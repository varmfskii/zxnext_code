<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2019 (Released January 1, 2019) -->
<HTML lang="EN">
<HEAD>
<TITLE>ZX Spectrum Next Registers</TITLE>
<META NAME="description" CONTENT="ZX Spectrum Next Registers">
<META NAME="keywords" CONTENT="zxnext_notes">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2019">

<LINK REL="STYLESHEET" HREF="zxnext_notes.css">

<LINK REL="next" HREF="node146.html">
<LINK REL="previous" HREF="node144.html">
<LINK REL="next" HREF="node146.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A
 HREF="node146.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="node144.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node144.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html1188"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A> 
<A ID="tex2html1190"
  HREF="node191.html">
<IMG WIDTH="43" HEIGHT="24" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A
 HREF="node146.html">AY-3-8912</A>
<B> Up:</B> <A
 HREF="node144.html">Registers</A>
<B> Previous:</B> <A
 HREF="node144.html">Registers</A>
 &nbsp; <B>  <A ID="tex2html1189"
  HREF="node1.html">Contents</A></B> 
 &nbsp; <B>  <A ID="tex2html1191"
  HREF="node191.html">Index</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H1><A ID="SECTION001210000000000000000">
ZX Spectrum Next Registers</A>
</H1>
The ZX Next stores configuration state in a field of registers. These
registers are accessible via two I/O ports or via the special nextreg
instructions.

<P>
Port $243B (9275) is used to set the register number, listed below.

<P>
Port $253B (9531) is used to access the register value.

<P>
Some registers are accessible only during the initialization process.

<P>
Register (R) $00 (00) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Machine ID

<UL>
<LI>00000001 = DE1A
</LI>
<LI>00000010 = DE2A
</LI>
<LI>00000101 = FBLABS
</LI>
<LI>00000110 = VTRUCCO
</LI>
<LI>00000111 = WXEDA
</LI>
<LI>00001000 = EMULATORS*
</LI>
<LI>00001010 = ZX Spectrum Next*
</LI>
<LI>00001011 = Multicore
</LI>
<LI>11101010 = ZX Spectrum Next on ZX-DOS fpga platform *
</LI>
<LI>11111010 = ZX Spectrum Next Anti-brick*
</LI>
</UL>
* Relevant for ZX Next machines &amp; software
Register (R) $01 (01) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Core Version
<table width="90%">
bits 7-4 = Major version number
bits 3-0 = Minor version number<tr><td valign="top">&nbsp;See register $0E for sub minor version number
</td></tr></table>

Register (R/W) $02 (02) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Reset
<BR>
Read

<UL>
<LI>bit 7 = Expansion bus <!-- MATH
 $\overline{\hbox{RESET}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img53.svg"
 ALT="$\overline{\hbox{RESET}}$"></SPAN> Asserted
</LI>
<LI>bits 6-2 = Reserved
</LI>
<LI>bit 1 = Last reset was Hard reset
</LI>
<LI>bit 0 = Last reset was Soft reset
</LI>
</UL>
Write

<UL>
<LI>bit 7 = Generate/Release Expansion bus <!-- MATH
 $\overline{\hbox{RESET}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img53.svg"
 ALT="$\overline{\hbox{RESET}}$"></SPAN>
</LI>
<LI>bits 6-2 = Reserved, must be 0
</LI>
<LI>bit 1 = generate Hard reset
</LI>
<LI>bit 0 = generate Soft reset
</LI>
</UL>
Register (R/W) $03 (03) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Machine Type
<BR>
A write to this register disables the boot rom in config mode
<BR>
bits 2-0 select machine type when in config mode
<table width="90%">
bit 7 = (W) Display Timing change enable (allow changes to
  bits 6-4) (0 on hard reset)
bits 6-4 = Display Timing
bit 3 = Display Timing user lock control
  <tr><td valign="top">&nbsp;Read
  
<UL>
<LI>0 = No user lock on display timing
</LI>
<LI>1 = User lock on display timing
  
</LI>
</UL>
  </td></tr>
<tr><td valign="top">&nbsp;Write
  
<UL>
<LI>1 = Apply user lock on display timing (0 on hard reset)
  
</LI>
</UL>
bits 2-1 = Machine Type</td></tr>
<tr><td valign="top">&nbsp;Machine Types/Display Timings
  
<UL>
<LI>000 or 001 = ZX 48K
</LI>
<LI>010 = ZX 128K/+2 (Grey)
</LI>
<LI>011 = ZX +2A-B/+3e/Next Native
</LI>
<LI>100 = Pentagon 128K
  
</LI>
</UL></td></tr></table>

Register (W) $04 (04) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Configuration Mapping
<table width="90%">
bits 7-5 = Reserved, must be 0
bits 4-0 = 16k SRAM bank mapping* ($00 on hard reset)<tr><td valign="top">&nbsp;*Maps a 16k SRAM bank over the bottom 16k. Applies only in
  config mode when the bootrom is disabled
</td></tr></table>

Register (R/W) $05 (05) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Peripheral 1 Settings

<UL>
<LI>bits 7-6 = joystick 1 mode (MSB)
</LI>
<LI>bits 5-4 = joystick 2 mode (MSB)
</LI>
<LI>bit 3 = joystick 1 mode (LSB)
</LI>
<LI>bit 2 = 50/60 Hz mode (0 = 50Hz, 1 = 60Hz)
</LI>
<LI>bit 1 = joystick 2 mode (LSB)
</LI>
<LI>bit 0 = Enable Scandoubler
</LI>
</UL>
Joystick modes

<UL>
<LI>000 = Sinclair 2 (67890)
</LI>
<LI>001 = Kempston 2 (port $37)
</LI>
<LI>010 = Kempston 1 (port $1F)
</LI>
<LI>011 = Megadrive 1 (port $1F)
</LI>
<LI>100 = Cursor
</LI>
<LI>101 = Megadrive 2 (port $37)
</LI>
<LI>110 = Sinclair 1 (12345)
</LI>
<LI>111 = I/O Mode
Both joysticks are places in I/O Mode if either is set to I/O
Mode. The underlying joystick type is not changed and reads of this
register will continue to return the last joystick type. Ehether the
joystick is in io mode or not is invisible but this state can be
cleared either through reset or by re-writing the gegister with
joystick type not equal to 111. Recovery time for a normal joystick
read after leaving I/O Mode is at most 64 scan lines.
</LI>
</UL>
Register (R/W) $06 (06) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Peripheral 2 Settings

<UL>
<LI>bit 7 = F8 CPU Speed Hotkey Enable (1 on reset)
</LI>
<LI>bit 6 = Enable classic audio mode (beep and tape to internal speaker,
  other audio to ear and HDMI, 3.01.02)
</LI>
<LI>bit 5 = F3 50Hz/60Hz Hotkey Enable (1 on reset)
</LI>
<LI>bit 4 = divMMC Automap/NMI Enable (0 on hard reset)
</LI>
<LI>bit 3 = NMI Button Enable (0 on hard reset)
</LI>
<LI>bit 2 = PS/2 Mode (0 = keyboard, 1 = mouse)
</LI>
<LI>bits 1-0 = PSG Mode (00 = YM, 01 = AY, 11 = hold all PSGs in Reset)
</LI>
</UL>
Register (R/W) $07 (07) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Turbo mode
<BR>
Read

<UL>
<LI>bits 7-6 = Reserved
</LI>
<LI>bits 5-4 = Current Actual CPU Speed
</LI>
<LI>bits 3-2 = Reserved
</LI>
<LI>bits 1-0 = Current Selected CPU Speed (00 on reset)
</LI>
</UL>
Write

<UL>
<LI>bits 7-2 = Reserved, must be 0
</LI>
<LI>bits 1-0 = Select CPU Speed
</LI>
</UL>
CPU Speeds

<UL>
<LI>00 = 3.5MHz
</LI>
<LI>01 = 7MHz
</LI>
<LI>10 = 14MHz
</LI>
<LI>11 = 28MHz
</LI>
</UL>
Register (R/W) $08 (08) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Peripheral 3 Settings

<UL>
<LI>bit 7 = 128K Banking Unlock (inverse of port $7FFD, bit 5) (0
  on reset)
</LI>
<LI>bit 6 = Disable RAM and Port Contention (0 on reset)
</LI>
<LI>bit 5 = PSG Stereo Mode Control (0 = ABC, 1 = ACB) (0 on hard
  reset)
</LI>
<LI>bit 4 = Enable internal speaker (1 on hard reset)
</LI>
<LI>bit 3 = Enable DACs (0 on hard reset)
</LI>
<LI>bit 2 = Enable read of port $FF (Timex) (0 on hard reset)
</LI>
<LI>bit 1 = Enable Multiple PSGs (0 on hard reset)
</LI>
<LI>bit 0 = Enable Issue 2 Keyboard
</LI>
</UL>
Register (R/W) $09 (09) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Peripheral 4 setting:
<table width="90%">
bit 7 = PSG 2 Mono Enable (0 on hard reset)
bit 6 = PSG 1 Mono Enable (0 on hard reset)
bit 5 = PSG 0 Mono Enable (0 on hard reset)
bit 4 = Sprite ID lockstep enable (1 = Nextreg $34 and IO Port
  $303B are in lockstep, 0 on reset)
bit 3 = divMMC mapRAM bit Control (reset bit 7 of port $E3)
bit 2 = HDMI audio mute (0 on hard reset)
bits 1-0 = scanlines
  
<UL>
<LI>00 = scanlines off
</LI>
<LI>01 = scanlines 12.5%
</LI>
<LI>10 = scanlines 25%
</LI>
<LI>11 = scanlines 50%
  
</LI>
</UL><tr><td valign="top">&nbsp;In Sprite lockstep, NextREG $34 and Port $303B are in
  lockstep
</td></tr></table>

Register (R/W) $0A (0A) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Peripheral 5 setting:

<UL>
<LI>bits 7-6 = Multiface type (00 on hard reset)
  
<UL>
<LI>00 = Multiface +3 (enable port 0x3F, disable port 0xBF)
</LI>
<LI>01 = Multiface 128 v87.2 (enable port 0xBF, disable port 0x3F)
</LI>
<LI>10 = Multiface 128 v87.12 (enable port 0x9F, disable port 0x1F)
</LI>
<LI>11 = Multiface 1 (enable port 0x9F, disable port 0x1F)
  
</LI>
</UL>
</LI>
<LI>bits 5-4 = Reserved, must be zero
</LI>
<LI>bit 3 = 1 to reverse left and right mouse buttons
</LI>
<LI>bits 1-0 = mouse dpi (00 on hard reset)
  
<UL>
<LI>00 = low dpi
</LI>
<LI>01 = default
</LI>
<LI>10 = medium dpi
</LI>
<LI>11 = high dpi
  
</LI>
</UL>
</LI>
</UL>
Register (R) $0E (0E) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Core Version (sub minor number)
<table width="90%">
bits 7-0 = Core sub minor version number<tr><td valign="top">&nbsp;(see register $01 for the major and minor version number)
</td></tr></table>

Register (R/W) $10 (10) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Core Boot
<BR>
Read

<UL>
<LI>bits 7-2 = Reserved
</LI>
<LI>bit 1 = Drive button pressed
</LI>
<LI>bit 0 = NMI button pressed
</LI>
</UL>
Write
<table width="90%">
bit 7 = Reboot FPGA using selected core (0 on reset)
bits 6-5 = Reserved, must be 0
bits 4-0 = Core ID<tr><td valign="top">&nbsp;Core ID with bits 4-0 can only be set in configuration mode
</td></tr></table>

Register (R/W) $11 (11) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Video Timing (writable in config mode only)
<table width="90%">
bits 7-3 = Reserved, must be 0
bits 2-0 = Mode (VGA = 0..6, HDMI = 7)
  
<UL>
<LI>000 = Base VGA timing, clk28 = 28000000
</LI>
<LI>001 = VGA setting 1, clk28 = 28571429
</LI>
<LI>010 = VGA setting 2, clk28 = 29464286
</LI>
<LI>011 = VGA setting 3, clk28 = 30000000
</LI>
<LI>100 = VGA setting 4, clk28 = 31000000
</LI>
<LI>101 = VGA setting 5, clk28 = 32000000
</LI>
<LI>110 = VGA setting 6, clk28 = 33000000
</LI>
<LI>111 = HDMI, clk28 = 27000000
  
</LI>
</UL><tr><td valign="top">&nbsp;50/60Hz selection depends on bit 2 of register $05</td></tr>
<tr><td valign="top">&nbsp;Only writable in config mode
</td></tr></table>

Register (R/W) $12 (12) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 2 Active RAM bank

<UL>
<LI>bits 7-6 = Reserved, must be 0
</LI>
<LI>bits 5-0 = RAM bank (point to bank 8 after a Reset, NextZXOS
  modifies to 9)
</LI>
</UL>
Register (R/W) $13 (13) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 2 Shadow RAM bank

<UL>
<LI>bits 7-6 = Reserved, must be 0
</LI>
<LI>bits 5-0 = RAM bank (point to bank 11 after a Reset, NextZXOS
  modifies to 12)
</LI>
</UL>
Register (R/W) $14 (14) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Global transparency color

<UL>
<LI>bits 7-0 = Transparency color value ($E3 after a reset)
</LI>
</UL>
(Note: this value is 8-bit, so the transparency is compared against
only by the MSB bits of the final 9-bit colour)
<BR>(Note2: this only affects Layer 2, ULA and LoRes. Sprites use register
$4B for transparency and tilemap uses nextreg $4C)
Register (R/W) $15 (15) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite and Layer System Setup

<UL>
<LI>bit 7 = LoRes mode (0 on reset)
</LI>
<LI>bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on
  top) (0 on reset)
</LI>
<LI>bit 5 = Enable sprite clipping in over border mode (0 on reset)
</LI>
<LI>bits 4-2 = set layers priorities (000 on reset)
  
<UL>
<LI>000 - S L U
</LI>
<LI>001 - L S U
</LI>
<LI>010 - S U L
</LI>
<LI>011 - L U S
</LI>
<LI>100 - U S L
</LI>
<LI>101 - U L S
</LI>
<LI>110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7
</LI>
<LI>111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]
  
</LI>
</UL>
</LI>
<LI>bit 1 = Enable Sprites Over border (0 on reset)
</LI>
<LI>bit 0 = Enable Sprites (0 on reset)
</LI>
</UL>
Register (R/W) $16 (16) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 2 Horizontal Scroll Control

<UL>
<LI>bits 7-0 = X Offset (0-255)(0 on reset)
</LI>
</UL>
Register (R/W) $17 (17) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 2 Vertical Scroll Control

<UL>
<LI>bits 7-0 = Y Offset (0-191)(0 on reset)
</LI>
</UL>
Register (R/W) $18 (18) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 2 Clip Window Definition

<UL>
<LI>bits 7-0 = Coords of the clip window
  <table width="90%">  <tr><td valign="top">&nbsp;1st write - X1 position
  </td></tr>
<tr><td valign="top">&nbsp;2nd write - X2 position
  </td></tr>
<tr><td valign="top">&nbsp;3rd write - Y1 position
  </td></tr>
<tr><td valign="top">&nbsp;4rd write - Y2 position
  </td></tr></table>
</LI>
</UL>
Reads do not advance the clip position
<BR>
The values are 0,255,0,191 after a Reset
Register (R/W) $19 (19) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Clip Window Definition

<UL>
<LI>bits 7-0 = Cood. of the clip window
  <table width="90%">  <tr><td valign="top">&nbsp;1st write - X1 position
  </td></tr>
<tr><td valign="top">&nbsp;2nd write - X2 position
  </td></tr>
<tr><td valign="top">&nbsp;3rd write - Y1 position
  </td></tr>
<tr><td valign="top">&nbsp;4rd write - Y2 position
  </td></tr></table>
</LI>
</UL>
The values are 0,255,0,191 after a Reset
<BR>
Reads do not advance the clip position

<P>
When the clip window is enabled for sprites in "over border" mode, the
X coords are internally doubled and the clip window origin is moved to
the sprite origin inside the border.
Register (R/W) $1A (1A) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 0 (ULA/LoRes) Clip Window Definition

<UL>
<LI>bits 7-0 = Coord. of the clip window
  <table width="90%">  <tr><td valign="top">&nbsp;1st write = X1 position
  </td></tr>
<tr><td valign="top">&nbsp;2nd write = X2 position
  </td></tr>
<tr><td valign="top">&nbsp;3rd write = Y1 position
  </td></tr>
<tr><td valign="top">&nbsp;4rd write = Y2 position
  </td></tr></table>
</LI>
</UL>
The values are 0,255,0,191 after a Reset
<BR>
Reads do not advance the clip position
Register (R/W) $1B (1B) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 3 (Tilemap) Clip Window Definition

<UL>
<LI>bits 7-0 = Coord. of the clip window
  <table width="90%">  <tr><td valign="top">&nbsp;1st write = X1 position
  </td></tr>
<tr><td valign="top">&nbsp;2nd write = X2 position
  </td></tr>
<tr><td valign="top">&nbsp;3rd write = Y1 position
  </td></tr>
<tr><td valign="top">&nbsp;4rd write = Y2 position
  </td></tr></table>
</LI>
</UL>
The values are 0,159,0,255 after a Reset
<BR>
Reads do not advance the clip position
<BR>
The X coords are internally doubled.
Register (R/W) $1C (1C) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Clip Window Control
<BR>
Read

<UL>
<LI>bits 7-6 = Layer 3 Clip Index
</LI>
<LI>bits 5-4 = Layer 0/1 Clip Index
</LI>
<LI>bits 3-2 = Sprite clip index
</LI>
<LI>bits 1-0 = Layer 2 Clip Index
</LI>
</UL>
Write

<UL>
<LI>bits 7-4 = Reserved, must be 0
</LI>
<LI>bit 3 - reset Layer 3 clip index
</LI>
<LI>bit 2 - reset Layer 0/1 clip index
</LI>
<LI>bit 1 - reset sprite clip index.
</LI>
<LI>bit 0 - reset Layer 2 clip index.
</LI>
</UL>
Register (R) $1E (1E) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Active video line (MSB)

<UL>
<LI>bits 7-1 = Reserved
</LI>
<LI>bit 0 = Active line MSB
</LI>
</UL>
Register (R) $1F (1F) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Active video line (LSB)

<UL>
<LI>bits 7-0 = Active line LSB (0-255)
</LI>
</UL>
Register (R/W) $22 (22) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Line Interrupt control

<UL>
<LI>bit 7 = (R) ULA asserting interrupt
</LI>
<LI>bit 7 = (W) Reserved, must be 0
</LI>
<LI>bits 6-3 = Reserved, must be 0
</LI>
<LI>bit 2 = Disable ULA Interrupt (0 on reset)
</LI>
<LI>bit 1 = Enable Line Interrupt (0 on reset)
</LI>
<LI>bit 0 = MSB of Line Interrupt line value (0 on reset)
</LI>
</UL>
Register (R/W) $23 (23) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Line Interrupt value LSB

<UL>
<LI>bits 7-0 = Line Interrupt line value LSB (0-255)(0 on reset)
</LI>
</UL>
Register (R/W) $26 (26) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> ULA Horizontal Scroll Control

<UL>
<LI>bits 7-0 = ULA X Offset (0-255) (0 on reset)
</LI>
</UL>
Register (R/W) $27 (27) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> ULA Vertical Scroll Control

<UL>
<LI>bits 7-0 = ULA Y Offset (0-191) (0 on reset)
</LI>
</UL>
Register (R/W) $28 (28) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Stored Palette Value and PS/2 Keymap Address MSB
<BR>
Read

<UL>
<LI>bits 7-0 = Stored palette value (see NextREG $44)
</LI>
</UL>
Write  

<UL>
<LI>bits 7-1 = Reserved, must be 0
</LI>
<LI>bit 0 = PS/2 Keymap Address MSB
</LI>
</UL>
Register (W) $29 (29) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> PS/2 Keymap Address LSB

<UL>
<LI>bits 7-0 = PS/2 Keymap Address LSB
</LI>
</UL>
Register (W) $2A (2A) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> PS/2 Keymap Data MSB

<UL>
<LI>bits 7-1 = Reserved, must be 0
</LI>
<LI>bit 0 = PS/2 Keymap Data MSB
</LI>
</UL>
Register (W) $2B (2B) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> PS/2 Keymap Data LSB

<UL>
<LI>bits 7-0 = PS/2 Keymap Data LSB
</LI>
</UL>
(writing this register auto-increments the address)
Register (R/W) $2C (2C) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> DAC B Mirror (Left)/ I<SUP>2</SUP>S Left Sample MSB
<BR>
Read

<UL>
<LI>bits 7-0 =  I<SUP>2</SUP>S Left Sample MSB
</LI>
</UL>
Write

<UL>
<LI>bits 7-0 = 8-bit sample left DAC ($80 on reset)
</LI>
</UL>
Register (R/W) $2D (2D) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> DAC A+D Mirror (mono/ I<SUP>2</SUP>S Sample LSB
<BR>
Read

<UL>
<LI>bits 7-0 =  I<SUP>2</SUP>S Last Sample LSB
</LI>
</UL>
Write

<UL>
<LI>bits 7-0 = 8-bit sample DACs A + D ($80 on reset)
</LI>
</UL>
Register (R/W) $2E (2E) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> DAC C Mirror (Right/ I<SUP>2</SUP>S Risht Sample MSB
<BR>
Read

<UL>
<LI>bits 7-0 =  I<SUP>2</SUP>S Right Sameple MSB
</LI>
</UL>
Write

<UL>
<LI>bits 7-0 = 8-bit sample Right DACs C ($80 on reset)
</LI>
</UL>
Register (R/W) $2F (2F) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 3 (Tilemap) Horizontal Scroll Control MSB

<UL>
<LI>bits 7-2 = Reserved, must be 0
</LI>
<LI>bits 1-0 = X Offset MSB ($00 on reset)
</LI>
</UL>
Meaningful Range is 0-319 in 40 char mode, 0-639 in 80 char mode
Register (R/W) $30 (30) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 3 (Tilemap) Horizontal Scroll Control LSB

<UL>
<LI>bits 7-0 = X Offset LSB ($00 on reset)
</LI>
</UL>
Meaningful range is 0-319 in 40 char mode, 0-639 in 80 char mode
Register (R/W) $31 (31) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 3 (Tilemap) Vertical Scroll Control

<UL>
<LI>bits 7-0 = Y Offset (0-255) )$00 on reset)
</LI>
</UL>
Register (R/W) $32 (32) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 1,0 (LoRes) Horizontal Scroll Control)

<UL>
<LI>bits 7-0 = X Offset (0-255) ($00 on reset)
</LI>
</UL>
Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and
smoothness as Layer 2.
Register (R/W) $33 (33) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 1,0 (LoRes) Vertical Scroll Control)

<UL>
<LI>bits 7-0 = Y Offset (0-191) ($00 on reset)
</LI>
</UL>
Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and
smoothness as Layer 2.
Register (R/W) $34 (34) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Number
<BR>
Lockstep (NextReg $09 bit 4 set)
<table width="90%">
bit 7 = Pattern address offset (Add 128 to pattern address)
bits 6-0 = Sprite number 0-127, Pattern number 0-63<tr><td valign="top">&nbsp;effectively performs an out to port $303B
</td></tr></table>

No Lockstep (NextReg $09 bit 4 clear)

<UL>
<LI>bit 7 = Reserved, must be 0
</LI>
<LI>bits 6-0 = Sprite number 0-127
</LI>
</UL>
This register selects which sprite has its attributes connected to the
sprite attribute registers
Register (W) $35 (35) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 0

<UL>
<LI>bits 7-0 = Sprite X coordinate LSB (MSB in NextReg $37)
</LI>
</UL>
Register (W) $36 (36) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 1

<UL>
<LI>bits 7-0 = Sprite Y coordinate LSB (MSB in NextReg $39)
</LI>
</UL>
Register (W) $37 (37) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 2

<UL>
<LI>bits 7-4 = 4-bit Palette offset
</LI>
<LI>bit 3 = Enable horizontal mirror (reverse)
</LI>
<LI>bit 2 = Enable vertical mirror (reverse)
</LI>
<LI>bit 1 = Enable 90<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img36.svg"
 ALT="$^O$"></SPAN> Clockwise Rotation
</LI>
</UL>
Normal Sprites

<UL>
<LI>bit 0 = X coordinate MSB
</LI>
</UL>
Relative Sprites

<UL>
<LI>bit 0 = Palette offset is relative to anchor sprite
</LI>
</UL>
Rotation is applied before mirroring
Register (W) $38 (38) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 3

<UL>
<LI>bit 7 = Enable Visiblity
</LI>
<LI>bit 6 = Enable Attribute 4 (0 = Attribute 4 effectively $00)
</LI>
<LI>bits 5-0 = Sprite Pattern Number
</LI>
</UL>
Register (W) $39 (39) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 4
<BR>
Normal Sprites

<UL>
<LI>bit 7 = 4-bit pattern switch (0 = 8-bit sprite, 1 = 4-bit sprite)
</LI>
<LI>bit 6 = Pattern number bit-7 for 4-bit, 0 for 8-bit
</LI>
<LI>bit 5 = Type of attached relative sprites (0 = Composite, 1 =
  Unified)
</LI>
<LI>bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
</LI>
<LI>bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
</LI>
<LI>bit 0 = MSB of Y coordinate
</LI>
</UL>
Relative, Composite Sprites

<UL>
<LI>bit 7-6 = 01
</LI>
<LI>bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit
</LI>
<LI>bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
</LI>
<LI>bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
</LI>
<LI>bit 0 = Pattern number is relative to anchor
</LI>
</UL>
Relative, Unified Sprites

<UL>
<LI>bit 7-6 = 01
</LI>
<LI>bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit
</LI>
<LI>bits 4-1 = 0000
</LI>
<LI>bit 0 = Pattern number is relative to anchor
</LI>
</UL>
Register (R/W) $40 (40) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Palette Index Select

<UL>
<LI>bits 7-0 = Palette Index Number
</LI>
</UL>
Selects the palette index to change the associated colour

<P>
For ULA only, INKs are mapped to indices 0 through 7, BRIGHT INKs to
indices 8 through 15, PAPERs to indices 16 through 23 and BRIGHT
PAPERs to indices 24 through 31.  In EnhancedULA mode, INKs come from
a subset of indices from 0 through 127 and PAPERs from a subset of
indices from 128 through 255.

<P>
The number of active indices depends on the number of attribute bits
assigned to INK and PAPER out of the attribute byte.

<P>
In ULAplus mode, the last 64 entries (indices 192 to 255) hold the
ULAplus palette.  The ULA always takes border colour from PAPER for
standard ULA and Enhanced ULA
Register (R/W) $41 (41) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> 8-bit Palette Data

<UL>
<LI>bits 7-0 = Colour Entry in RRRGGGBB format
</LI>
</UL>
The lower blue bit of the 9-bit internal colour will be the logical or
of bits 0 and 1 of the 8-bit entry. After each write, the palette
index auto-increments if aut-increment has been enabled (NextReg $43
bit 7), Reads do not auto-increment.
Register (R/W) $42 (42) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> ULANext Attribute Byte Format

<UL>
<LI>bits 7-0 = Attribute byte's INK representation mask (7 on reset)
</LI>
</UL>
The mask can only indicate a solid sequence of bits on the right side
of the attribute byte (1, 3, 7, 15, 31, 63, 127 or 255).

<P>
INKs are mapped to base index 0 in the palette and PAPERs and border
are mapped to base index 128 in the palette.

<P>
The 255 value enables the full ink colour mode making all the palette
entries INK. PAPER and border both take on the fallback colour
(nextreg $4A) in this mode.
Register (R/W) $43 (43) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Palette Control

<UL>
<LI>bit 7 = Disable palette write auto-increment.
</LI>
<LI>bits 6-4 = Select palette for reading or writing:
  
<UL>
<LI>000 = ULA first palette
</LI>
<LI>100 = ULA second palette
</LI>
<LI>001 = Layer 2 first palette
</LI>
<LI>101 = Layer 2 second palette
</LI>
<LI>010 = Sprite first palette
</LI>
<LI>110 = Sprite second palette
</LI>
<LI>011 = Layer 3 first palette
</LI>
<LI>111 = Layer 3 second palette
  
</LI>
</UL>
</LI>
<LI>bit 3 = Select Sprite palette (0 = first palette, 1 = second
  palette)
</LI>
<LI>bit 2 = Select Layer 2 palette (0 = first palette, 1 = second
  palette)
</LI>
<LI>bit 1 = Select ULA palette (0 = first palette, 1 = second
  palette)
</LI>
<LI>bit 0 = Enable EnhancedULA mode if 1. (0 after a reset)
</LI>
</UL>
Register (R/W) $44 (44) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> 9-bit Palette Data
<BR>
Non Level 2
<table width="90%"><tr><td valign="top">&nbsp;1st write
bits 7-0 = MSB (RRRGGGBB)</td></tr>
<tr><td valign="top">&nbsp;2nd write
bits 7-1 = Reserved, must be 0
bit 0 = LSB (B)
</td></tr></table>

Level 2
<table width="90%"><tr><td valign="top">&nbsp;1st write
bits 7-0 = MSB (RRRGGGBB)</td></tr>
<tr><td valign="top">&nbsp;2nd write
bit 7 = Priority
bits 6-1 = Reserved, must be 0
bit 0 = LSB (B)
</td></tr></table>

9-bit Palette Data is entered in two consecutive writes; the second
write autoincrements the palette index if auto-increment is enabled in
NextREG $43 bit 7

<P>
If writing an L2 palette, the second write's D7 holds the L2 priority
bit which if set (1) brings the colour defined at that index on top of
all other layers. If you also need the same colour in regular priority
(for example: for enviromental masking) you will have to set it up
again, this time with no priority.

<P>
Reads return the second byte and do not autoincrement. Writes to
nextreg $40, $41, $41, or $43 reset to the first write.
Register (R/W) $4A (4A) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Fallback Colour Value

<UL>
<LI>bits 7-0 = 8-bit colour if all layers are transparent ($E3 on
  reset)
</LI>
</UL>
(black on reset = 0)
Register (R/W) $4B (4B) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Transparency Index

<UL>
<LI>bits 7-0 = Index value ($E3 if reset)
</LI>
</UL>
For 4-bit sprites only the bottom 4-bits are relevant.
Register (R/W) $4C (4C) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Level 3 Transparency Index

<UL>
<LI>bits 7-4 = Reserved, must be 0
</LI>
<LI>bits 3-0 = Index value ($0F on reset)
</LI>
</UL>
Register (R/W) $50 (50) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 0 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $0000 to $1FFF ($ff on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.
<BR>
A 255 value causes the ROM to become visible.
Register (R/W) $51 (51) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 1 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $2000 to $3FFF ($ff on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.
<BR>
A 255 value causes the ROM to become visible.
Register (R/W) $52 (52) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 2 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $4000 to $5FFF ($0A on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.
Register (R/W) $53 (53) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 3 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $6000 to $7FFF ($0B on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.
Register (R/W) $54 (54) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 4 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $8000 to $9FFF ($04 on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.
Register (R/W) $55 (55) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 5 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $A000 to $BFFF ($05 on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.
Register (R/W) $56 (56) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 6 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $C000 to $DFFF ($00 on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.
Register (R/W) $57 (57) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 7 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $E000 to $FFFF ($01 on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.

<P>
Writing to ports $1FFD, $7FFD and $DFFD writes $FF to MMU0 and
MMU1 and writes appropriate values to MMU6 and MMU7 to map in the
selected 16k bank.

<P>
+3 special modes override the MMUs if used.
Register (W) $60 (60) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Copper Data 8-bit Write

<UL>
<LI>bits 7-0 = Byte to write to copper instruction memory
</LI>
</UL>
Note that each copper instruction is two bytes long, after a write,
the coppen address is auto-incremented to the next memory position.

<P>
After a write, the index is auto-incremented to the next memory position.
Register (W) $61 (61) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Copper Address LSB

<UL>
<LI>bits 7-0 = Copper instruction memory address LSB (0 on reset)
</LI>
</UL>
Register (W) $62 (62) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Copper Control

<UL>
<LI>bits 7-6 = Start Control
  <table width="90%">  <tr><td valign="top">&nbsp;00 = Copper fully stopped
  </td></tr>
<tr><td valign="top">&nbsp;01 = Copper start, execute the list from index 0, and loop
    to the start
  </td></tr>
<tr><td valign="top">&nbsp;10 = Copper start, execute the list from last point, and
    loop to the start
  </td></tr>
<tr><td valign="top">&nbsp;11 = Copper start, execute the list from index 0, and
    restart the list when the raster reaches position (0,0)
  </td></tr></table>

</LI>
<LI>bits 2-0 = Copper instruction memory address (MSB) (0 on reset)
</LI>
</UL>
Register (W) $63 (63) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Copper Data 16-bit Write

<UL>
<LI>bits 7-0 = Byte to write to copper instruction memory
</LI>
</UL>
The 16-bit value is written in pairs. The first 8-bits are the MSB and
are destined for an even copper instruction address. The sesond 8-bits
are the LSB and are destined for an odd copper instruction address.

<P>
After each write, the copper address is auto-incremented to the next
memory position.

<P>
After a write to an odd address, the all 16-bits are written to copper
memory at once.
Register (R/W) $64 (64) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Vertical Line Count Offset (3.01.05)
<table width="90%">
bits 7-0 = Offset added to the vertical line counter<tr><td valign="top">&nbsp;affects copper, line interrupt and active line
  count.
<BR>
Normally the ula's pixel row 0 aligns with vertical line count 0.
  With a non-zero offset, the ula's pixel row 0 will align with the
  vertical line offset.
<BR>
Eg, if the offset is 32 then vertical line 32 will correspond to
  the first pixel row in the ula and vertical line 0 will align with
  the first pixel row of the tilemap and sprites.
</td></tr></table>

* Since a change in offset takes effect when the ula reaches row 0,
the change can take up to one frame to occur.
Register (R/W) $68 (68) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> ULA Control
<table width="90%">
bit 7 = Disable ULA output (0 on reset)
bit 6-5 = Color blending control for layering modes 6 &amp; 7

<UL>
<LI>00 = ULA as blend colour
</LI>
<LI>01 = No blending
</LI>
<LI>10 = ULA/Tilemap mix result as blend colour
</LI>
<LI>11 = Tilemap as blend colour
</LI>
</UL>
bit 4 = Cancel entries in 8x5 matrix for extended keys (3.01.04)
bit 3 = Enable ULAplus (0 on reset)
bit 2 = Enable ULA half pixel scroll (0 on reset)<tr><td valign="top">&nbsp;may change
bit 1 = Reserved (must be 0)
bit 0 = Enable stencil mode (0 on reset)</td></tr>
<tr><td valign="top">&nbsp;When ULA and Layer 3 are enabled, if either are transparent,
  the result is transparent, otherwise the result is the logical AND
  of both colours.
</td></tr></table>

Register (R/W) $69 (69) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Display Control 1

<UL>
<LI>bit 7 = Layer 2 Enable (Port $123B bit 1 alias)
</LI>
<LI>bit 6 = ULA Shadow display enable (Port $7FFD bit 3 alias)
</LI>
<LI>bits 5-0 = Timex alias (Port $FF alias)
</LI>
</UL>
Register (R/W) $6A (6A) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 1,0 (LoRes) Control

<UL>
<LI>bits 7-6 = reserved, must be 0
</LI>
<LI>bit 5 = Enable Radistan (16-colour) (0 on reset)
</LI>
<LI>bit 4 = Radistan DFILE switch (xor with bit 0 of port $ff) (0
  on reset)
</LI>
<LI>bits 3-0 = Radistsan palette offset (0 on reset)
</LI>
<LI>bits 1-0 = ULAplus palette offset (0 on reset)
</LI>
</UL>
Register (R/W) $6B (6B) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 3 (Tilemap) Control

<UL>
<LI>bit 7 = Layer 3 Enable (0 on reset)
</LI>
<LI>bit 6 = Layer 3 Size control (0 on reset)
  
<UL>
<LI>0 = 40x32
</LI>
<LI>1 = 80x32
  
</LI>
</UL>
</LI>
<LI>bit 5 = Disable Arrtibute Entry (0 on reset)
</LI>
<LI>bit 4 = palette select (0 on reset)
</LI>
<LI>bit 3 = Enable Text mode (1-bit tilemap) (0 on reset)
</LI>
<LI>bit 2 = Reserved, must be 0
</LI>
<LI>bit 1 = Activate 512 tile mode (0 on reset)
</LI>
<LI>bit 0 = Enable Layer 3 on top of ULA (0 on reset)
</LI>
</UL>
Register (R/W) $6C (6C) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Default Layer 3 Attribute*

<UL>
<LI>bits 7-4 = Palette Offset ($00 on reset)
</LI>
<LI>bit 3 = X mirror (0 on reset)
</LI>
<LI>bit 2 = Y mirror (0 on reset)
</LI>
<LI>bit 1 = Rotate (0 on reset)
</LI>
<LI>bit 0 = Bit 8 of the tile number (512 tile mode) (0 on reset)
</LI>
<LI>bit 0 = ULA over tilemap (256 tile mode) (0 on reset)
</LI>
</UL>
*Active tile attribute if bit 5 of nextreg $6B is set.
Register (R/W) $6E (6E) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 3 Tilemap Base Address

<UL>
<LI>bits 7-6 = Read back as zero, write values ignored
</LI>
<LI>bits 5-0 = MSB of address of the tilemap in Bank 5 ($2C on
  reset)
</LI>
</UL>
Soft Reset default $2C - This is because the address is $6C00 so the
MSB is $6C. But the stored value is only the lower 6 bits so it's an
offset into the 16k Bank 5. To calculate therefore subtract $40
leaving you with $2C.

<P>
The value written is an offset into the 16k Bank 5 allowing the
tilemap to be placed at any multiple of 256 bytes.  Writing a physical
MSB address in $40 - $7F or $C0 - $FF range is permitted.

<P>
The value read back should be treated as having a fully significant
8-bit value.
Register (R/W) $6F (6F) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 3 Tile Definitions Base Address

<UL>
<LI>bits 7-6 = Read back as zero, write values ignored
</LI>
<LI>bits 5-0 = MSB of address of the tilemap in Bank 5 ($0C on
  reset)
</LI>
</UL>
Soft Reset default $0C - This is because the address is $4C00 so the
MSB is $4C. But the stored value is only the lower 6 bits so it's an
offset into the 16k Bank 5. To calculate therefore subtract $40
leaving you with $0C.

<P>
The value written is an offset into the 16k Bank 5 allowing the
tilemap to be placed at any multiple of 256 bytes.  Writing a physical
MSB address in $40 - $7F or $C0 - $FF range is permitted.

<P>
The value read back should be treated as having a fully significant
8-bit value.
Register (R/W) $70 (70) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 2 Control

<UL>
<LI>bits 7-6 = Reserved, must be 0
</LI>
<LI>bits 5-4 = Resolution (00 on soft reset)
  
<UL>
<LI>00 = <!-- MATH
 $256\times192\times256$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img4.svg"
 ALT="$256\times192\times256$"></SPAN>
</LI>
<LI>01 = <!-- MATH
 $320\times256\times256$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img5.svg"
 ALT="$320\times256\times256$"></SPAN>
</LI>
<LI>10 = <!-- MATH
 $640\times256\times16$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img25.svg"
 ALT="$640\times256\times16$"></SPAN>
</LI>
<LI>11 = Do not use
  
</LI>
</UL>
</LI>
<LI>bits 3-0 = Palette offset ($0 on soft reset)
</LI>
</UL>
Register (W) $75 (75) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 0 (Auto-incrementing)
<BR>
See nextreg $35
Register (W) $76 (76) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 1 (Auto-incrementing)
<BR>
See nextreg $36
Register (W) $77 (77) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 2 (Auto-incrementing)
<BR>
See nextreg $37
Register (W) $78 (78) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 3 (Auto-incrementing)
<BR>
See nextreg $38
Register (W) $79 (79) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 4 (Auto-incrementing)
<BR>
See nextreg $39
Register (R/W) $7F (7F) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> User Register 0

<UL>
<LI>bits 7-0 = User Register ($FF on reset)
</LI>
</UL>

<P>
Caution NextReg numbers above $7F are inaccessible to the Copper
Register (R/W) $80 (80) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Expansion Bus Enable
<BR>
Immediate

<UL>
<LI>bit 7 = Expansion Bus Enable (0 on hard reset)
</LI>
<LI>bit 6 = Enable ROMCS ROM replacement from divmmc banks 14/15
  (experimental, 3.01.03)
</LI>
<LI>bit 5 = I/O cycle Disable/Ignore <!-- MATH
 $\overline{\hbox{IORQULA}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img140.svg"
 ALT="$\overline{\hbox{IORQULA}}$"></SPAN> (0 on
  hard reset)
</LI>
<LI>bit 4 = Memory cycle Disable/Ignore <!-- MATH
 $\overline{\hbox{ROMCS}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img141.svg"
 ALT="$\overline{\hbox{ROMCS}}$"></SPAN> (0 on
  hard reset)
</LI>
</UL>
After Soft Reset (Copied into bits 7-4)

<UL>
<LI>bit 3 = Expansion Bus Enable (0 on hard reset)
</LI>
<LI>bit 2 = Enable ROMCS ROM replacement from divmmc banks 14/15
  (experimental, 3.01.03)
</LI>
<LI>bit 1 = I/O cycle Disable/Ignore <!-- MATH
 $\overline{\hbox{IORQULA}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img140.svg"
 ALT="$\overline{\hbox{IORQULA}}$"></SPAN> (0 on
  hard reset)
</LI>
<LI>bit 0 = Memory cycle Disable/Ignore <!-- MATH
 $\overline{\hbox{ROMCS}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img141.svg"
 ALT="$\overline{\hbox{ROMCS}}$"></SPAN> (0 on
  hard reset)
</LI>
</UL>
Register (R/W) $81 (81) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Expansion Bus Control

<UL>
<LI>bit 7 = (R) Expansion bus <!-- MATH
 $\overline{\hbox{ROMCS}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img141.svg"
 ALT="$\overline{\hbox{ROMCS}}$"></SPAN> asserted
</LI>
<LI>bit 6 = Allow peripherials to override the ULA on some even
  port reads (Rotoronics Wafadrive)
</LI>
<LI>bit 5 = Disable expansion bus NMI debounce (Opus Discovery)
</LI>
<LI>bit 4 = (W) Propagate max CPU clock at all times (0 on hard
  reset)
</LI>
<LI>bits 3-2 = Reserved, must be 0
</LI>
<LI>bits 1-0 = Max CPU Speed when Expansion Bus is enabled ($00 on
  hard reset, currently fixed at $00)
  
<UL>
<LI>00 = 3.5 MHz
</LI>
<LI>01 = 7 MHz
</LI>
<LI>10 = 14 MHz
</LI>
<LI>11 = 28 MHz
  
</LI>
</UL>
</LI>
</UL>
Register (R/W) $82 (82) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Internal Port decoding control 1/4

<UL>
<LI>bit 7 = Enable Kempston Port 2 (Port $37) (1 on reset)
</LI>
<LI>bit 6 = Enable Kempston Port 1 (Port $1F) (1 on reset)
</LI>
<LI>bit 5 = Enable DMA (Port $6B) (1 on reset)
</LI>
<LI>bit 4 = Enable +3 Floating Bus (1 on reset)
</LI>
<LI>bit 3 = Enable +3 Paging (Port $1FFD) (1 on reset)
</LI>
<LI>bit 2 = Enable Next Memory Paging (Port $DFFD) (1 on reset)
</LI>
<LI>bit 1 = Enable Paging (Port $7FFD) (1 on reset)
</LI>
<LI>bit 0 = Enable Timex (Port $FF) (1 on reset)
</LI>
</UL>
Register (R/W) $83 (83) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Internal Port decoding control 2/4

<UL>
<LI>bit 7 = Enable Layer 2 (Port $123B) (1 on reset)
</LI>
<LI>bit 6 = Enable Sprites (Ports $57, $5B, $303B) (1 on reset)
</LI>
<LI>bit 5 = Enable Kempston Mouse (Ports $FADF, $FBDF, $FFDF) (1
  on reset)
</LI>
<LI>bit 4 = Enable UART (Ports $133B, $143B, $153B) (1 on reset)
</LI>
<LI>bit 3 = Enable SPI (Ports $E7, $EB) (1 on reset)
</LI>
<LI>bit 2 = Enable  I<SUP>2</SUP>C (Ports $103B, $113B) (1 on reset)
</LI>
<LI>bit 1 = Enable Multiface (two variable ports) (1 on reset)
</LI>
<LI>bit 0 = Enable divMMC (Port $E3) (1 on reset)
</LI>
</UL>
Register (R/W) $84 (84) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Internal Port decoding control 3/4

<UL>
<LI>bit 7 = Enable SPECdrum Mono DAC (Port $DF) (1 on reset)
</LI>
<LI>bit 6 = Enable Covox/GS Mono DAC (Port $B3) (1 on reset)
</LI>
<LI>bit 5 = Enable Pentagon/ATM DAC (Port $FB) (1 on reset)
</LI>
<LI>bit 4 = Enable Covox Stereo DAC (Ports $0F, $4F) (1 on reset)
</LI>
<LI>bit 3 = Enable Profi/Covox Stereo DAC (Ports $3F, $5F) (1 on
  reset)
</LI>
<LI>bit 2 = Enable Soundrive DAC Mode 2 (Ports $F1, $F3, $F9,
  $FB) (1 on reset)
</LI>
<LI>bit 1 = Enable Soundrive DAC Mode 1 (Ports $0F, $1F, $4F,
  $5F) (1 on reset)
</LI>
<LI>bit 0 = Enable AY (Ports $FFFD, $BFFD) (1 on reset)
</LI>
</UL>
Register (R/W) $85 (85) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Internal Port decoding control 4/4

<UL>
<LI>bit 7 = Enable configuration of port decoding on soft reset (3.01.01)
</LI>
<LI>bits 6-4 = Reserved
</LI>
<LI>bit 3 = Enable Z80 CTC ports $183B, $193B, $1A3B, $1B3B, $1C3B,
  $1D3B, $1E3B, and $1F3B
</LI>
<LI>bit 2 = Enable Pentagon 1024 memory port $EFF7
</LI>
<LI>bit 1 = Enable DMA port $0B (3.01.02)
</LI>
<LI>bit 0 = Enable ULAplus (Ports $BF3B, $FF3B) (1 on reset)
</LI>
</UL>
Register (R/W) $86 (86) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Expansion Port decoding control 1/4

<UL>
<LI>bit 7 = Enable Kempston Port 2 (Port $37) (1 on reset)
</LI>
<LI>bit 6 = Enable Kempston Port 1 (Port $1F) (1 on reset)
</LI>
<LI>bit 5 = Enable DMA (Port $6B) (1 on reset)
</LI>
<LI>bit 4 = Enable +3 Floating Bus (1 on reset)
</LI>
<LI>bit 3 = Enable +3 Paging (Port $1FFD) (1 on reset)
</LI>
<LI>bit 2 = Enable Next Memory Paging (Port $DFFD) (1 on reset)
</LI>
<LI>bit 1 = Enable Paging (Port $7FFD) (1 on reset)
</LI>
<LI>bit 0 = Enable Timex (Port $FF) (1 on reset)
</LI>
</UL>
Register (R/W) $87 (87) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Expansion Port decoding control 2/4

<UL>
<LI>bit 7 = Enable Layer 2 (Port $123B) (1 on reset)
</LI>
<LI>bit 6 = Enable Sprites (Ports $57, $5B, $303B) (1 on reset)
</LI>
<LI>bit 5 = Enable Kempston Mouse (Ports $FADF, $FBDF, $FFDF) (1
  on reset)
</LI>
<LI>bit 4 = Enable UART (Ports $133B, $143B, $153B) (1 on reset)
</LI>
<LI>bit 3 = Enable SPI (Ports $E7, $EB) (1 on reset)
</LI>
<LI>bit 2 = Enable  I<SUP>2</SUP>C (Ports $103B, $113B) (1 on reset)
</LI>
<LI>bit 1 = Enable Multiface (two variable ports) (1 on reset)
</LI>
<LI>bit 0 = Enable divMMC (Port $E3) (1 on reset)
</LI>
</UL>
Register (R/W) $88 (88) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Expansion Port decoding control 3/4

<UL>
<LI>bit 7 = Enable SPECdrum Mono DAC (Port $DF) (1 on reset)
</LI>
<LI>bit 6 = Enable Covox/GS Mono DAC (Port $B3) (1 on reset)
</LI>
<LI>bit 5 = Enable Pentagon/ATM DAC (Port $FB) (1 on reset)
</LI>
<LI>bit 4 = Enable Covox Stereo DAC (Ports $0F, $4F) (1 on reset)
</LI>
<LI>bit 3 = Enable Profi/Covox Stereo DAC (Ports $3F, $5F) (1 on
  reset)
</LI>
<LI>bit 2 = Enable Soundrive DAC Mode 2 (Ports $F1, $F3, $F9,
  $FB) (1 on reset)
</LI>
<LI>bit 1 = Enable Soundrive DAC Mode 1 (Ports $0F, $1F, $4F,
  $5F) (1 on reset)
</LI>
<LI>bit 0 = Enable AY (Ports $FFFD, $BFFD) (1 on reset)
</LI>
</UL>
Register (R/W) $89 (89) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Expansion Port decoding control 4/4

<UL>
<LI>bit 7 = Enable configuration of port decoding on soft reset (3.01.01)
</LI>
<LI>bits 6-4 = Reserved
</LI>
<LI>bit 3 = Enable Z80 CTC ports $183B, $193B, $1A3B, $1B3B, $1C3B,
  $1D3B, $1E3B, and $1F3B
</LI>
<LI>bit 2 = Enable Pentagon 1024 memory port $EFF7
</LI>
<LI>bit 1 = Enable DMA port $0B (3.01.02)
</LI>
<LI>bit 0 = Enable ULAplus (Ports $BF3B, $FF3B) (1 on reset)
</LI>
</UL>

<P>
The Internal Port Decoding Enables always apply.

<P>
When the Expansion Bus is enabled, the Expansion Bus Port Decoding
Enables are logically ANDed with the Internal Enables. A result of 0
for the corresponding bit indicates the internal device is
<SPAN  CLASS="textit">disabled</SPAN>. If the Expansion Bus is enabled, this allows
I/O cycles for disabled ports to propagate to the Expansion Bus,
otherwise corresponding I/O cycles to the Expansion Bus are filtered.
Register (R/W) $8A (8A) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Expansion Bus I/O Propagate Control

<UL>
<LI>bits 7-3 = Reserved, must be 0
</LI>
<LI>bit 4 = Propagate port $FF I/O Cycles (0 on hard reset, 3.01.02)
</LI>
<LI>bit 3 = Propagate port $1FFD I/O Cycles (0 on hard reset)
</LI>
<LI>bit 2 = Propagate port $DFFD I/O Cycles (0 on hard reset)
</LI>
<LI>bit 1 = Propagate port $7FFD I/O Cycles (0 on hard reset)
</LI>
<LI>bit 0 = Propagate port $FE I/O Cycles (1 on hard reset, 3.01.03:
  0 on hard reset)
</LI>
</UL>
Register (R/W) $8C (8C) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Alternate ROM
<BR>
Immediate

<UL>
<LI>bit 7 = Alt ROM Enable (0 on hard reset)
</LI>
<LI>bit 6 = Alt ROM visible ONLY during writes (0 on hard reset)
</LI>
<LI>bit 5 = Reserved, must be 0
</LI>
<LI>bit 4 = 48k ROM Lock (0 on hard reset)
</LI>
</UL>
After Soft Reset (copied into bits 7-4)

<UL>
<LI>bit 3 = Alt ROM Enable (0 on hard reset)
</LI>
<LI>bit 2 = Alt ROM visible ONLY during writes (0 on hard reset)
</LI>
<LI>bit 1 = Reserved, must be 0
</LI>
<LI>bit 0 = 48k ROM Lock (0 on hard reset)
</LI>
</UL>
Register (R/W) $8E (8E) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Legacy Memory Paging Control (3.01.01)
<table width="90%">
bit 7 = Bank number bit 3
bit 6-4 = Bank number bits 2-0
bit 3 = Enable change ram page (read as 1)
bit 2 = Paging mode

<UL>
<LI>0 = Normal paging mode
</LI>
<LI>1 = Special paging mode (lot bit of memory configuration)
</LI>
</UL><tr><td valign="top">&nbsp;Normal Paging Mode
bits 1-0 = ROM selection</td></tr>
<tr><td valign="top">&nbsp;Special (all RAM) Paging Mode
bits 1-0 = RAM configuration selection
</td></tr></table>

Register (R/W) $90 (90) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO output enable 1/4

<UL>
<LI>bit 7 = Enable Pin 7 (0 on reset)
</LI>
<LI>bit 6 = Enable Pin 6 (0 on reset)
</LI>
<LI>bit 5 = Enable Pin 5 (0 on reset)
</LI>
<LI>bit 4 = Enable Pin 4 (0 on reset)
</LI>
<LI>bit 3 = Enable Pin 3 (0 on reset)
</LI>
<LI>bit 2 = Enable Pin 2 (0 on reset)
</LI>
<LI>bit 1 = Enable Pin 1 (cannot be enabled) (0 on reset)
</LI>
<LI>bit 0 = Enable Pin 0 (cannot be enabled) (0 on reset)
</LI>
</UL>
Register (R/W) $91 (91) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO output enable 2/4

<UL>
<LI>bit 7 = Enable Pin 15 (0 on reset)
</LI>
<LI>bit 6 = Enable Pin 14 (0 on reset)
</LI>
<LI>bit 5 = Enable Pin 13 (0 on reset)
</LI>
<LI>bit 4 = Enable Pin 12 (0 on reset)
</LI>
<LI>bit 3 = Enable Pin 11 (0 on reset)
</LI>
<LI>bit 2 = Enable Pin 10 (0 on reset)
</LI>
<LI>bit 1 = Enable Pin 9 (0 on reset)
</LI>
<LI>bit 0 = Enable Pin 8 (0 on reset)
</LI>
</UL>
Register (R/W) $92 (92) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO output enable 3/4

<UL>
<LI>bit 7 = Enable Pin 23 (0 on reset)
</LI>
<LI>bit 6 = Enable Pin 22 (0 on reset)
</LI>
<LI>bit 5 = Enable Pin 21 (0 on reset)
</LI>
<LI>bit 4 = Enable Pin 20 (0 on reset)
</LI>
<LI>bit 3 = Enable Pin 19 (0 on reset)
</LI>
<LI>bit 2 = Enable Pin 18 (0 on reset)
</LI>
<LI>bit 1 = Enable Pin 17 (0 on reset)
</LI>
<LI>bit 0 = Enable Pin 16 (0 on reset)
</LI>
</UL>
Register (R/W) $93 (93) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO output enable 4/4

<UL>
<LI>bits 7-4 = Reserved
</LI>
<LI>bit 3 = Enable Pin 27 (0 on reset)
</LI>
<LI>bit 2 = Enable Pin 26 (0 on reset)
</LI>
<LI>bit 1 = Enable Pin 25 (0 on reset)
</LI>
<LI>bit 0 = Enable Pin 24 (0 on reset)
</LI>
</UL>
Register (R/W) $98 (98) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO Pin State 1/4

<UL>
<LI>bit 7 = Pin 7 Data (1 on reset)
</LI>
<LI>bit 6 = Pin 6 Data (1 on reset)
</LI>
<LI>bit 5 = Pin 5 Data (1 on reset)
</LI>
<LI>bit 4 = Pin 4 Data (1 on reset)
</LI>
<LI>bit 3 = Pin 3 Data (1 on reset)
</LI>
<LI>bit 2 = Pin 2 Data (1 on reset)
</LI>
<LI>bit 1 = Pin 1 Data (1 on reset)
</LI>
<LI>bit 0 = Pin 0 Data (1 on reset)
</LI>
</UL>
Register (R/W) $99 (99) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO Pin State 2/4

<UL>
<LI>bit 7 = Pin 15 Data (1 on reset)
</LI>
<LI>bit 6 = Pin 14 Data (1 on reset)
</LI>
<LI>bit 5 = Pin 13 Data (1 on reset)
</LI>
<LI>bit 4 = Pin 12 Data (1 on reset)
</LI>
<LI>bit 3 = Pin 11 Data (1 on reset)
</LI>
<LI>bit 2 = Pin 10 Data (1 on reset)
</LI>
<LI>bit 1 = Pin 9 Data (1 on reset)
</LI>
<LI>bit 0 = Pin 8 Data (1 on reset)
</LI>
</UL>
Register (R/W) $9A (9A) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO Pin State 3/4

<UL>
<LI>bit 7 = Pin 23 Data (1 on reset)
</LI>
<LI>bit 6 = Pin 22 Data (1 on reset)
</LI>
<LI>bit 5 = Pin 21 Data (1 on reset)
</LI>
<LI>bit 4 = Pin 20 Data (1 on reset)
</LI>
<LI>bit 3 = Pin 19 Data (1 on reset)
</LI>
<LI>bit 2 = Pin 18 Data (1 on reset)
</LI>
<LI>bit 1 = Pin 17 Data (1 on reset)
</LI>
<LI>bit 0 = Pin 16 Data (1 on reset)
</LI>
</UL>
Register (R/W) $9B (9B) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO Pin State 4/4

<UL>
<LI>bits 7-4 = Reserved
</LI>
<LI>bit 3 = Pin 27 Data (1 on reset)
</LI>
<LI>bit 2 = Pin 26 Data (1 on reset)
</LI>
<LI>bit 1 = Pin 25 Data (1 on reset)
</LI>
<LI>bit 0 = Pin 24 Data (1 on reset)
</LI>
</UL>
Register (R/W) $A0 (A0) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Pi Peripheral Enable

<UL>
<LI>bits 7-6 = Reserved, must be 0
</LI>
<LI>bit 5 = Enable UART on GPIO 14, 15 (0 on reset)*
</LI>
<LI>bit 4 = Communication Type (0 on reset)
  
<UL>
<LI>0 = Rx to GPIO 15, Tx to GPIO 14 (Pi)
</LI>
<LI>1 = Rx to GPIO 14, Tx to GPIO 15 (Pi Hats)
  
</LI>
</UL>
</LI>
<LI>bit 3 = Enable  I<SUP>2</SUP>C on GPIO 2, 3 (0 on reset)*
</LI>
<LI>bits 2-1 = Reserved, must be 0
</LI>
<LI>bit 0 = Enable SPI on GPIO 7, 8, 9, 10, 11 (0 on reset)*
</LI>
</UL>
*Overrides GPIO Enables
Register (R/W) $A2 (A2) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Pi  I<SUP>2</SUP>S Audio Control

<UL>
<LI>bits 7-6 =  I<SUP>2</SUP>S State ($00 on reset)
  
<UL>
<LI>00 =  I<SUP>2</SUP>S Disabled
</LI>
<LI>01 =  I<SUP>2</SUP>S is mono, source R
</LI>
<LI>10 =  I<SUP>2</SUP>S is mono, source L
</LI>
<LI>11 =  I<SUP>2</SUP>S is stereo
  
</LI>
</UL>
</LI>
<LI>bit 5 = Reserved, must be 0
</LI>
<LI>bit 4 = Audio Flow Direction (0 on reset)
  
<UL>
<LI>0 = PCM_DOUT to Pi, PCM_DIN from Pi (Hats)
</LI>
<LI>1 = PCM_DOUT from Pi, PCM_DIN to Pi (Pi)
  
</LI>
</UL>
</LI>
<LI>bit 3 = Mute left (0 on reset)
</LI>
<LI>bit 2 = Mute right (0 on reset)
</LI>
<LI>bit 1 = Reserved must be 1 (3.01.05)
</LI>
<LI>bit 0 = Direct  I<SUP>2</SUP>S audio to EAR on port $FE (0 on reset)
</LI>
</UL>
Register (R/W) $A3 (A3) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Pi  I<SUP>2</SUP>S Clock Divide (Master Mode) (removed in 3.01.05)

<UL>
<LI>bits 7-0 = Clock divide value ($0B on reset)
</LI>
</UL>
<!-- MATH
 $\hbox{Divider}=\frac{538461}{\hbox{Rate}}-1$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img142.svg"
 ALT="$\hbox{Divider}=\frac{538461}{\hbox{Rate}}-1$"></SPAN> or
<!-- MATH
 $\hbox{Rate}=\frac{538461}{\hbox{Divider}+1}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img143.svg"
 ALT="$\hbox{Rate}=\frac{538461}{\hbox{Divider}+1}$"></SPAN>
Register (R) $B0 (B0) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Extended Keys 0 (3.01.05)

<UL>
<LI>bit 7 = 1 if ; pressed
</LI>
<LI>bit 6 = 1 if pressed
</LI>
<LI>bit 5 = 1 if , pressed
</LI>
<LI>bit 4 = 1 if . pressed
</LI>
<LI>bit 3 = 1 if UP pressed
</LI>
<LI>bit 2 = 1 if DOWN pressed
</LI>
<LI>bit 1 = 1 if LEFT pressed
</LI>
<LI>bit 0 = 1 if RIGHT pressed
</LI>
</UL>
Register (R) $B1 (B1) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Extended Keys 1 (3.01.05)

<UL>
<LI>bit 7 = 1 if DELETE pressed
</LI>
<LI>bit 6 = 1 if EDIT pressed
</LI>
<LI>bit 5 = 1 if BREAK pressed
</LI>
<LI>bit 4 = 1 if INV VIDEO pressed
</LI>
<LI>bit 3 = 1 if TRUE VIDEO pressed
</LI>
<LI>bit 2 = 1 if GRAPH pressed
</LI>
<LI>bit 1 = 1 if CAPS LOCK pressed
</LI>
<LI>bit 0 = 1 if EXTEND pressed
</LI>
</UL>
Register (W) $FF (FF) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img7.svg"
 ALT="$\Rightarrow$"></SPAN> Debug LEDs (DE-1, DE-2 am Multicore only)

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A
 HREF="node146.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="node144.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node144.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html1188"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A> 
<A ID="tex2html1190"
  HREF="node191.html">
<IMG WIDTH="43" HEIGHT="24" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A
 HREF="node146.html">AY-3-8912</A>
<B> Up:</B> <A
 HREF="node144.html">Registers</A>
<B> Previous:</B> <A
 HREF="node144.html">Registers</A>
 &nbsp; <B>  <A ID="tex2html1189"
  HREF="node1.html">Contents</A></B> 
 &nbsp; <B>  <A ID="tex2html1191"
  HREF="node191.html">Index</A></B> </DIV>
<!--End of Navigation Panel-->

</BODY>
</HTML>
