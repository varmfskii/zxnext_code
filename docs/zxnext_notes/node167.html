<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2020.2 (Released July 1, 2020) -->
<HTML lang="en">
<HEAD>
<TITLE>ZX Spectrum Next Registers</TITLE>
<META NAME="description" CONTENT="ZX Spectrum Next Registers">
<META NAME="keywords" CONTENT="zxnext_notes">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2020.2">

<LINK REL="STYLESHEET" HREF="zxnext_notes.css">

<LINK REL="next" HREF="node168.html">
<LINK REL="previous" HREF="node166.html">
<LINK REL="next" HREF="node168.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A
 HREF="node168.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="node166.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node166.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html1358"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A> 
<A ID="tex2html1360"
  HREF="node234.html">
<IMG WIDTH="43" HEIGHT="24" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A
 HREF="node168.html">AY-3-8912</A>
<B> Up:</B> <A
 HREF="node166.html">Registers</A>
<B> Previous:</B> <A
 HREF="node166.html">Registers</A>
 &nbsp; <B>  <A ID="tex2html1359"
  HREF="node1.html">Contents</A></B> 
 &nbsp; <B>  <A ID="tex2html1361"
  HREF="node234.html">Index</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H1><A ID="SECTION001410000000000000000">
ZX Spectrum Next Registers</A>
</H1>
The ZX Next stores configuration state in a field of registers. These
registers are accessible via two I/O ports or via the special nextreg
instructions.

<P>
Port $243B (9275) is used to set the register number, listed below.

<P>
Port $253B (9531) is used to access the register value.

<P>
Some registers are accessible only during the initialization process.

<P>
Register (R) $00 (00) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Machine ID

<UL>
<LI>00000001 = DE1A
</LI>
<LI>00000010 = DE2A
</LI>
<LI>00000101 = FBLABS
</LI>
<LI>00000110 = VTRUCCO
</LI>
<LI>00000111 = WXEDA
</LI>
<LI>00001000 = EMULATORS
</LI>
<LI>00001010 = ZX Spectrum Next
</LI>
<LI>00001011 = Multicore
</LI>
<LI>10101010 = ZX Spectrum Next Core on unAmiga
</LI>
<LI>10111010 = ZX Spectrum Next Core on SiDi
</LI>
<LI>11001010 = ZX Spectrum Next Core on MIST
</LI>
<LI>11011010 = ZX Spectrum Next Core on MiSTer
</LI>
<LI>11011010 = ZX Spectrum Next Core on unAmiga Reloaded
</LI>
<LI>11101010 = ZX Spectrum Next Core on ZX-DOS
</LI>
<LI>11111010 = ZX Spectrum Next Anti-brick
</LI>
</UL>
Register (R) $01 (01) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Core Version
<table width="90%">
bits 7-4 = Major version number
bits 3-0 = Minor version number<tr><td valign="top">&nbsp;See register $0E for sub minor version number
</td></tr></table>

<P>
Register (R/W) $02 (02) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Reset
<BR>
Read

<UL>
<LI>bit 7 = Expansion bus <!-- MATH
 $\overline{\hbox{RESET}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img4.svg"
 ALT="$\overline {\hbox {RESET}}$"></SPAN> Asserted
</LI>
<LI>bits 6-5 = Reserved
</LI>
<LI>bit 4 = Multiface <!-- MATH
 $\overline{\hbox{NMI}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img5.svg"
 ALT="$\overline {\hbox {NMI}}$"></SPAN> generated by I/O trap
(experimental) (3.01.11)
</LI>
<LI>bit 3 = Indicates multiface <!-- MATH
 $\overline{\hbox{NMI}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img5.svg"
 ALT="$\overline {\hbox {NMI}}$"></SPAN> was generated by this
nextreg (3.01.09)
</LI>
<LI>bit 2 = Indicates divmmc <!-- MATH
 $\overline{\hbox{NMI}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img5.svg"
 ALT="$\overline {\hbox {NMI}}$"></SPAN> was generated by this
nextreg (3.01.09)
</LI>
<LI>bit 1 = Last reset was Hard reset
</LI>
<LI>bit 0 = Last reset was Soft reset
</LI>
</UL>
Write

<UL>
<LI>bit 7 = Hold Expansion bus and ESP <!-- MATH
 $\overline{\hbox{RESET}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img4.svg"
 ALT="$\overline {\hbox {RESET}}$"></SPAN>
</LI>
<LI>bits 6-5 = Reserved, must be 0
</LI>
<LI>bit 4 = clear I/O trap (experimental)(3.01.10)
</LI>
<LI>bit 3 = Generate multiface <!-- MATH
 $\overline{\hbox{NMI}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img5.svg"
 ALT="$\overline {\hbox {NMI}}$"></SPAN> **
(write zero to clear) (3.01.09)
</LI>
<LI>bit 2 = Generate divmmc <!-- MATH
 $\overline{\hbox{NMI}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img5.svg"
 ALT="$\overline {\hbox {NMI}}$"></SPAN> **
(write zero to clear) (3.01.09)
</LI>
<LI>bit 1 = generate Hard reset * (reboot)
</LI>
<LI>bit 0 = generate Soft reset *
</LI>
</UL>
* Hard reset has precedence
<BR>** These signals are ignored if the multiface, divmmc, dma or
external <!-- MATH
 $\overline{\hbox{NMI}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img5.svg"
 ALT="$\overline {\hbox {NMI}}$"></SPAN> master is active
Register (R/W) $03 (03) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Machine Type
<BR>
A write to this register disables the boot rom
<BR>
bits 2-0 select machine type when in config mode
<table width="90%">
bit 7 = (W) Display Timing change enable (allow changes to
  bits 6-4) (0 on hard reset)
bits 6-4 = Display Timing
bit 3 = Display Timing user lock control
  <tr><td valign="top">&nbsp;Read
  
<UL>
<LI>0 = No user lock on display timing
</LI>
<LI>1 = User lock on display timing
  
</LI>
</UL>
  </td></tr>
<tr><td valign="top">&nbsp;Write
  
<UL>
<LI>1 = Apply user lock on display timing (0 on hard reset)
  
</LI>
</UL>
bits 2-0 = Machine Type (config mode only)
<BR>
determines roms loaded</td></tr>
<tr><td valign="top">&nbsp;Machine Types/Display Timings
  
<UL>
<LI>000 or 001 = ZX 48K
</LI>
<LI>010 = ZX 128K/+2 (Grey)
</LI>
<LI>011 = ZX +2A-B/+3e/Next Native
</LI>
<LI>100 = Pentagon 128K
  
</LI>
</UL></td></tr></table>

<P>
Register (W) $04 (04) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Configuration Mapping
<table width="90%">
bits 7 = Reserved, must be 0
bits 6-0 = 16k SRAM bank mapping* ($00 on hard reset)<tr><td valign="top">&nbsp;* Maps a 16k SRAM bank over the bottom 16k. Applies only in
  config mode when the bootrom is disabled</td></tr>
<tr><td valign="top">&nbsp;** Odd multiples of 256k are unreliable if storing data in sram
  for the mext core started.</td></tr>
<tr><td valign="top">&nbsp;*** number of useful bits changed from 5 to 7 in coure 3.01.06
</td></tr></table>

<P>
Register (R/W) $05 (05) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Peripheral 1 Settings

<UL>
<LI>bits 7-6 = joystick 1 mode (MSB)
</LI>
<LI>bits 5-4 = joystick 2 mode (MSB)
</LI>
<LI>bit 3 = joystick 1 mode (LSB)
</LI>
<LI>bit 2 = 50/60 Hz mode (0 = 50Hz, 1 = 60Hz)
</LI>
<LI>bit 1 = joystick 2 mode (LSB)
</LI>
<LI>bit 0 = Enable Scandoubler
</LI>
</UL>
Joystick modes

<UL>
<LI>000 = Sinclair 2 (67890)
</LI>
<LI>001 = Kempston 2 (port $37)
</LI>
<LI>010 = Kempston 1 (port $1F)
</LI>
<LI>011 = Megadrive 1 (port $1F)
</LI>
<LI>100 = Cursor
</LI>
<LI>101 = Megadrive 2 (port $37)
</LI>
<LI>110 = Sinclair 1 (12345)
</LI>
<LI>111 = User Defined Keys Joystick
</LI>
</UL>
<table width="90%"><tr><td align="right" valign="top">*</td><td valign="top">&nbsp;Joysticks can be placed in i/o mode via nextreg 0x0B.</td></tr>
<tr><td align="right" valign="top">*</td><td valign="top">&nbsp;Programming the user defined keys joystick is done through the ps2
keymap interface on nextreg 0x28, 0x29 and 0x2B:
</td></tr></table>

<OL>
<LI>Write 128 to nextreg 0x28
</LI>
<LI>Write 0 (left joystick) or 16 (right joystick) to nextreg 0x29
</LI>
<LI>Write eleven bytes to nextreg 0x2B. The bytes correspond to the eleven
buttons on an md pad (X=11 Z Y START A C B U D L R=1)
</LI>
<LI>Each byte written identifies a key in the 8x7 membrane; bits 5:3 select
the row and bits 2:0 select the column with 111 meaning no action.
<BR>*
In all joystick modes, excess buttons on an md pad not read via ports
will generate key input if so programmed.
</LI>
</OL>

<P>
Register (R/W) $06 (06) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Peripheral 2 Settings

<UL>
<LI>bit 7 = Enable F8 cpu speed hotkey (soft reset = 1)
</LI>
<LI>bit 6 = Divert BEEP only to internal speaker (hard reset = 0)
</LI>
<LI>bit 5 = Enable F3 50/60 Hz hotkey (soft reset = 1)
</LI>
<LI>bit 4 = Enable divmmc nmi by DRIVE button (hard reset = 0)
</LI>
<LI>bit 3 = Enable multiface nmi by M1 button (hard reset = 0)
</LI>
<LI>bit 2 = PS/2 mode (config mode only)

<UL>
<LI>0 = keyboard primary
</LI>
<LI>1 = mouse primary
</LI>
</UL>
</LI>
<LI>bits 1-0 = Audio chip mode

<UL>
<LI>00 = YM
</LI>
<LI>01 = AY
</LI>
<LI>11 = Hold all AY in reset
</LI>
</UL>
</LI>
</UL>

<P>
Register (R/W) $07 (07) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Turbo mode
<BR>
Read

<UL>
<LI>bits 7-6 = Reserved
</LI>
<LI>bits 5-4 = Current Actual CPU Speed
</LI>
<LI>bits 3-2 = Reserved
</LI>
<LI>bits 1-0 = Current Selected CPU Speed (00 on reset)
</LI>
</UL>
Write

<UL>
<LI>bits 7-2 = Reserved, must be 0
</LI>
<LI>bits 1-0 = Select CPU Speed
</LI>
</UL>
CPU Speeds

<UL>
<LI>00 = 3.5MHz
</LI>
<LI>01 = 7MHz
</LI>
<LI>10 = 14MHz
</LI>
<LI>11 = 28MHz
</LI>
</UL>

<P>
Register (R/W) $08 (08) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Peripheral 3 Settings

<UL>
<LI>bit 7 = 128K Banking Unlock (inverse of port $7FFD, bit 5) (0
  on reset)
</LI>
<LI>bit 6 = Disable RAM and Port Contention (0 on reset)
</LI>
<LI>bit 5 = PSG Stereo Mode Control (0 = ABC, 1 = ACB) (0 on hard
  reset)
</LI>
<LI>bit 4 = Enable internal speaker (1 on hard reset)
</LI>
<LI>bit 3 = Enable DACs (0 on hard reset)
</LI>
<LI>bit 2 = Enable read of port $FF (Timex) (0 on hard reset)
</LI>
<LI>bit 1 = Enable Multiple PSGs (0 on hard reset)
</LI>
<LI>bit 0 = Enable Issue 2 Keyboard
</LI>
</UL>

<P>
Register (R/W) $09 (09) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Peripheral 4 setting:
<table width="90%">
bit 7 = PSG 2 Mono Enable (0 on hard reset)
bit 6 = PSG 1 Mono Enable (0 on hard reset)
bit 5 = PSG 0 Mono Enable (0 on hard reset)
bit 4 = Sprite ID lockstep enable (1 = Nextreg $34 and IO Port
  $303B are in lockstep, 0 on reset)
bit 3 = divMMC mapRAM bit Control (reset bit 7 of port $E3)
bit 2 = HDMI audio mute (0 on hard reset)
bits 1-0 = scanlines
  
<UL>
<LI>00 = scanlines off
</LI>
<LI>01 = scanlines 12.5%
</LI>
<LI>10 = scanlines 25%
</LI>
<LI>11 = scanlines 50%
  
</LI>
</UL><tr><td valign="top">&nbsp;In Sprite lockstep, NextREG $34 and Port $303B are in
  lockstep
</td></tr></table>

<P>
Register (R/W) $0A (0A) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Peripheral 5 setting:

<UL>
<LI>bits 7-6 = Multiface type (00 on hard reset)
  
<UL>
<LI>00 = Multiface +3 (enable port 0x3F, disable port 0xBF)
</LI>
<LI>01 = Multiface 128 v87.2 (enable port 0xBF, disable port 0x3F)
</LI>
<LI>10 = Multiface 128 v87.12 (enable port 0x9F, disable port 0x1F)
</LI>
<LI>11 = Multiface 1 (enable port 0x9F, disable port 0x1F)
  
</LI>
</UL>
</LI>
<LI>bit 5 = Reserved, must be zero
</LI>
<LI>bit 4 = Enable divmmc automap (hard reset = 0) (3.01.10)
</LI>
<LI>bit 3 = 1 to reverse left and right mouse buttons (3.01.07)
</LI>
<LI>bit 2 = Reserved, must be 0
</LI>
<LI>bits 1-0 = mouse dpi (00 on hard reset) (3.01.05)
  
<UL>
<LI>00 = low dpi
</LI>
<LI>01 = default
</LI>
<LI>10 = medium dpi
</LI>
<LI>11 = high dpi
  
</LI>
</UL>
</LI>
</UL>

<P>
Register (R/W) $0B (0B) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Joystick I/O Mode

<UL>
<LI>bit 7 = 1 to enable i/o mode
</LI>
<LI>bit 6 = Reserved, must be 0
</LI>
<LI>bits 5-4 = I/O Mode
  
<UL>
<LI>00 = bit bang
</LI>
<LI>01 = clock
</LI>
<LI>10 = uart on left joystick port
</LI>
<LI>11 = uart on right joystick port
  
</LI>
</UL>
</LI>
<LI>bits 3-1 = Reserved, must be 0
</LI>
<LI>bit 0 = Parameter
  <table width="90%">  <tr><td valign="top">&nbsp;bit bang : copied to pin 7
  </td></tr>
<tr><td valign="top">&nbsp;clock
    
<UL>
<LI>0 = hold high when clock becomes high
</LI>
<LI>1 = run *
    
</LI>
</UL>
  </td></tr>
<tr><td valign="top">&nbsp;uart
    
<UL>
<LI>0 = redirect esp uart0 to joystick
</LI>
<LI>1 = redirect pi uart1 to joystick
<BR>      (Tx out on pin 7, Rx in from pin 9, CTS_n in from pin 6 **)
    
</LI>
</UL></td></tr></table>
</LI>
</UL>
The state of output pin 7 is stored internally in a register and is
retained across changing modes and while i/o mode is disabled.  While
in i/o mode, keyboard joystick types (Sinclair, Cursor, etc) produce
no readings but the current state of pins can still be read via the
Kempston ports.  When leaving i/o mode, joystick operation resumes
after&nbsp;64 scan lines have passed.
<BR>* CTC channel 3 is currently used to drive pin 7 in clock mode.  Freq
= Fctc3 / 2.
<BR>** CTS_n is only active if the seleced uart is in hw flow control mode.
Register (R) $0E (0E) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Core Version (sub minor number)
<table width="90%">
bits 7-0 = Core sub minor version number<tr><td valign="top">&nbsp;(see register $01 for the major and minor version number)
</td></tr></table>

<P>
Register (R/W) $10 (10) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Core Boot
<BR>
Read

<UL>
<LI>bits 7-2 = Reserved
</LI>
<LI>bit 1 = Drive button pressed
</LI>
<LI>bit 0 = <!-- MATH
 $\overline{\hbox{NMI}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img5.svg"
 ALT="$\overline {\hbox {NMI}}$"></SPAN> button pressed
</LI>
</UL>
Write
<table width="90%">
bit 7 = Reboot FPGA using selected core (0 on reset)
bits 6-5 = Reserved, must be 0
bits 4-0 = Core ID<tr><td valign="top">&nbsp;Core ID with bits 4-0 can only be set in configuration mode
</td></tr></table>

<P>
Register (R/W) $11 (11) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Video Timing (writable in config mode only)
<table width="90%">
bits 7-3 = Reserved, must be 0
bits 2-0 = Mode (VGA = 0..6, HDMI = 7)
  
<UL>
<LI>000 = Base VGA timing, clk28 = 28000000
</LI>
<LI>001 = VGA setting 1, clk28 = 28571429
</LI>
<LI>010 = VGA setting 2, clk28 = 29464286
</LI>
<LI>011 = VGA setting 3, clk28 = 30000000
</LI>
<LI>100 = VGA setting 4, clk28 = 31000000
</LI>
<LI>101 = VGA setting 5, clk28 = 32000000
</LI>
<LI>110 = VGA setting 6, clk28 = 33000000
</LI>
<LI>111 = HDMI, clk28 = 27000000
  
</LI>
</UL><tr><td valign="top">&nbsp;50/60Hz selection depends on bit 2 of register $05</td></tr>
<tr><td valign="top">&nbsp;Only writable in config mode
</td></tr></table>

<P>
Register (R/W) $12 (12) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 2 Active RAM bank

<UL>
<LI>bits 7-6 = Reserved, must be 0
</LI>
<LI>bits 5-0 = RAM bank (point to bank 8 after a Reset, NextZXOS
  modifies to 9)
</LI>
</UL>

<P>
Register (R/W) $13 (13) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 2 Shadow RAM bank

<UL>
<LI>bits 7-6 = Reserved, must be 0
</LI>
<LI>bits 5-0 = RAM bank (point to bank 11 after a Reset, NextZXOS
  modifies to 12)
</LI>
</UL>

<P>
Register (R/W) $14 (14) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Global transparency color

<UL>
<LI>bits 7-0 = Transparency color value ($E3 after a reset)
</LI>
</UL>
(Note: this value is 8-bit, so the transparency is compared against
only by the MSB bits of the final 9-bit colour)
<BR>(Note2: this only affects Layer 2, ULA and LoRes. Sprites use register
$4B for transparency and tilemap uses nextreg $4C)

<P>
Register (R/W) $15 (15) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite and Layer System Setup

<UL>
<LI>bit 7 = LoRes mode (0 on reset)
</LI>
<LI>bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on
  top) (0 on reset)
</LI>
<LI>bit 5 = Enable sprite clipping in over border mode (0 on reset)
</LI>
<LI>bits 4-2 = set layers priorities (000 on reset)
  
<UL>
<LI>000 - S L U
</LI>
<LI>001 - L S U
</LI>
<LI>010 - S U L
</LI>
<LI>011 - L U S
</LI>
<LI>100 - U S L
</LI>
<LI>101 - U L S
</LI>
<LI>110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7
</LI>
<LI>111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]
  
</LI>
</UL>
</LI>
<LI>bit 1 = Enable Sprites Over border (0 on reset)
</LI>
<LI>bit 0 = Enable Sprites (0 on reset)
</LI>
</UL>

<P>
Register (R/W) $16 (16) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 2 Horizontal Scroll Control

<UL>
<LI>bits 7-0 = X Offset (0-255)(0 on reset)
</LI>
</UL>

<P>
Register (R/W) $17 (17) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 2 Vertical Scroll Control

<UL>
<LI>bits 7-0 = Y Offset (0-191)(0 on reset)
</LI>
</UL>

<P>
Register (R/W) $18 (18) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 2 Clip Window Definition

<UL>
<LI>bits 7-0 = Coords of the clip window
  <table width="90%">  <tr><td valign="top">&nbsp;1st write - X1 position
  </td></tr>
<tr><td valign="top">&nbsp;2nd write - X2 position
  </td></tr>
<tr><td valign="top">&nbsp;3rd write - Y1 position
  </td></tr>
<tr><td valign="top">&nbsp;4rd write - Y2 position
  </td></tr></table>
</LI>
</UL>
Reads do not advance the clip position
<BR>
The values are 0,255,0,191 after a Reset

<P>
Register (R/W) $19 (19) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Clip Window Definition

<UL>
<LI>bits 7-0 = Cood. of the clip window
  <table width="90%">  <tr><td valign="top">&nbsp;1st write - X1 position
  </td></tr>
<tr><td valign="top">&nbsp;2nd write - X2 position
  </td></tr>
<tr><td valign="top">&nbsp;3rd write - Y1 position
  </td></tr>
<tr><td valign="top">&nbsp;4rd write - Y2 position
  </td></tr></table>
</LI>
</UL>
The values are 0,255,0,191 after a Reset
<BR>
Reads do not advance the clip position

<P>
When the clip window is enabled for sprites in "over border" mode, the
X coords are internally doubled and the clip window origin is moved to
the sprite origin inside the border.

<P>
Register (R/W) $1A (1A) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 0 (ULA/LoRes) Clip Window Definition

<UL>
<LI>bits 7-0 = Coord. of the clip window
  <table width="90%">  <tr><td valign="top">&nbsp;1st write = X1 position
  </td></tr>
<tr><td valign="top">&nbsp;2nd write = X2 position
  </td></tr>
<tr><td valign="top">&nbsp;3rd write = Y1 position
  </td></tr>
<tr><td valign="top">&nbsp;4rd write = Y2 position
  </td></tr></table>
</LI>
</UL>
The values are 0,255,0,191 after a Reset
<BR>
Reads do not advance the clip position

<P>
Register (R/W) $1B (1B) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 3 (Tilemap) Clip Window Definition

<UL>
<LI>bits 7-0 = Coord. of the clip window
  <table width="90%">  <tr><td valign="top">&nbsp;1st write = X1 position
  </td></tr>
<tr><td valign="top">&nbsp;2nd write = X2 position
  </td></tr>
<tr><td valign="top">&nbsp;3rd write = Y1 position
  </td></tr>
<tr><td valign="top">&nbsp;4rd write = Y2 position
  </td></tr></table>
</LI>
</UL>
The values are 0,159,0,255 after a Reset
<BR>
Reads do not advance the clip position
<BR>
The X coords are internally doubled.

<P>
Register (R/W) $1C (1C) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Clip Window Control
<BR>
Read

<UL>
<LI>bits 7-6 = Layer 3 Clip Index
</LI>
<LI>bits 5-4 = Layer 0/1 Clip Index
</LI>
<LI>bits 3-2 = Sprite clip index
</LI>
<LI>bits 1-0 = Layer 2 Clip Index
</LI>
</UL>
Write

<UL>
<LI>bits 7-4 = Reserved, must be 0
</LI>
<LI>bit 3 - reset Layer 3 clip index
</LI>
<LI>bit 2 - reset Layer 0/1 clip index
</LI>
<LI>bit 1 - reset sprite clip index.
</LI>
<LI>bit 0 - reset Layer 2 clip index.
</LI>
</UL>

<P>
Register (R) $1E (1E) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Active video line (MSB)

<UL>
<LI>bits 7-1 = Reserved
</LI>
<LI>bit 0 = Active line MSB
</LI>
</UL>

<P>
Register (R) $1F (1F) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Active video line (LSB)

<UL>
<LI>bits 7-0 = Active line LSB (0-255)
</LI>
</UL>

<P>
Register (R/W) $22 (22) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Line Interrupt control

<UL>
<LI>bit 7 = (R) ULA asserting interrupt
</LI>
<LI>bit 7 = (W) Reserved, must be 0
</LI>
<LI>bits 6-3 = Reserved, must be 0
</LI>
<LI>bit 2 = Disable ULA Interrupt (0 on reset)
</LI>
<LI>bit 1 = Enable Line Interrupt (0 on reset)
</LI>
<LI>bit 0 = MSB of Line Interrupt line value (0 on reset)
</LI>
</UL>

<P>
Register (R/W) $23 (23) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Line Interrupt value LSB

<UL>
<LI>bits 7-0 = Line Interrupt line value LSB (0-255)(0 on reset)
</LI>
</UL>

<P>
Register (R/W) $24 (24) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Reserved
<BR>
Protection against &ldquo;OUT ($3B),A&rdquo;

<P>
Register (R/W) $26 (26) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> ULA Horizontal Scroll Control

<UL>
<LI>bits 7-0 = ULA X Offset (0-255) (0 on reset)
</LI>
</UL>

<P>
Register (R/W) $27 (27) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> ULA Vertical Scroll Control

<UL>
<LI>bits 7-0 = ULA Y Offset (0-191) (0 on reset)
</LI>
</UL>

<P>
Register (R/W) $28 (28) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Stored Palette Value and PS/2 Keymap Address MSB
<BR>
Read

<UL>
<LI>bits 7-0 = Stored palette value (see NextREG $44)
</LI>
</UL>
Write  

<UL>
<LI>bit 7 = PS/2 or Joystick

<UL>
<LI>0 = PS/2 keymap
</LI>
<LI>1 = Key joystick
</LI>
</UL>
</LI>
<LI>bits 6-1 = Reserved, must be 0
</LI>
<LI>bit 0 = PS/2 Keymap Address MSB
</LI>
</UL>

<P>
Register (W) $29 (29) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> PS/2 Keymap Address LSB

<UL>
<LI>bits 7-0 = PS/2 Keymap Address LSB
</LI>
</UL>

<P>
Register (W) $2A (2A) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> PS/2 Keymap Data MSB

<UL>
<LI>bits 7-1 = Reserved, must be 0
</LI>
<LI>bit 0 = PS/2 Keymap Data MSB
</LI>
</UL>

<P>
Register (W) $2B (2B) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> PS/2 Keymap Data LSB

<UL>
<LI>bits 7-0 = PS/2 Keymap Data LSB
</LI>
</UL>
(writing this register auto-increments the address)

<P>
Register (R/W) $2C (2C) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> DAC B Mirror (Left)/ I<SUP>2</SUP>S Left Sample MSB
<BR>
Read

<UL>
<LI>bits 7-0 =  I<SUP>2</SUP>S Left Sample MSB
</LI>
</UL>
Write

<UL>
<LI>bits 7-0 = 8-bit sample left DAC ($80 on reset)
</LI>
</UL>

<P>
Register (R/W) $2D (2D) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> DAC A+D Mirror (mono/ I<SUP>2</SUP>S Sample LSB
<BR>
Read

<UL>
<LI>bits 7-0 =  I<SUP>2</SUP>S Last Sample LSB
</LI>
</UL>
Write

<UL>
<LI>bits 7-0 = 8-bit sample DACs A + D ($80 on reset)
</LI>
</UL>

<P>
Register (R/W) $2E (2E) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> DAC C Mirror (Right/ I<SUP>2</SUP>S Risht Sample MSB
<BR>
Read

<UL>
<LI>bits 7-0 =  I<SUP>2</SUP>S Right Sameple MSB
</LI>
</UL>
Write

<UL>
<LI>bits 7-0 = 8-bit sample Right DACs C ($80 on reset)
</LI>
</UL>

<P>
Register (R/W) $2F (2F) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 3 (Tilemap) Horizontal Scroll Control MSB

<UL>
<LI>bits 7-2 = Reserved, must be 0
</LI>
<LI>bits 1-0 = X Offset MSB ($00 on reset)
</LI>
</UL>
Meaningful Range is 0-319 in 40 char mode, 0-639 in 80 char mode

<P>
Register (R/W) $30 (30) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 3 (Tilemap) Horizontal Scroll Control LSB

<UL>
<LI>bits 7-0 = X Offset LSB ($00 on reset)
</LI>
</UL>
Meaningful range is 0-319 in 40 char mode, 0-639 in 80 char mode

<P>
Register (R/W) $31 (31) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 3 (Tilemap) Vertical Scroll Control

<UL>
<LI>bits 7-0 = Y Offset (0-255) )$00 on reset)
</LI>
</UL>

<P>
Register (R/W) $32 (32) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 1,0 (LoRes) Horizontal Scroll Control)

<UL>
<LI>bits 7-0 = X Offset (0-255) ($00 on reset)
</LI>
</UL>
Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and
smoothness as Layer 2.

<P>
Register (R/W) $33 (33) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 1,0 (LoRes) Vertical Scroll Control)

<UL>
<LI>bits 7-0 = Y Offset (0-191) ($00 on reset)
</LI>
</UL>
Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and
smoothness as Layer 2.

<P>
Register (R/W) $34 (34) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Number
<BR>
Lockstep (NextReg $09 bit 4 set)
<table width="90%">
bit 7 = Pattern address offset (Add 128 to pattern address)
bits 6-0 = Sprite number 0-127, Pattern number 0-63<tr><td valign="top">&nbsp;effectively performs an out to port $303B
</td></tr></table>

No Lockstep (NextReg $09 bit 4 clear)

<UL>
<LI>bit 7 = Reserved, must be 0
</LI>
<LI>bits 6-0 = Sprite number 0-127
</LI>
</UL>
This register selects which sprite has its attributes connected to the
sprite attribute registers

<P>
Register (W) $35 (35) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 0

<UL>
<LI>bits 7-0 = Sprite X coordinate LSB (MSB in NextReg $37)
</LI>
</UL>

<P>
Register (W) $36 (36) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 1

<UL>
<LI>bits 7-0 = Sprite Y coordinate LSB (MSB in NextReg $39)
</LI>
</UL>

<P>
Register (W) $37 (37) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 2

<UL>
<LI>bits 7-4 = 4-bit Palette offset
</LI>
<LI>bit 3 = Enable horizontal mirror (reverse)
</LI>
<LI>bit 2 = Enable vertical mirror (reverse)
</LI>
<LI>bit 1 = Enable 90<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img40.svg"
 ALT="$^O$"></SPAN> Clockwise Rotation
</LI>
</UL>
Normal Sprites

<UL>
<LI>bit 0 = X coordinate MSB
</LI>
</UL>
Relative Sprites

<UL>
<LI>bit 0 = Palette offset is relative to anchor sprite
</LI>
</UL>
Rotation is applied before mirroring

<P>
Register (W) $38 (38) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 3

<UL>
<LI>bit 7 = Enable Visiblity
</LI>
<LI>bit 6 = Enable Attribute 4 (0 = Attribute 4 effectively $00)
</LI>
<LI>bits 5-0 = Sprite Pattern Number
</LI>
</UL>

<P>
Register (W) $39 (39) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 4
<BR>
Normal Sprites

<UL>
<LI>bit 7 = 4-bit pattern switch (0 = 8-bit sprite, 1 = 4-bit sprite)
</LI>
<LI>bit 6 = Pattern number bit-7 for 4-bit, 0 for 8-bit
</LI>
<LI>bit 5 = Type of attached relative sprites (0 = Composite, 1 =
  Unified)
</LI>
<LI>bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
</LI>
<LI>bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
</LI>
<LI>bit 0 = MSB of Y coordinate
</LI>
</UL>
Relative, Composite Sprites

<UL>
<LI>bit 7-6 = 01
</LI>
<LI>bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit
</LI>
<LI>bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
</LI>
<LI>bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
</LI>
<LI>bit 0 = Pattern number is relative to anchor
</LI>
</UL>
Relative, Unified Sprites

<UL>
<LI>bit 7-6 = 01
</LI>
<LI>bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit
</LI>
<LI>bits 4-1 = 0000
</LI>
<LI>bit 0 = Pattern number is relative to anchor
</LI>
</UL>

<P>
Register (R/W) $40 (40) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Palette Index Select

<UL>
<LI>bits 7-0 = Palette Index Number
</LI>
</UL>
Selects the palette index to change the associated colour

<P>
For ULA only, INKs are mapped to indices 0 through 7, BRIGHT INKs to
indices 8 through 15, PAPERs to indices 16 through 23 and BRIGHT
PAPERs to indices 24 through 31.  In EnhancedULA mode, INKs come from
a subset of indices from 0 through 127 and PAPERs from a subset of
indices from 128 through 255.

<P>
The number of active indices depends on the number of attribute bits
assigned to INK and PAPER out of the attribute byte.

<P>
In ULAplus mode, the last 64 entries (indices 192 to 255) hold the
ULAplus palette.  The ULA always takes border colour from PAPER for
standard ULA and Enhanced ULA

<P>
Register (R/W) $41 (41) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> 8-bit Palette Data

<UL>
<LI>bits 7-0 = Colour Entry in RRRGGGBB format
</LI>
</UL>
The lower blue bit of the 9-bit internal colour will be the logical or
of bits 0 and 1 of the 8-bit entry. After each write, the palette
index auto-increments if aut-increment has been enabled (NextReg $43
bit 7), Reads do not auto-increment.

<P>
Register (R/W) $42 (42) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> ULANext Attribute Byte Format

<UL>
<LI>bits 7-0 = Attribute byte's INK representation mask (7 on reset)
</LI>
</UL>
The mask can only indicate a solid sequence of bits on the right side
of the attribute byte (1, 3, 7, 15, 31, 63, 127 or 255).

<P>
INKs are mapped to base index 0 in the palette and PAPERs and border
are mapped to base index 128 in the palette.

<P>
The 255 value enables the full ink colour mode making all the palette
entries INK. PAPER and border both take on the fallback colour
(nextreg $4A) in this mode.

<P>
Register (R/W) $43 (43) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Palette Control

<UL>
<LI>bit 7 = Disable palette write auto-increment.
</LI>
<LI>bits 6-4 = Select palette for reading or writing:
  
<UL>
<LI>000 = ULA first palette
</LI>
<LI>100 = ULA second palette
</LI>
<LI>001 = Layer 2 first palette
</LI>
<LI>101 = Layer 2 second palette
</LI>
<LI>010 = Sprite first palette
</LI>
<LI>110 = Sprite second palette
</LI>
<LI>011 = Layer 3 first palette
</LI>
<LI>111 = Layer 3 second palette
  
</LI>
</UL>
</LI>
<LI>bit 3 = Select Sprite palette (0 = first palette, 1 = second
  palette)
</LI>
<LI>bit 2 = Select Layer 2 palette (0 = first palette, 1 = second
  palette)
</LI>
<LI>bit 1 = Select ULA palette (0 = first palette, 1 = second
  palette)
</LI>
<LI>bit 0 = Enable EnhancedULA mode if 1. (0 after a reset)
</LI>
</UL>

<P>
Register (R/W) $44 (44) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> 9-bit Palette Data
<BR>
Non Level 2
<table width="90%"><tr><td valign="top">&nbsp;1st write
bits 7-0 = MSB (RRRGGGBB)</td></tr>
<tr><td valign="top">&nbsp;2nd write
bits 7-1 = Reserved, must be 0
bit 0 = LSB (B)
</td></tr></table>

Level 2
<table width="90%"><tr><td valign="top">&nbsp;1st write
bits 7-0 = MSB (RRRGGGBB)</td></tr>
<tr><td valign="top">&nbsp;2nd write
bit 7 = Priority
bits 6-1 = Reserved, must be 0
bit 0 = LSB (B)
</td></tr></table>

9-bit Palette Data is entered in two consecutive writes; the second
write autoincrements the palette index if auto-increment is enabled in
NextREG $43 bit 7

<P>
If writing an L2 palette, the second write's D7 holds the L2 priority
bit which if set (1) brings the colour defined at that index on top of
all other layers. If you also need the same colour in regular priority
(for example: for enviromental masking) you will have to set it up
again, this time with no priority.

<P>
Reads return the second byte and do not autoincrement. Writes to
nextreg $40, $41, $41, or $43 reset to the first write.

<P>
Register (R/W) $4A (4A) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Fallback Colour Value

<UL>
<LI>bits 7-0 = 8-bit colour if all layers are transparent ($E3 on
  reset)
</LI>
</UL>
(black on reset = 0)

<P>
Register (R/W) $4B (4B) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Transparency Index

<UL>
<LI>bits 7-0 = Index value ($E3 if reset)
</LI>
</UL>
For 4-bit sprites only the bottom 4-bits are relevant.

<P>
Register (R/W) $4C (4C) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Level 3 Transparency Index

<UL>
<LI>bits 7-4 = Reserved, must be 0
</LI>
<LI>bits 3-0 = Index value ($0F on reset)
</LI>
</UL>

<P>
Register (R/W) $50 (50) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 0 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $0000 to $1FFF ($ff on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.
<BR>
A 255 value causes the ROM to become visible.

<P>
Register (R/W) $51 (51) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 1 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $2000 to $3FFF ($ff on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.
<BR>
A 255 value causes the ROM to become visible.

<P>
Register (R/W) $52 (52) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 2 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $4000 to $5FFF ($0A on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.

<P>
Register (R/W) $53 (53) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 3 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $6000 to $7FFF ($0B on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.

<P>
Register (R/W) $54 (54) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 4 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $8000 to $9FFF ($04 on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.

<P>
Register (R/W) $55 (55) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 5 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $A000 to $BFFF ($05 on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.

<P>
Register (R/W) $56 (56) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 6 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $C000 to $DFFF ($00 on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.

<P>
Register (R/W) $57 (57) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> MMU Slot 7 Control

<UL>
<LI>bits 7-0 = 8k RAM page at position $E000 to $FFFF ($01 on
  reset)
</LI>
</UL>
Pages can be from 0 to 223 on a fully expanded Next.

<P>
Writing to ports $1FFD, $7FFD and $DFFD writes $FF to MMU0 and
MMU1 and writes appropriate values to MMU6 and MMU7 to map in the
selected 16k bank.

<P>
+3 special modes override the MMUs if used.

<P>
Register (W) $60 (60) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Copper Data 8-bit Write

<UL>
<LI>bits 7-0 = Byte to write to copper instruction memory
</LI>
</UL>
Note that each copper instruction is two bytes long, after a write,
the coppen address is auto-incremented to the next memory position.

<P>
After a write, the index is auto-incremented to the next memory position.

<P>
Register (W) $61 (61) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Copper Address LSB

<UL>
<LI>bits 7-0 = Copper instruction memory address LSB (0 on reset)
</LI>
</UL>

<P>
Register (W) $62 (62) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Copper Control

<UL>
<LI>bits 7-6 = Start Control
  <table width="90%">  <tr><td valign="top">&nbsp;00 = Copper fully stopped
  </td></tr>
<tr><td valign="top">&nbsp;01 = Copper start, execute the list from index 0, and loop
    to the start
  </td></tr>
<tr><td valign="top">&nbsp;10 = Copper start, execute the list from last point, and
    loop to the start
  </td></tr>
<tr><td valign="top">&nbsp;11 = Copper start, execute the list from index 0, and
    restart the list when the raster reaches position (0,0)
  </td></tr></table>

</LI>
<LI>bits 2-0 = Copper instruction memory address (MSB) (0 on reset)
</LI>
</UL>

<P>
Register (W) $63 (63) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Copper Data 16-bit Write

<UL>
<LI>bits 7-0 = Byte to write to copper instruction memory
</LI>
</UL>
The 16-bit value is written in pairs. The first 8-bits are the MSB and
are destined for an even copper instruction address. The sesond 8-bits
are the LSB and are destined for an odd copper instruction address.

<P>
After each write, the copper address is auto-incremented to the next
memory position.

<P>
After a write to an odd address, the all 16-bits are written to copper
memory at once.

<P>
Register (R/W) $64 (64) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Vertical Line Count Offset (3.01.05)
<table width="90%">
bits 7-0 = Offset added to the vertical line counter<tr><td valign="top">&nbsp;affects copper, line interrupt and active line
  count.
<BR>
Normally the ula's pixel row 0 aligns with vertical line count 0.
  With a non-zero offset, the ula's pixel row 0 will align with the
  vertical line offset.
<BR>
Eg, if the offset is 32 then vertical line 32 will correspond to
  the first pixel row in the ula and vertical line 0 will align with
  the first pixel row of the tilemap and sprites.
</td></tr></table>

* Since a change in offset takes effect when the ula reaches row 0,
the change can take up to one frame to occur.
Register (R/W) $68 (68) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> ULA Control
<table width="90%">
bit 7 = Disable ULA output (0 on reset)
bit 6-5 = Color blending control for layering modes 6 &amp; 7 (3.01.01)

<UL>
<LI>00 = ULA as blend colour
</LI>
<LI>01 = No blending
</LI>
<LI>10 = ULA/Tilemap mix result as blend colour
</LI>
<LI>11 = Tilemap as blend colour
</LI>
</UL>
bit 4 = Cancel entries in 8x5 matrix for extended keys (3.01.04)
bit 3 = Enable ULAplus (0 on reset)
bit 2 = Enable ULA half pixel scroll (0 on reset)<tr><td valign="top">&nbsp;may change
bit 1 = Reserved (must be 0)
bit 0 = Enable stencil mode (0 on reset)</td></tr>
<tr><td valign="top">&nbsp;When ULA and Layer 3 are enabled, if either are transparent,
  the result is transparent, otherwise the result is the logical AND
  of both colours.
</td></tr></table>

<P>
Register (R/W) $69 (69) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Display Control 1

<UL>
<LI>bit 7 = Layer 2 Enable (Port $123B bit 1 alias)
</LI>
<LI>bit 6 = ULA Shadow display enable (Port $7FFD bit 3 alias)
</LI>
<LI>bits 5-0 = Timex alias (Port $FF alias)
</LI>
</UL>

<P>
Register (R/W) $6A (6A) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 1,0 (LoRes) Control

<UL>
<LI>bits 7-6 = reserved, must be 0
</LI>
<LI>bit 5 = Enable Radistan (16-colour) (0 on reset)
</LI>
<LI>bit 4 = Radistan DFILE switch (xor with bit 0 of port $ff) (0
  on reset)
</LI>
<LI>bits 3-0 = Radistsan palette offset (0 on reset)
</LI>
<LI>bits 1-0 = ULAplus palette offset (0 on reset)
</LI>
</UL>

<P>
Register (R/W) $6B (6B) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 3 (Tilemap) Control

<UL>
<LI>bit 7 = Layer 3 Enable (0 on reset)
</LI>
<LI>bit 6 = Layer 3 Size control (0 on reset)
  
<UL>
<LI>0 = 40x32
</LI>
<LI>1 = 80x32
  
</LI>
</UL>
</LI>
<LI>bit 5 = Disable Arrtibute Entry (0 on reset)
</LI>
<LI>bit 4 = palette select (0 on reset)
</LI>
<LI>bit 3 = Enable Text mode (1-bit tilemap) (0 on reset)
</LI>
<LI>bit 2 = Reserved, must be 0
</LI>
<LI>bit 1 = Activate 512 tile mode (0 on reset)
</LI>
<LI>bit 0 = Enable Layer 3 on top of ULA (0 on reset)
</LI>
</UL>

<P>
Register (R/W) $6C (6C) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Default Layer 3 Attribute*

<UL>
<LI>bits 7-4 = Palette Offset ($00 on reset)
</LI>
<LI>bit 3 = X mirror (0 on reset)
</LI>
<LI>bit 2 = Y mirror (0 on reset)
</LI>
<LI>bit 1 = Rotate (0 on reset)
</LI>
<LI>bit 0 = Bit 8 of the tile number (512 tile mode) (0 on reset)
</LI>
<LI>bit 0 = ULA over tilemap (256 tile mode) (0 on reset)
</LI>
</UL>
*Active tile attribute if bit 5 of nextreg $6B is set.

<P>
Register (R/W) $6E (6E) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 3 Tilemap Base Address

<UL>
<LI>bit 7 = Bank Select (3.01.08)
<table width="90%"><tr><td valign="top">&nbsp;0 = Bank 5</td></tr>
<tr><td valign="top">&nbsp;1 = Bank 7
</td></tr></table>

</LI>
<LI>bit 6 = Reserved, must be 0
</LI>
<LI>bits 5-0 = MSB of address of the tilemap in Bank 5 (16k) or 7 (8k)
($2C on reset)
</LI>
</UL>
Soft Reset default $2C - This is because the address is $6C00 so the
MSB is $6C. But the stored value is only the lower 6 bits so it's an
offset into the 16k Bank 5. To calculate therefore subtract $40
leaving you with $2C.

<P>
The value written is an offset into the 16k Bank 5 or the 8k lower
half of Bank 7 allowinf the tilemap to be placed at any multiple of
256 bytes.
Register (R/W) $6F (6F) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 3 Tile Definitions Base Address

<UL>
<LI>bit 7 = Select bank (3.01.08)
<table width="90%"><tr><td valign="top">&nbsp;0 = Bank 5</td></tr>
<tr><td valign="top">&nbsp;1 = Bank 7
</td></tr></table>

</LI>
<LI>bit 6 = Reserved, must be 0
</LI>
<LI>bits 5-0 = MSB of address of the tile definitions in Bank 5 (16k) or 7
(8k) ($0C on reset)
</LI>
</UL>
Soft Reset default $0C - This is because the address is $4C00 so the
MSB is $4C. But the stored value is only the lower 6 bits so it's an
offset into the 16k Bank 5. To calculate therefore subtract $40
leaving you with $0C.

<P>
The value written is an offset into the 16k Bank 5 or the 8k lower
half of Bank 7 allowing the tilemap to be placed at any multiple of
256 bytes.
Register (R/W) $70 (70) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 2 Control

<UL>
<LI>bits 7-6 = Reserved, must be 0
</LI>
<LI>bits 5-4 = Resolution (00 on soft reset)
  
<UL>
<LI>00 = <!-- MATH
 $256\times192\times256$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img8.svg"
 ALT="$256\times192\times256$"></SPAN>
</LI>
<LI>01 = <!-- MATH
 $320\times256\times256$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img9.svg"
 ALT="$320\times256\times256$"></SPAN>
</LI>
<LI>10 = <!-- MATH
 $640\times256\times16$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img10.svg"
 ALT="$640\times256\times16$"></SPAN>
</LI>
<LI>11 = Do not use
  
</LI>
</UL>
</LI>
<LI>bits 3-0 = Palette offset ($0 on soft reset)
</LI>
</UL>

<P>
Register (R/W) $71 (71) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Layer 2 X Scroll MSB

<UL>
<LI>bits 7-1 = Reserved, must be 0
</LI>
<LI>bits 0 = MSB of X Offset
</LI>
</UL>

<P>
Register (W) $75 (75) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 0 (Auto-incrementing)
<BR>
See nextreg $35

<P>
Register (W) $76 (76) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 1 (Auto-incrementing)
<BR>
See nextreg $36

<P>
Register (W) $77 (77) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 2 (Auto-incrementing)
<BR>
See nextreg $37

<P>
Register (W) $78 (78) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 3 (Auto-incrementing)
<BR>
See nextreg $38

<P>
Register (W) $79 (79) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Sprite Attribute 4 (Auto-incrementing)
<BR>
See nextreg $39

<P>
Register (R/W) $7F (7F) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> User Register 0

<UL>
<LI>bits 7-0 = User Register ($FF on hard reset)
</LI>
</UL>

<P>
Caution NextReg numbers above $7F are inaccessible to the Copper

<P>
Register (R/W) $80 (80) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Expansion Bus Enable
<BR>
Immediate

<UL>
<LI>bit 7 = Expansion Bus Enable (0 on hard reset)(3.01.07)
</LI>
<LI>bit 6 = Enable ROMCS ROM replacement from divmmc banks 14/15
  (experimental, 3.01.03)
</LI>
<LI>bit 5 = I/O cycle Disable/Ignore <!-- MATH
 $\overline{\hbox{IORQULA}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img146.svg"
 ALT="$\overline{\hbox{IORQULA}}$"></SPAN> (0 on
  hard reset)
</LI>
<LI>bit 4 = Memory cycle Disable/Ignore <!-- MATH
 $\overline{\hbox{ROMCS}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img147.svg"
 ALT="$\overline{\hbox{ROMCS}}$"></SPAN> (0 on
  hard reset)
</LI>
</UL>
After Soft Reset (Copied into bits 7-4)

<UL>
<LI>bit 3 = Expansion Bus Enable (0 on hard reset)
</LI>
<LI>bit 2 = Enable ROMCS ROM replacement from divmmc banks 14/15
  (experimental, 3.01.03)
</LI>
<LI>bit 1 = I/O cycle Disable/Ignore <!-- MATH
 $\overline{\hbox{IORQULA}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img146.svg"
 ALT="$\overline{\hbox{IORQULA}}$"></SPAN> (0 on
  hard reset)
</LI>
<LI>bit 0 = Memory cycle Disable/Ignore <!-- MATH
 $\overline{\hbox{ROMCS}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img147.svg"
 ALT="$\overline{\hbox{ROMCS}}$"></SPAN> (0 on
  hard reset)
</LI>
</UL>

<P>
Register (R/W) $81 (81) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Expansion Bus Control

<UL>
<LI>bit 7 = (R) Expansion bus <!-- MATH
 $\overline{\hbox{ROMCS}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img147.svg"
 ALT="$\overline{\hbox{ROMCS}}$"></SPAN> asserted
</LI>
<LI>bit 6 = Allow peripherials to override the ULA on some even
  port reads ($00-$0E)(Rotoronics Wafadrive)(3.01.07)
</LI>
<LI>bit 5 = Disable expansion bus NMI debounce (Opus Discovery)(3.01.07)
</LI>
<LI>bit 4 = (W) Propagate max CPU clock at all times (0 on hard
  reset)
</LI>
<LI>bits 3-2 = Reserved, must be 0
</LI>
<LI>bits 1-0 = Max CPU Speed when Expansion Bus is enabled ($00 on
  hard reset, currently fixed at $00)
  
<UL>
<LI>00 = 3.5 MHz
</LI>
<LI>01 = 7 MHz
</LI>
<LI>10 = 14 MHz
</LI>
<LI>11 = 28 MHz
  
</LI>
</UL>
</LI>
</UL>

<P>
Register (R/W) $82 (82) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Internal Port decoding control 1/4

<UL>
<LI>bit 7 = Enable Kempston Port 2 (Port $37) (1 on reset)
</LI>
<LI>bit 6 = Enable Kempston Port 1 (Port $1F) (1 on reset)
</LI>
<LI>bit 5 = Enable DMA (Port $6B) (1 on reset)
</LI>
<LI>bit 4 = Enable +3 Floating Bus (1 on reset)
</LI>
<LI>bit 3 = Enable +3 Paging (Port $1FFD) (1 on reset)
</LI>
<LI>bit 2 = Enable Next Memory Paging (Port $DFFD) (1 on reset)
</LI>
<LI>bit 1 = Enable Paging (Port $7FFD) (1 on reset)
</LI>
<LI>bit 0 = Enable Timex (Port $FF) (1 on reset)
</LI>
</UL>

<P>
Register (R/W) $83 (83) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Internal Port decoding control 2/4

<UL>
<LI>bit 7 = Enable Layer 2 (Port $123B) (1 on reset)
</LI>
<LI>bit 6 = Enable Sprites (Ports $57, $5B, $303B) (1 on reset)
</LI>
<LI>bit 5 = Enable Kempston Mouse (Ports $FADF, $FBDF, $FFDF) (1
  on reset)
</LI>
<LI>bit 4 = Enable UART (Ports $133B, $143B, $153B) (1 on reset)
</LI>
<LI>bit 3 = Enable SPI (Ports $E7, $EB) (1 on reset)
</LI>
<LI>bit 2 = Enable  I<SUP>2</SUP>C (Ports $103B, $113B) (1 on reset)
</LI>
<LI>bit 1 = Enable Multiface (two variable ports) (1 on reset)
</LI>
<LI>bit 0 = Enable divMMC (Port $E3) (1 on reset)
</LI>
</UL>

<P>
Register (R/W) $84 (84) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Internal Port decoding control 3/4

<UL>
<LI>bit 7 = Enable SPECdrum Mono DAC (Port $DF) (1 on reset)
</LI>
<LI>bit 6 = Enable Covox/GS Mono DAC (Port $B3) (1 on reset)
</LI>
<LI>bit 5 = Enable Pentagon/ATM DAC (Port $FB) (1 on reset)
</LI>
<LI>bit 4 = Enable Covox Stereo DAC (Ports $0F, $4F) (1 on reset)
</LI>
<LI>bit 3 = Enable Profi/Covox Stereo DAC (Ports $3F, $5F) (1 on
  reset)
</LI>
<LI>bit 2 = Enable Soundrive DAC Mode 2 (Ports $F1, $F3, $F9,
  $FB) (1 on reset)
</LI>
<LI>bit 1 = Enable Soundrive DAC Mode 1 (Ports $0F, $1F, $4F,
  $5F) (1 on reset)
</LI>
<LI>bit 0 = Enable AY (Ports $FFFD, $BFFD) (1 on reset)
</LI>
</UL>

<P>
Register (R/W) $85 (85) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Internal Port decoding control 4/4

<UL>
<LI>bit 7 = Enable configuration of port decoding on soft reset (3.01.01)
</LI>
<LI>bits 6-4 = Reserved
</LI>
<LI>bit 3 = Enable Z80 CTC ports $183B, $193B, $1A3B, $1B3B, $1C3B,
  $1D3B, $1E3B, and $1F3B
</LI>
<LI>bit 2 = Enable Pentagon 1024 memory port $EFF7
</LI>
<LI>bit 1 = Enable DMA port $0B (3.01.02)
</LI>
<LI>bit 0 = Enable ULAplus (Ports $BF3B, $FF3B) (1 on reset)
</LI>
</UL>

<P>
Register (R/W) $86 (86) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Expansion Port decoding control 1/4

<UL>
<LI>bit 7 = Enable Kempston Port 2 (Port $37) (1 on reset)
</LI>
<LI>bit 6 = Enable Kempston Port 1 (Port $1F) (1 on reset)
</LI>
<LI>bit 5 = Enable DMA (Port $6B) (1 on reset)
</LI>
<LI>bit 4 = Enable +3 Floating Bus (1 on reset)
</LI>
<LI>bit 3 = Enable +3 Paging (Port $1FFD) (1 on reset)
</LI>
<LI>bit 2 = Enable Next Memory Paging (Port $DFFD) (1 on reset)
</LI>
<LI>bit 1 = Enable Paging (Port $7FFD) (1 on reset)
</LI>
<LI>bit 0 = Enable Timex (Port $FF) (1 on reset)
</LI>
</UL>

<P>
Register (R/W) $87 (87) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Expansion Port decoding control 2/4

<UL>
<LI>bit 7 = Enable Layer 2 (Port $123B) (1 on reset)
</LI>
<LI>bit 6 = Enable Sprites (Ports $57, $5B, $303B) (1 on reset)
</LI>
<LI>bit 5 = Enable Kempston Mouse (Ports $FADF, $FBDF, $FFDF) (1
  on reset)
</LI>
<LI>bit 4 = Enable UART (Ports $133B, $143B, $153B) (1 on reset)
</LI>
<LI>bit 3 = Enable SPI (Ports $E7, $EB) (1 on reset)
</LI>
<LI>bit 2 = Enable  I<SUP>2</SUP>C (Ports $103B, $113B) (1 on reset)
</LI>
<LI>bit 1 = Enable Multiface (two variable ports) (1 on reset)
</LI>
<LI>bit 0 = Enable divMMC (Port $E3) (1 on reset)
</LI>
</UL>

<P>
Register (R/W) $88 (88) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Expansion Port decoding control 3/4

<UL>
<LI>bit 7 = Enable SPECdrum Mono DAC (Port $DF) (1 on reset)
</LI>
<LI>bit 6 = Enable Covox/GS Mono DAC (Port $B3) (1 on reset)
</LI>
<LI>bit 5 = Enable Pentagon/ATM DAC (Port $FB) (1 on reset)
</LI>
<LI>bit 4 = Enable Covox Stereo DAC (Ports $0F, $4F) (1 on reset)
</LI>
<LI>bit 3 = Enable Profi/Covox Stereo DAC (Ports $3F, $5F) (1 on
  reset)
</LI>
<LI>bit 2 = Enable Soundrive DAC Mode 2 (Ports $F1, $F3, $F9,
  $FB) (1 on reset)
</LI>
<LI>bit 1 = Enable Soundrive DAC Mode 1 (Ports $0F, $1F, $4F,
  $5F) (1 on reset)
</LI>
<LI>bit 0 = Enable AY (Ports $FFFD, $BFFD) (1 on reset)
</LI>
</UL>

<P>
Register (R/W) $89 (89) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Expansion Port decoding control 4/4

<UL>
<LI>bit 7 = Enable configuration of port decoding on soft reset (3.01.01)
</LI>
<LI>bits 6-4 = Reserved
</LI>
<LI>bit 3 = Enable Z80 CTC ports $183B, $193B, $1A3B, $1B3B, $1C3B,
  $1D3B, $1E3B, and $1F3B
</LI>
<LI>bit 2 = Enable Pentagon 1024 memory port $EFF7
</LI>
<LI>bit 1 = Enable DMA port $0B (3.01.02)
</LI>
<LI>bit 0 = Enable ULAplus (Ports $BF3B, $FF3B) (1 on reset)
</LI>
</UL>

<P>
The Internal Port Decoding Enables always apply.

<P>
When the Expansion Bus is enabled, the Expansion Bus Port Decoding
Enables are logically ANDed with the Internal Enables. A result of 0
for the corresponding bit indicates the internal device is
<SPAN  CLASS="textit">disabled</SPAN>. If the Expansion Bus is enabled, this allows
I/O cycles for disabled ports to propagate to the Expansion Bus,
otherwise corresponding I/O cycles to the Expansion Bus are filtered.

<P>
Register (R/W) $8A (8A) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Expansion Bus I/O Propagate Control

<UL>
<LI>bits 7-3 = Reserved, must be 0
</LI>
<LI>bit 4 = Propagate port $FF I/O Cycles (0 on hard reset, 3.01.02)
</LI>
<LI>bit 3 = Propagate port $1FFD I/O Cycles (0 on hard reset)
</LI>
<LI>bit 2 = Propagate port $DFFD I/O Cycles (0 on hard reset)
</LI>
<LI>bit 1 = Propagate port $7FFD I/O Cycles (0 on hard reset)
</LI>
<LI>bit 0 = Propagate port $FE I/O Cycles (1 on hard reset, 3.01.03:
  0 on hard reset)
</LI>
</UL>

<P>
Register (R/W) $8C (8C) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Alternate ROM
<BR>
Immediate

<UL>
<LI>bit 7 = Alt ROM Enable (0 on hard reset)
</LI>
<LI>bit 6 = Alt ROM visible ONLY during writes (0 on hard reset)
</LI>
<LI>bit 5 = Reserved, must be 0
</LI>
<LI>bit 4 = 48k ROM Lock (0 on hard reset)
</LI>
</UL>
After Soft Reset (copied into bits 7-4)

<UL>
<LI>bit 3 = Alt ROM Enable (0 on hard reset)
</LI>
<LI>bit 2 = Alt ROM visible ONLY during writes (0 on hard reset)
</LI>
<LI>bit 1 = Reserved, must be 0
</LI>
<LI>bit 0 = 48k ROM Lock (0 on hard reset)
</LI>
</UL>

<P>
Register (R/W) $8E (8E) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Spectrum 128k Memory Mapping (3.01.01)
<table width="90%">
bit 7 = Bank number bit 3 (port $dffd bit 0)
bit 6-4 = Bank number bits 2-0 (port $7ffd bits 2-0)
bit 3 = Enable change ram page (read as 1)
bit 2 = Paging mode (port $1ffd bit 0)

<UL>
<LI>0 = Normal paging mode
</LI>
<LI>1 = Special paging mode (lot bit of memory configuration)
</LI>
</UL><tr><td valign="top">&nbsp;Normal Paging Mode
bits 1-0 = ROM selection (port $1ffd bit 1 and $7ffd bit 4)</td></tr>
<tr><td valign="top">&nbsp;Special (all RAM) Paging Mode
bits 1-0 = RAM configuration selection (port $1ffd bits 2-1)
</td></tr></table>

Writes can affect all ports $7ffd, $dffd, and $1ffd
<BR>
Writes can always change the ROM/allRAM mapping
<BR>
Writes immediately change the current MMU mapping as if by port write.

<P>
Register (R/W) $8F (8F) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Memory Mapping Mode (3.01.06)

<UL>
<LI>bits 7-2 = Reserved, must be zero
</LI>
<LI>bits 1-0 = Mapping mode applied
  
<UL>
<LI>00 = Standard ZX 128k +3
</LI>
<LI>01 = Profi (removed in 3.01.09)
</LI>
<LI>10 = Pentagon 512k
</LI>
<LI>11 = Pentagon 1024k (limited to 768k on 1MB machines)
  
</LI>
</UL>
</LI>
</UL>
* Standard ZX 128k +3 = principally ports $7FFD, $DFFD, and $1FFD
<BR>* Pentagon 512k = principally port $7FFD
<BR>* Pentagon 1024k = principally ports $7FFD and $EFF7
<BR>** The mapping modes affect how ports $7FFD, $DFFD, $1FFD, and $EFF7
carry out memory paging, see ports

<P>
Register (R/W) $90 (90) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO output enable 1/4

<UL>
<LI>bit 7 = Enable Pin 7 (0 on reset)
</LI>
<LI>bit 6 = Enable Pin 6 (0 on reset)
</LI>
<LI>bit 5 = Enable Pin 5 (0 on reset)
</LI>
<LI>bit 4 = Enable Pin 4 (0 on reset)
</LI>
<LI>bit 3 = Enable Pin 3 (0 on reset)
</LI>
<LI>bit 2 = Enable Pin 2 (0 on reset)
</LI>
<LI>bit 1 = Enable Pin 1 (cannot be enabled) (0 on reset)
</LI>
<LI>bit 0 = Enable Pin 0 (cannot be enabled) (0 on reset)
</LI>
</UL>

<P>
Register (R/W) $91 (91) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO output enable 2/4

<UL>
<LI>bit 7 = Enable Pin 15 (0 on reset)
</LI>
<LI>bit 6 = Enable Pin 14 (0 on reset)
</LI>
<LI>bit 5 = Enable Pin 13 (0 on reset)
</LI>
<LI>bit 4 = Enable Pin 12 (0 on reset)
</LI>
<LI>bit 3 = Enable Pin 11 (0 on reset)
</LI>
<LI>bit 2 = Enable Pin 10 (0 on reset)
</LI>
<LI>bit 1 = Enable Pin 9 (0 on reset)
</LI>
<LI>bit 0 = Enable Pin 8 (0 on reset)
</LI>
</UL>

<P>
Register (R/W) $92 (92) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO output enable 3/4

<UL>
<LI>bit 7 = Enable Pin 23 (0 on reset)
</LI>
<LI>bit 6 = Enable Pin 22 (0 on reset)
</LI>
<LI>bit 5 = Enable Pin 21 (0 on reset)
</LI>
<LI>bit 4 = Enable Pin 20 (0 on reset)
</LI>
<LI>bit 3 = Enable Pin 19 (0 on reset)
</LI>
<LI>bit 2 = Enable Pin 18 (0 on reset)
</LI>
<LI>bit 1 = Enable Pin 17 (0 on reset)
</LI>
<LI>bit 0 = Enable Pin 16 (0 on reset)
</LI>
</UL>

<P>
Register (R/W) $93 (93) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO output enable 4/4

<UL>
<LI>bits 7-4 = Reserved
</LI>
<LI>bit 3 = Enable Pin 27 (0 on reset)
</LI>
<LI>bit 2 = Enable Pin 26 (0 on reset)
</LI>
<LI>bit 1 = Enable Pin 25 (0 on reset)
</LI>
<LI>bit 0 = Enable Pin 24 (0 on reset)
</LI>
</UL>

<P>
Register (R/W) $98 (98) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO Pin State 1/4

<UL>
<LI>bit 7 = Pin 7 Data (1 on reset)
</LI>
<LI>bit 6 = Pin 6 Data (1 on reset)
</LI>
<LI>bit 5 = Pin 5 Data (1 on reset)
</LI>
<LI>bit 4 = Pin 4 Data (1 on reset)
</LI>
<LI>bit 3 = Pin 3 Data (1 on reset)
</LI>
<LI>bit 2 = Pin 2 Data (1 on reset)
</LI>
<LI>bit 1 = Pin 1 Data (1 on reset)
</LI>
<LI>bit 0 = Pin 0 Data (1 on reset)
</LI>
</UL>

<P>
Register (R/W) $99 (99) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO Pin State 2/4

<UL>
<LI>bit 7 = Pin 15 Data (1 on reset)
</LI>
<LI>bit 6 = Pin 14 Data (1 on reset)
</LI>
<LI>bit 5 = Pin 13 Data (1 on reset)
</LI>
<LI>bit 4 = Pin 12 Data (1 on reset)
</LI>
<LI>bit 3 = Pin 11 Data (1 on reset)
</LI>
<LI>bit 2 = Pin 10 Data (1 on reset)
</LI>
<LI>bit 1 = Pin 9 Data (1 on reset)
</LI>
<LI>bit 0 = Pin 8 Data (1 on reset)
</LI>
</UL>

<P>
Register (R/W) $9A (9A) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO Pin State 3/4

<UL>
<LI>bit 7 = Pin 23 Data (1 on reset)
</LI>
<LI>bit 6 = Pin 22 Data (1 on reset)
</LI>
<LI>bit 5 = Pin 21 Data (1 on reset)
</LI>
<LI>bit 4 = Pin 20 Data (1 on reset)
</LI>
<LI>bit 3 = Pin 19 Data (1 on reset)
</LI>
<LI>bit 2 = Pin 18 Data (1 on reset)
</LI>
<LI>bit 1 = Pin 17 Data (1 on reset)
</LI>
<LI>bit 0 = Pin 16 Data (1 on reset)
</LI>
</UL>

<P>
Register (R/W) $9B (9B) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Pi GPIO Pin State 4/4

<UL>
<LI>bits 7-4 = Reserved
</LI>
<LI>bit 3 = Pin 27 Data (1 on reset)
</LI>
<LI>bit 2 = Pin 26 Data (1 on reset)
</LI>
<LI>bit 1 = Pin 25 Data (1 on reset)
</LI>
<LI>bit 0 = Pin 24 Data (1 on reset)
</LI>
</UL>

<P>
Register (R/W) $A0 (A0) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Pi Peripheral Enable

<UL>
<LI>bits 7-6 = Reserved, must be 0
</LI>
<LI>bit 5 = Enable UART on GPIO 14, 15 (0 on reset)*
</LI>
<LI>bit 4 = Communication Type (0 on reset)
  
<UL>
<LI>0 = Rx to GPIO 15, Tx to GPIO 14 (Pi)
</LI>
<LI>1 = Rx to GPIO 14, Tx to GPIO 15 (Pi Hats)
  
</LI>
</UL>
</LI>
<LI>bit 3 = Enable  I<SUP>2</SUP>C on GPIO 2, 3 (0 on reset)*
</LI>
<LI>bits 2-1 = Reserved, must be 0
</LI>
<LI>bit 0 = Enable SPI on GPIO 7, 8, 9, 10, 11 (0 on reset)*
</LI>
</UL>
*Overrides GPIO Enables

<P>
Register (R/W) $A2 (A2) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Pi  I<SUP>2</SUP>S Audio Control

<UL>
<LI>bits 7-6 =  I<SUP>2</SUP>S State ($00 on reset)
  
<UL>
<LI>00 =  I<SUP>2</SUP>S Disabled
</LI>
<LI>01 =  I<SUP>2</SUP>S is mono, source R
</LI>
<LI>10 =  I<SUP>2</SUP>S is mono, source L
</LI>
<LI>11 =  I<SUP>2</SUP>S is stereo
  
</LI>
</UL>
</LI>
<LI>bit 5 = Reserved, must be 0
</LI>
<LI>bit 4 = Audio Flow Direction (0 on reset)
  
<UL>
<LI>0 = PCM_DOUT to Pi, PCM_DIN from Pi (Hats)
</LI>
<LI>1 = PCM_DOUT from Pi, PCM_DIN to Pi (Pi)
  
</LI>
</UL>
</LI>
<LI>bit 3 = Mute left (0 on reset)
</LI>
<LI>bit 2 = Mute right (0 on reset)
</LI>
<LI>bit 1 = Slave mode, Reserved must be 1 (remove in 3.01.05)
</LI>
<LI>bit 0 = Direct  I<SUP>2</SUP>S audio to EAR on port $FE (0 on reset)
</LI>
</UL>

<P>
Register (R/W) $A3 (A3) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Pi  I<SUP>2</SUP>S Clock Divide (Master Mode) (removed in 3.01.05)

<UL>
<LI>bits 7-0 = Clock divide value ($0B on reset)
</LI>
</UL>
<!-- MATH
 $\hbox{Divider}=\frac{538461}{\hbox{Rate}}-1$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img64.svg"
 ALT="$\hbox{Divider}=\frac{538461}{\hbox{Rate}}-1$"></SPAN> or
<!-- MATH
 $\hbox{Rate}=\frac{538461}{\hbox{Divider}+1}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img65.svg"
 ALT="$\hbox{Rate}=\frac{538461}{\hbox{Divider}+1}$"></SPAN>

<P>
Register (R/W) $A8 (A8) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> ESP WiFi GPIO Output Enable

<UL>
<LI>bits 7-3 = Reserved, must be sero
</LI>
<LI>bit 2 = GPIO2 output enable (fixed at 0, GPIO2 is read-only)
</LI>
<LI>bit 1 = Reserved, must be zero
</LI>
<LI>bit 0 = GPIO0 output enable (fixed at 0, GPIO2 is read-only)
</LI>
</UL>
Register (R/W) $A9 (A9) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> ESP WiFi GPIO

<UL>
<LI>bits 7-3 = Reserved, must be sero
</LI>
<LI>bit 2 = Read/Write GPIO2 (reset = 1)
</LI>
<LI>bit 1 = Reserved, must be zero
</LI>
<LI>bit 0 = Read/Write GPIO0 (reset = 1)
</LI>
</UL>
Register (R) $B0 (B0) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Extended Keys 0 (3.01.04)

<UL>
<LI>bit 7 = 1 if ; pressed
</LI>
<LI>bit 6 = 1 if p&#x308;ressed
</LI>
<LI>bit 5 = 1 if , pressed
</LI>
<LI>bit 4 = 1 if . pressed
</LI>
<LI>bit 3 = 1 if UP pressed
</LI>
<LI>bit 2 = 1 if DOWN pressed
</LI>
<LI>bit 1 = 1 if LEFT pressed
</LI>
<LI>bit 0 = 1 if RIGHT pressed
</LI>
</UL>
Register (R) $B1 (B1) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Extended Keys 1 (3.01.04)

<UL>
<LI>bit 7 = 1 if DELETE pressed
</LI>
<LI>bit 6 = 1 if EDIT pressed
</LI>
<LI>bit 5 = 1 if BREAK pressed
</LI>
<LI>bit 4 = 1 if INV VIDEO pressed
</LI>
<LI>bit 3 = 1 if TRUE VIDEO pressed
</LI>
<LI>bit 2 = 1 if GRAPH pressed
</LI>
<LI>bit 1 = 1 if CAPS LOCK pressed
</LI>
<LI>bit 0 = 1 if EXTEND pressed
</LI>
</UL>
Register (R) $B2 (B2) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Extended MD Pad Buttons (3.01.10)

<UL>
<LI>bit 7 = 1 if Right Pad X Pressed
</LI>
<LI>bit 6 = 1 if Right Pad Z Pressed
</LI>
<LI>bit 5 = 1 if Right Pad Y Pressed
</LI>
<LI>bit 4 = 1 if Right Pad START Pressed
</LI>
<LI>bit 3 = 1 if Left Pad X Pressed
</LI>
<LI>bit 2 = 1 if Left Pad Z Pressed
</LI>
<LI>bit 1 = 1 if Left Pad Y Pressed
</LI>
<LI>bit 0 = 1 if Left Pad START Pressed
</LI>
</UL>
Register (R/W) $C0 (C0) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Interrupt Control (3.01.09)
<BR>($00 on reset)

<UL>
<LI>bits 7-5 = Programmable portion of IM2 vector *
</LI>
<LI>bit 4 = Reserved, must be 0
</LI>
<LI>bit 3 = Enable stackless <!-- MATH
 $\overline{\hbox{NMI}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img5.svg"
 ALT="$\overline {\hbox {NMI}}$"></SPAN> response**
</LI>
<LI>bits 2-1 = Reserved, must be 0
</LI>
<LI>bit 0 = Maskable interrupt mode
<table width="90%"><tr><td valign="top">&nbsp;0 - pulse</td></tr>
<tr><td valign="top">&nbsp;1 - IM2
</td></tr></table>
</LI>
</UL>
* In IM2 mode vector generated is:

<UL>
<LI>bits 7-5 = nextreg $C0 bits 7-5
</LI>
<LI>bits 4-1 = Interrupt source
<table width="90%"><tr><td valign="top">&nbsp;0 - line interrupt (highest priority)</td></tr>
<tr><td valign="top">&nbsp;1 - UART 0 Rx</td></tr>
<tr><td valign="top">&nbsp;2 - UART 1 Rx</td></tr>
<tr><td valign="top">&nbsp;3&ndash;10 - CTC channels 0-7</td></tr>
<tr><td valign="top">&nbsp;11 - ULA</td></tr>
<tr><td valign="top">&nbsp;12 - UART 0 Tx</td></tr>
<tr><td valign="top">&nbsp;13 - UART 1 Tx (lowest priority)
</td></tr></table>

</LI>
<LI>bit 0 = 0
</LI>
</UL>

<P>
* In IM2 mode the expansion bus is the lowest priority interrupter and
  if no vector is supplied externally the $FF is generated.

<P>
** The return address pushed during an nmi acknowledge cycle will be
   written to the appropriate nextreg instead of memory (the stack
   pointer will be decremented) and the RETN after acknowledge will
   take its return address from nextreg instead of memory (the stack
   pointer will be incremented). If bit 3 = 0 and in other
   circumstances, RETN functions normally.

<P>
Register (R/W) $C2 (C2) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> <!-- MATH
 $\overline{\hbox{NMI}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img5.svg"
 ALT="$\overline {\hbox {NMI}}$"></SPAN> Return Address LSB (3.01.09)
<BR>($00 on reset)

<P>
Register (R/W) $C3 (C3) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> <!-- MATH
 $\overline{\hbox{NMI}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img5.svg"
 ALT="$\overline {\hbox {NMI}}$"></SPAN> Return Address MSB (3.01.09)
<BR>($00 on reset)

<P>
Register (R/W) $C4 (C4) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Interrupt Enable 0 (3.01.08)
<BR>($81 on reset)

<UL>
<LI>bit 7 = Expansion bus <!-- MATH
 $\overline{\hbox{INT}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img6.svg"
 ALT="$\overline {\hbox {INT}}$"></SPAN>
</LI>
<LI>bits 6-2 = Reserved must be zero
</LI>
<LI>bit 1 = Line
</LI>
<LI>bit 0 = ULA
</LI>
</UL>

<P>
Register (R/W) $C5 (C5) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Interrupt Enable 1 (3.01.08)
<BR>($00 on reset)

<UL>
<LI>bit 7 = ctc channel 7 zc/to
</LI>
<LI>bit 6 = ctc channel 6 zc/to
</LI>
<LI>bit 5 = ctc channel 5 zc/to
</LI>
<LI>bit 4 = ctc channel 4 zc/to
</LI>
<LI>bit 3 = ctc channel 3 zc/to
</LI>
<LI>bit 2 = ctc channel 2 zc/to
</LI>
<LI>bit 1 = ctc channel 1 zc/to
</LI>
<LI>bit 0 = ctc channel 0 zc/to
</LI>
</UL>

<P>
Register (W) $C6 (C6) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Interrupt Enable 2 (3.01.08)
<BR>($00 on reset)

<UL>
<LI>bit 7 = Reserved, must be 0
</LI>
<LI>bit 6 = UART1 Tx empty
</LI>
<LI>bit 5 = UART1 Rx half full *
</LI>
<LI>bit 4 = UART1 Rx available *
</LI>
<LI>bit 3 = Reserved, must be 0
</LI>
<LI>bit 2 = UART0 Tx empty
</LI>
<LI>bit 1 = UART0 Rx half full *
</LI>
<LI>bit 0 = UART0 Rx available *
</LI>
</UL>
* For each UART, Rx half full and Rx available are shared interrupts

<P>
Register (W) $C7 (C7) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Reserved (3.01.09)

<P>
Register (R/W) $C8 (C8) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Interrupt Status 0 (3.01.09)
<BR>($00 on reset)

<UL>
<LI>bits 7-2 = Reserved, must be zero
</LI>
<LI>bit 1 = Line
</LI>
<LI>bit 0 = ULA
</LI>
</UL>
* Set bits indicate the device generated an interrupt in the past
* Writes clear bits where bits are set except in IM2 mode

<P>
Register (R/W) $C9 (C9) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Interrupt Status 1 (3.01.09)

<UL>
<LI>bit 7 = ctc channel 7 zc/to
</LI>
<LI>bit 6 = ctc channel 6 zc/to
</LI>
<LI>bit 5 = ctc channel 5 zc/to
</LI>
<LI>bit 4 = ctc channel 4 zc/to
</LI>
<LI>bit 3 = ctc channel 3 zc/to
</LI>
<LI>bit 2 = ctc channel 2 zc/to
</LI>
<LI>bit 1 = ctc channel 1 zc/to
</LI>
<LI>bit 0 = ctc channel 0 zc/to
</LI>
</UL>
* Set bits indicate the device generated an interrupt in the past
* Writes clear bits where bits are set except in IM2 mode

<P>
Register (R/W) $CA (CA) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Interrupt Status 2 (3.01.09)
($00 on reset)

<UL>
<LI>bit 7 = Reserved, must be zero
</LI>
<LI>bit 6 = UART1 Tx empty
</LI>
<LI>bit 5 = UART1 Rx almost full *
</LI>
<LI>bit 4 = UART1 Rx available *
</LI>
<LI>bit 3 = Reserved must be zero
</LI>
<LI>bit 2 = UART0 Tx empty
</LI>
<LI>bit 1 = UART0 Rx almost full *
</LI>
<LI>bit 0 = UART0 Rx available *
</LI>
</UL>
* For each UART Rx half full and Rx available are shared interrupts
** Set bits indicate the device generated an interrupt in the past
** Writes clear bits where bits are set except in IM2 mode

<P>
Register (W) $CB (CB) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Reserved (3.01.09)

<P>
Register (R/W) $CC (CC) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> DMA Interrupt Enable 0 (3.01.09)
($00 on reset)

<UL>
<LI>bits 7-2 = Reserved, must be 0
</LI>
<LI>bit 1 = Line
</LI>
<LI>bit 0 = ULA
</LI>
</UL>
* Set bits indicate the specified interrupt will interrupt a DMA
  operation when in IM2 mode

<P>
Register (R/W) $CD (CD) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> DMA Interrupt Enable 1 (3.01.09)
($00 on reset)

<UL>
<LI>bit 7 = CTC channel 7 zc/to
</LI>
<LI>bit 6 = CTC channel 6 zc/to
</LI>
<LI>bit 5 = CTC channel 5 zc/to
</LI>
<LI>bit 4 = CTC channel 4 zc/to
</LI>
<LI>bit 3 = CTC channel 3 zc/to
</LI>
<LI>bit 2 = CTC channel 2 zc/to
</LI>
<LI>bit 1 = CTC channel 1 zc/to
</LI>
<LI>bit 0 = CTC channel 0 zc/to
</LI>
</UL>
* Set bits indicate the corresponding interrupt will interrupt a DMA
  operation when in IM2 mode

<P>
Register (R/W) $CE (CE) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> DMA Interrupt Enable 2 (3.01.09)
($00 on reset)

<UL>
<LI>bit 7 = Reserved, must be 0
</LI>
<LI>bit 6 = UART1 Tx empty
</LI>
<LI>bit 5 = UART1 Rx half full
</LI>
<LI>bit 4 = UART1 Rx available
</LI>
<LI>bit 3 = Reserved, must be 0
</LI>
<LI>bit 2 = UART0 Tx empty
</LI>
<LI>bit 1 = UART0 Tx half full
</LI>
<LI>bit 0 = UART0 Tx available
</LI>
</UL>
* Set bits indicate the corresponding interrupt will interrupt a DMA
  operation when in IM2 mode.

<P>
Register (W) $CF (CF) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Reserved (3.01.09)

<P>
Register (R/W) $B8 (B8) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Divmmc Entry Points 0 (3.01.10)
<BR>($83 on reset)

<UL>
<LI>bit 7 = enable automap on address $0038 (instruction fetch)
</LI>
<LI>bit 6 = enable automap on address $0030 (instruction fetch)
</LI>
<LI>bit 5 = enable automap on address $0028 (instruction fetch)
</LI>
<LI>bit 4 = enable automap on address $0020 (instruction fetch)
</LI>
<LI>bit 3 = enable automap on address $0018 (instruction fetch)
</LI>
<LI>bit 2 = enable automap on address $0010 (instruction fetch)
</LI>
<LI>bit 1 = enable automap on address $0008 (instruction fetch)
</LI>
<LI>bit 0 = enable automap on address $0000 (instruction fetch)
</LI>
</UL>

<P>
Register (R/W) $B9 (B9) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Divmmc Entry Points Valid 0 (3.01.10)
<BR>($01 on reset)

<UL>
<LI>bit 7 = address $0038
</LI>
<LI>bit 6 = address $0030
</LI>
<LI>bit 5 = address $0028
</LI>
<LI>bit 4 = address $0020
</LI>
<LI>bit 3 = address $0018
</LI>
<LI>bit 2 = address $0010
</LI>
<LI>bit 1 = address $0008
</LI>
<LI>bit 0 = address $0000
<table width="90%"><tr><td valign="top">&nbsp;0 = Only when ROM3 is present</td></tr>
<tr><td valign="top">&nbsp;1 = Always
</td></tr></table>
</LI>
</UL>

<P>
Register (R/W) $B9 (B9) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Divmmc Entry Points Timing 0 (3.01.10)
<BR>($00 on reset)

<UL>
<LI>bit 7 = address $0038
</LI>
<LI>bit 6 = address $0030
</LI>
<LI>bit 5 = address $0028
</LI>
<LI>bit 4 = address $0020
</LI>
<LI>bit 3 = address $0018
</LI>
<LI>bit 2 = address $0010
</LI>
<LI>bit 1 = address $0008
</LI>
<LI>bit 0 = address $0000
<table width="90%"><tr><td valign="top">&nbsp;0 = Delayed mapping</td></tr>
<tr><td valign="top">&nbsp;1 = Instant mapping
</td></tr></table>
</LI>
</UL>

<P>
Register (R/W) $B8 (B8) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Divmmc Entry Points 1 (3.01.10)
<BR>($CD on reset)

<UL>
<LI>bit 7 = enable automap on address $3Dxx (instant, ROM3, TRDOS)
</LI>
<LI>bit 6 = enable automap on address $1FF8-1FFF (delayed)
</LI>
<LI>bit 5 = enable automap on address $056A (delayed, ROM3, tape traps, nextzxos)
</LI>
<LI>bit 4 = enable automap on address $04D7 (delayed, ROM3, tape traps, nextzxos)
</LI>
<LI>bit 3 = enable automap on address $0562 (delayed, ROM3, tape traps, esxdos, divmmc)
</LI>
<LI>bit 2 = enable automap on address $04C6 (delayed, ROM3, tape traps, esxdos, divmmc)
</LI>
<LI>bit 1 = enable automap on address $0066 (instant, button)
</LI>
<LI>bit 0 = enable automap on address $0066 (delayed, button)
</LI>
</UL>

<P>
Register (R/W) $D8 (D8) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> I/O Traps (experimental)(3.01.10)

<UL>
<LI>bits 7-1 = Reserved, must be 0
</LI>
<LI>bit 0 = Enable FDC traps on ports $2ffd and $3ffd
</LI>
</UL>
* An i/o trap generates a multiface <!-- MATH
 $\overline{\hbox{NMI}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img5.svg"
 ALT="$\overline {\hbox {NMI}}$"></SPAN> with nextreg $02
  indicating which trap occurred
<BR>* Traps cannot be triggered by the DMA or while the multiface, dma, or
 external <!-- MATH
 $\overline{\hbox{NMI}}$
 -->
<SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img5.svg"
 ALT="$\overline {\hbox {NMI}}$"></SPAN> is active
Register (R/W) $D9 (D9) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> I/O Trap Write (experimental)(3.01.10)

<UL>
<LI>bits 7-0 = The byte written during trapped I/O
</LI>
</UL>
Register (W) $FF (FF) <SPAN CLASS="MATH"><IMG STYLE=""
 SRC="img11.svg"
 ALT="$\Rightarrow$"></SPAN> Debug LEDs (DE-1, DE-2 am Multicore only)

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A
 HREF="node168.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="node166.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node166.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html1358"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A> 
<A ID="tex2html1360"
  HREF="node234.html">
<IMG WIDTH="43" HEIGHT="24" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A
 HREF="node168.html">AY-3-8912</A>
<B> Up:</B> <A
 HREF="node166.html">Registers</A>
<B> Previous:</B> <A
 HREF="node166.html">Registers</A>
 &nbsp; <B>  <A ID="tex2html1359"
  HREF="node1.html">Contents</A></B> 
 &nbsp; <B>  <A ID="tex2html1361"
  HREF="node234.html">Index</A></B> </DIV>
<!--End of Navigation Panel-->

</BODY>
</HTML>
