@node INDEX

ZX Spectrum Next Programming Notes

------------------------------------------

@{ "Contents" LINK NODE1 }
@{ "Introduction" LINK NODE2 }
@{ "Video" LINK NODE3 }
* @{ "General Features" LINK NODE4 }
** @{ "Video Layering and Transparency" LINK NODE5 }
** @{ "Palette" LINK NODE6 }
** @{ "Scrolling" LINK NODE8 }
** @{ "Clipping" LINK NODE9 }
* @{ "Layer 1" LINK NODE10 }
** @{ "Colour Attributes" LINK NODE11 }
** @{ "Layer 1 Scrolling" LINK NODE21 }
** @{ "Layer 1 Clipping" LINK NODE22 }
** @{ "ZX Spectrum Mode" LINK NODE23 }
** @{ "Alternate Page Mode" LINK NODE24 }
** @{ "Timex Hi-Colour Mode" LINK NODE25 }
** @{ "Timex Hi-Resolution Mode" LINK NODE26 }
** @{ "Lo-Resolution Mode" LINK NODE27 }
* @{ "Layer 2" LINK NODE28 }
** @{ "Configuration" LINK NODE29 }
** @{ "Scrolling" LINK NODE34 }
** @{ "Clipping" LINK NODE35 }
* @{ "Layer 3 (Tilemap) Mode" LINK NODE36 }
** @{ "General Description" LINK NODE37 }
** @{ "Data Structures" LINK NODE38 }
** @{ "Memory Organization &amp; Display Layer" LINK NODE41 }
** @{ "Combining ULA &amp; Tilemap" LINK NODE42 }
** @{ "Programming Tilemap mode" LINK NODE43 }
* @{ "Sprites" LINK NODE46 }
** @{ "Sprite Patterns" LINK NODE47 }
** @{ "Sprite Palette" LINK NODE51 }
** @{ "Sprite Attributes" LINK NODE52 }
** @{ "Relative Sprites" LINK NODE53 }
** @{ "Programming Sprites" LINK NODE54 }
** @{ "Global Control of Sprites" LINK NODE55 }
@{ "Audio" LINK NODE56 }
* @{ "ZX Spectrum 1-bit" LINK NODE57 }
* @{ "Sampled 8-bit" LINK NODE58 }
* @{ "Turbosound" LINK NODE59 }
** @{ "Pi Audio" LINK NODE60 }
@{ "Memory" LINK NODE61 }
* @{ "Memory Management" LINK NODE62 }
** @{ "Default Layout" LINK NODE63 }
** @{ "RAM" LINK NODE64 }
** @{ "ROM" LINK NODE70 }
* @{ "Interactions between paging methods" LINK NODE76 }
* @{ "Memory Map" LINK NODE77 }
** @{ "Global Memory Map" LINK NODE78 }
** @{ "Z80 Visible Memory Map" LINK NODE79 }
@{ "zxnDMA" LINK NODE80 }
* @{ "Overview" LINK NODE81 }
* @{ "Accessing the zxnDMA" LINK NODE82 }
* @{ "Description" LINK NODE83 }
* @{ "Modes of Operation" LINK NODE84 }
* @{ "Programming the zxnDMA" LINK NODE85 }
* @{ "zxnDMA Registers" LINK NODE86 }
* @{ "Programming examples" LINK NODE96 }
@{ "Copper and Display Timing" LINK NODE97 }
* @{ "Timing" LINK NODE100 }
* @{ "Instructions" LINK NODE108 }
* @{ "Control" LINK NODE113 }
* @{ "Configuration" LINK NODE118 }
@{ "Interrupts" LINK NODE123 }
* @{ "Interrupt Types" LINK NODE124 }
* @{ "Interrupt Modes" LINK NODE128 }
* @{ "Z80 CTC" LINK NODE132 }
@{ "Serial Communication" LINK NODE134 }
@{ "Raspberry Pi0 Acceleration" LINK NODE135 }
@{ "System Software" LINK NODE136 }
* @{ "CP/M" LINK NODE137 }
** @{ "Utilities" LINK NODE138 }
** @{ "BDOS" LINK NODE139 }
** @{ "BIOS" LINK NODE140 }
*** @{ "System Initialization Functions" LINK NODE141 }
*** @{ "Character I/O Functions" LINK NODE142 }
*** @{ "Disk I/O Functions" LINK NODE143 }
** @{ "Memory Select and Move Functions" LINK NODE144 }
*** @{ "Clock Support Function" LINK NODE145 }
* @{ "NextZXOS" LINK NODE146 }
* @{ "NextZXOS" LINK NODE147 }
** @{ "+3DOS compatible API" LINK NODE148 }
** @{ "esxDOS compatible API" LINK NODE149 }
** @{ "Next Extensions" LINK NODE150 }
** @{ "esxDOS compatible API" LINK NODE151 }
@{ "Ports" LINK NODE152 }
* @{ "8-bit" LINK NODE153 }
* @{ "16-bit" LINK NODE154 }
@{ "Registers" LINK NODE155 }
* @{ "ZX Spectrum Next Registers" LINK NODE156 }
* @{ "AY-3-8912" LINK NODE157 }
* @{ "zxDMA" LINK NODE158 }
@{ "Extended Opcodes to Mnemonics" LINK NODE159 }
* @{ "Single Byte Opcodes" LINK NODE160 }
* @{ "$CBxx Bit Operations" LINK NODE161 }
* @{ "$DDxx IX" LINK NODE162 }
* @{ "$EDxx Block/Port" LINK NODE163 }
* @{ "$FDxx IY" LINK NODE164 }
* @{ "$DDCBxx IX Bit Operations" LINK NODE165 }
* @{ "$FDCBxx IY Bit Operations" LINK NODE166 }
@{ "Mnemonics to Extended Opcodes" LINK NODE167 }
@{ "File Formats" LINK NODE168 }
* @{ "BAS" LINK NODE169 }
* @{ "BMP" LINK NODE170 }
* @{ "DSK" LINK NODE171 }
* @{ "NDR" LINK NODE172 }
* @{ "NEX" LINK NODE173 }
* @{ "O" LINK NODE174 }
* @{ "P3D" LINK NODE175 }
* @{ "PT3" LINK NODE176 }
* @{ "P" LINK NODE177 }
* @{ "SCR" LINK NODE178 }
* @{ "SHC" LINK NODE179 }
* @{ "SHR" LINK NODE180 }
* @{ "SL2" LINK NODE181 }
* @{ "SLR" LINK NODE182 }
* @{ "SNA" LINK NODE183 }
* @{ "SNX" LINK NODE184 }
* @{ "SPR" LINK NODE185 }
* @{ "TAP" LINK NODE186 }
* @{ "TXT,DOC,ASM,INI,CFG,MD" LINK NODE187 }
* @{ "TZX" LINK NODE188 }
* @{ "Z3 to Z8" LINK NODE189 }
* @{ "Z80" LINK NODE190 }
@{ "Call Tables" LINK NODE191 }
* @{ "BDOS Call Table" LINK NODE192 }
* @{ "BIOS Call Table" LINK NODE193 }
* @{ "NextZXOS Calls" LINK NODE194 }
** @{ "+3DOS Compatible Calls" LINK NODE195 }
** @{ "+3DOS compatible error codes" LINK NODE196 }
** @{ "esxDOS Compatible Calls" LINK NODE197 }
@{ "List of Figures" LINK NODE198 }
@{ "List of Tables" LINK NODE199 }
@{ "Index" LINK NODE200 }
@{ "About this document ..." LINK NODE201 }

------------------------------------------

@node NODE001

@{h2}Contents

@{ "Introduction" LINK NODE2 }
@{ "Video" LINK NODE3 }
* @{ "General Features" LINK NODE4 }
** @{ "Video Layering and Transparency" LINK NODE5 }
** @{ "Palette" LINK NODE6 }
** @{ "Scrolling" LINK NODE8 }
** @{ "Clipping" LINK NODE9 }
* @{ "Layer 1" LINK NODE10 }
** @{ "Colour Attributes" LINK NODE11 }
** @{ "Layer 1 Scrolling" LINK NODE21 }
** @{ "Layer 1 Clipping" LINK NODE22 }
** @{ "ZX Spectrum Mode" LINK NODE23 }
** @{ "Alternate Page Mode" LINK NODE24 }
** @{ "Timex Hi-Colour Mode" LINK NODE25 }
** @{ "Timex Hi-Resolution Mode" LINK NODE26 }
** @{ "Lo-Resolution Mode" LINK NODE27 }
* @{ "Layer 2" LINK NODE28 }
** @{ "Configuration" LINK NODE29 }
** @{ "Scrolling" LINK NODE34 }
** @{ "Clipping" LINK NODE35 }
* @{ "Layer 3 (Tilemap) Mode" LINK NODE36 }
** @{ "General Description" LINK NODE37 }
** @{ "Data Structures" LINK NODE38 }
** @{ "Memory Organization &amp; Display Layer" LINK NODE41 }
** @{ "Combining ULA &amp; Tilemap" LINK NODE42 }
** @{ "Programming Tilemap mode" LINK NODE43 }
* @{ "Sprites" LINK NODE46 }
** @{ "Sprite Patterns" LINK NODE47 }
** @{ "Sprite Palette" LINK NODE51 }
** @{ "Sprite Attributes" LINK NODE52 }
** @{ "Relative Sprites" LINK NODE53 }
** @{ "Programming Sprites" LINK NODE54 }
** @{ "Global Control of Sprites" LINK NODE55 }
@{ "Audio" LINK NODE56 }
* @{ "ZX Spectrum 1-bit" LINK NODE57 }
* @{ "Sampled 8-bit" LINK NODE58 }
* @{ "Turbosound" LINK NODE59 }
** @{ "Pi Audio" LINK NODE60 }
@{ "Memory" LINK NODE61 }
* @{ "Memory Management" LINK NODE62 }
** @{ "Default Layout" LINK NODE63 }
** @{ "RAM" LINK NODE64 }
** @{ "ROM" LINK NODE70 }
* @{ "Interactions between paging methods" LINK NODE76 }
* @{ "Memory Map" LINK NODE77 }
** @{ "Global Memory Map" LINK NODE78 }
** @{ "Z80 Visible Memory Map" LINK NODE79 }
@{ "zxnDMA" LINK NODE80 }
* @{ "Overview" LINK NODE81 }
* @{ "Accessing the zxnDMA" LINK NODE82 }
* @{ "Description" LINK NODE83 }
* @{ "Modes of Operation" LINK NODE84 }
* @{ "Programming the zxnDMA" LINK NODE85 }
* @{ "zxnDMA Registers" LINK NODE86 }
* @{ "Programming examples" LINK NODE96 }
@{ "Copper and Display Timing" LINK NODE97 }
* @{ "Timing" LINK NODE100 }
* @{ "Instructions" LINK NODE108 }
* @{ "Control" LINK NODE113 }
* @{ "Configuration" LINK NODE118 }
@{ "Interrupts" LINK NODE123 }
* @{ "Interrupt Types" LINK NODE124 }
* @{ "Interrupt Modes" LINK NODE128 }
* @{ "Z80 CTC" LINK NODE132 }
@{ "Serial Communication" LINK NODE134 }
@{ "Raspberry Pi0 Acceleration" LINK NODE135 }
@{ "System Software" LINK NODE136 }
* @{ "CP/M" LINK NODE137 }
** @{ "Utilities" LINK NODE138 }
** @{ "BDOS" LINK NODE139 }
** @{ "BIOS" LINK NODE140 }
** @{ "Memory Select and Move Functions" LINK NODE144 }
* @{ "NextZXOS" LINK NODE146 }
* @{ "NextZXOS" LINK NODE147 }
** @{ "+3DOS compatible API" LINK NODE148 }
** @{ "esxDOS compatible API" LINK NODE149 }
** @{ "Next Extensions" LINK NODE150 }
** @{ "esxDOS compatible API" LINK NODE151 }
@{ "Ports" LINK NODE152 }
* @{ "8-bit" LINK NODE153 }
* @{ "16-bit" LINK NODE154 }
@{ "Registers" LINK NODE155 }
* @{ "ZX Spectrum Next Registers" LINK NODE156 }
* @{ "AY-3-8912" LINK NODE157 }
* @{ "zxDMA" LINK NODE158 }
@{ "Extended Opcodes to Mnemonics" LINK NODE159 }
* @{ "Single Byte Opcodes" LINK NODE160 }
* @{ "$CBxx Bit Operations" LINK NODE161 }
* @{ "$DDxx IX" LINK NODE162 }
* @{ "$EDxx Block/Port" LINK NODE163 }
* @{ "$FDxx IY" LINK NODE164 }
* @{ "$DDCBxx IX Bit Operations" LINK NODE165 }
* @{ "$FDCBxx IY Bit Operations" LINK NODE166 }
@{ "Mnemonics to Extended Opcodes" LINK NODE167 }
@{ "File Formats" LINK NODE168 }
* @{ "BAS" LINK NODE169 }
* @{ "BMP" LINK NODE170 }
* @{ "DSK" LINK NODE171 }
* @{ "NDR" LINK NODE172 }
* @{ "NEX" LINK NODE173 }
* @{ "O" LINK NODE174 }
* @{ "P3D" LINK NODE175 }
* @{ "PT3" LINK NODE176 }
* @{ "P" LINK NODE177 }
* @{ "SCR" LINK NODE178 }
* @{ "SHC" LINK NODE179 }
* @{ "SHR" LINK NODE180 }
* @{ "SL2" LINK NODE181 }
* @{ "SLR" LINK NODE182 }
* @{ "SNA" LINK NODE183 }
* @{ "SNX" LINK NODE184 }
* @{ "SPR" LINK NODE185 }
* @{ "TAP" LINK NODE186 }
* @{ "TXT,DOC,ASM,INI,CFG,MD" LINK NODE187 }
* @{ "TZX" LINK NODE188 }
* @{ "Z3 to Z8" LINK NODE189 }
* @{ "Z80" LINK NODE190 }
@{ "Call Tables" LINK NODE191 }
* @{ "BDOS Call Table" LINK NODE192 }
* @{ "BIOS Call Table" LINK NODE193 }
* @{ "NextZXOS Calls" LINK NODE194 }
** @{ "+3DOS Compatible Calls" LINK NODE195 }
** @{ "+3DOS compatible error codes" LINK NODE196 }
** @{ "esxDOS Compatible Calls" LINK NODE197 }
@{ "List of Figures" LINK NODE198 }
@{ "List of Tables" LINK NODE199 }
@{ "Index" LINK NODE200 }

------------------------------------------

@node NODE002

@{h1}Introduction

The ZX Spectrum Next is an extension of the original ZX Spectrum
implemented in FPGA which implements many of the common additions to
the system includin the characteristics of all of the original ZX
Spectrum line, including the Timex/Sinclair 2068, along with a number
of characteristics to modernize the design.

This document is an attempt to consolidate the programming interface
for the ZX Spectrum Next into a single location. This document started
when much of the documentation on the ZX Spectrum Next site
(https://www.specnext.com/) was out of date and/or difficult to figure
out. The way to figure out how things actually worked was to either
dig through the forums and ask questions or find someones code that
implemented a particular bit of functionality and reverse engineer
it. The situation has greatly improved and this document may even be
redundant at this point.

Description from http://www.specnext.com/about/:

The Spectrum Next is fully implemented with FPGA technology, ensuring
it can be upgraded and enhanced while remaining truly compatible with
the original hardware by using special memory chips and clever
design. Here’s what under the hood of the machine:

* Processor: Z80n normal and turbo modes

* Memory: 1024Kb RAM (expandable to 2048Kb on board)

* Video: Multilayer video implementing classic ZX Spectrum, Timex
Hi-Resolution, Timex Hi-Colour, LoRes, Layer 2, and Tilemap video
modes with Hardware sprites

* Video Output: RGB, VGA, HDMI

* Storage: SD Card slot, with DivMMC-compatible protocol

* Audio: ZX Spectrum 1-bit audio, Turbo Sound Next (3x AY-3-8912
audio chips with stereo output), stereo PCM audio, and ability to
use Pi accelerator as a sound source

* Joystick: DB9 compatible with Cursor, Kempston and Interface 2
protocols (selectable)

* PS/2 port: Mouse with Kempston mode emulation and an external keyboard

* Special: Multiface functionality for memory access, savegames,
cheats etc.

* Tape support: Mic and Ear ports for tape loading and saving

* Expansion: Original external bus expansion port and accelerator
expansion port

* Accelerator board (optional): Pi Zero with GPU / 1Ghz CPU / 512Mb RAM

* Network (optional): Wi Fi module

* Extras: Real Time Clock (optional), internal speaker (optional)

@node NODE003

@{h1}Video

ZX Spectrum Next video splits the display types into four categories
(layer 1 (ULA/Timex/LoRes), layer 2, layer 3 (tilemap) and sprites)
which have their own sets of controls for colour palettes, clipping,
and scrolling. Some aspects of ULA and tilemap are tied together, but
all the rest operate in a largely independent manner using a layering
system. The ULA category has a number of separate video modes that it
can use. One of these (LoRes) is incompatible with using tilemaps
(This may have change in the most recent cores).

------------------------------------------

Subsections

@{ "General Features" LINK NODE4 }
* @{ "Video Layering and Transparency" LINK NODE5 }
* @{ "Palette" LINK NODE6 }
** @{ "Next Colour Palettes" LINK NODE7 }
* @{ "Scrolling" LINK NODE8 }
* @{ "Clipping" LINK NODE9 }
@{ "Layer 1" LINK NODE10 }
* @{ "Colour Attributes" LINK NODE11 }
** @{ "ULA Colour" LINK NODE12 }
** @{ "ULANext" LINK NODE13 }
** @{ "ULAplus" LINK NODE14 }
* @{ "Layer 1 Scrolling" LINK NODE21 }
* @{ "Layer 1 Clipping" LINK NODE22 }
* @{ "ZX Spectrum Mode" LINK NODE23 }
* @{ "Alternate Page Mode" LINK NODE24 }
* @{ "Timex Hi-Colour Mode" LINK NODE25 }
* @{ "Timex Hi-Resolution Mode" LINK NODE26 }
* @{ "Lo-Resolution Mode" LINK NODE27 }
@{ "Layer 2" LINK NODE28 }
* @{ "Configuration" LINK NODE29 }
** @{ "Layer 2 256x192, Write only overlaid on ROM" LINK NODE30 }
** @{ "Layer 2 256x192 resolution" LINK NODE31 }
** @{ "Layer 2 320x256 resolution" LINK NODE32 }
** @{ "Layer 2 640x256 resolution" LINK NODE33 }
* @{ "Scrolling" LINK NODE34 }
* @{ "Clipping" LINK NODE35 }
@{ "Layer 3 (Tilemap) Mode" LINK NODE36 }
* @{ "General Description" LINK NODE37 }
* @{ "Data Structures" LINK NODE38 }
** @{ "Tilemap" LINK NODE39 }
** @{ "Tile Definitions" LINK NODE40 }
* @{ "Memory Organization & Display Layer" LINK NODE41 }
* @{ "Combining ULA & Tilemap" LINK NODE42 }
* @{ "Programming Tilemap mode" LINK NODE43 }
** @{ "Changes Since 2.00.26" LINK NODE44 }
** @{ "Future Direction" LINK NODE45 }
@{ "Sprites" LINK NODE46 }
* @{ "Sprite Patterns" LINK NODE47 }
** @{ "Pattern Number" LINK NODE48 }
* @{ "Sprite Palette" LINK NODE51 }
* @{ "Sprite Attributes" LINK NODE52 }
* @{ "Relative Sprites" LINK NODE53 }
* @{ "Programming Sprites" LINK NODE54 }
* @{ "Global Control of Sprites" LINK NODE55 }

------------------------------------------

@node NODE004

@{h1}General Features

There are a number of control features for the various video modes
that are done in a unified fashion. These features are layering and
transparency, palettes, scrolling, and clipping. For the sake of
convenience we will occasionally talk about a global coordinate system
for graphics on the ZX Next. This coordinate system has (0, 0) at the
upper left corner of the usable display area and (319, 255) at the
lower right corner. Individual pixels generally correspond to integer
locations in this grid, but some modes may either double or halve this
grid. This will be discussed in the sections for each of the video
layers.

------------------------------------------

Subsections

@{ "Video Layering and Transparency" LINK NODE5 }
@{ "Palette" LINK NODE6 }
* @{ "Next Colour Palettes" LINK NODE7 }
@{ "Scrolling" LINK NODE8 }
@{ "Clipping" LINK NODE9 }

------------------------------------------

@node NODE005

@{h2}Video Layering and Transparency

Video for the ZX Next is composed of a number of features and layers
each of which may have its own set of video modes. Not all of these
features are mandatory.

By composing together the border colour and transparency fallback
color, layer 1 (ULA, Timex modes, or LoRes), layer 2 (256x192x256,
320x256x256, or 640x256x16), layer 3 (16 or 2 colour tiles), and
sprites; we generate the full video display.

The border/transparency fallback is the bottom with the ordering of
the layers controlled by a combination of the video layering register
(Next register $15 (21) bits 4-2), the interaction of layers 1 and 3
(Next register $6B (107) bit 0), and whether or not a pixel in layer 2
is set as a priority colour.

Register (R/W) $15 (15) => Sprite and Layer System Setup
* bit 7 = LoRes mode (0 on reset)
* bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on
top) (0 on reset)
* bit 5 = Enable sprite clipping in over border mode (0 on reset)
* bits 4-2 = set layers priorities (000 on reset)
** 000 - S L U
** 001 - L S U
** 010 - S U L
** 011 - L U S
** 100 - U S L
** 101 - U L S
** 110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7
** 111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]
* bit 1 = Enable Sprites Over border (0 on reset)
* bit 0 = Enable Sprites (0 on reset)

Transparency for Layer 2, Layer 1, and 1-bit Tilemaps are
controlled by Next register $14 (20) and defaults to $E3. Sprites
and 4-bit Tilemaps have their own registers ($4B and $4C
respectively) for setting their transparency index (not colour). This
colour ignores the state of the least significant blue bit, so $E3
equates to both $1C6 and $1C7. For Sprites and Tilemaps transparency
is determined by colour index. For Sprites this is controlled by
register $4B (with only the least significant 4-bits being relevant
for 16-colour Sprites). For Tilemaps, the transparency index is set by
register $4C. If all layers are transparent, the transparency
fallback colour is displayed. This is set by register $4A.

Register (R/W) $14 (14) => Global transparency color
* bits 7-0 = Transparency color value ($E3 after a reset)
(Note: this value is 8-bit, so the transparency is compared against
only by the MSB bits of the final 9-bit colour)
(Note2: this only affects Layer 2, ULA and LoRes. Sprites use register
$4B for transparency and tilemap uses nextreg $4C)

Register (R/W) $4A (4A) => Fallback Colour Value
* bits 7-0 = 8-bit colour if all layers are transparent ($E3 on
reset)
(black on reset = 0)

Register (R/W) $4B (4B) => Sprite Transparency Index
* bits 7-0 = Index value ($E3 if reset)
For 4-bit sprites only the bottom 4-bits are relevant.

Register (R/W) $4C (4C) => Level 3 Transparency Index
* bits 7-4 = Reserved, must be 0
* bits 3-0 = Index value ($0F on reset)

@node NODE006

@{h2}Palette

------------------------------------------
Subsections

* @{ "Next Colour Palettes" LINK NODE7 }

------------------------------------------

@node NODE007

@{h4}Next Colour Palettes

Each video mode group has a pair of palettes assigned to it a primary
and an alternate palette. Each palette entry is actually a 9-bit value
(RRRGGGBBB) and can be set by selecting a palette using nextreg $43
(palette control), the entry using nextreg $40 (palette index), then
writing the value into nextreg $44 (palette value, 9-bit) using pairs
of consecutive writes for each palette value or nextreg $41 (palette
value, 8-bit). Once a palette index has been selected writes
automatically increment the palette index number so it is possible to
efficiently write the values for a collection of palette entries.

Register (R/W) $40 (40) => Palette Index Select
* bits 7-0 = Palette Index Number

Selects the palette index to change the associated colour

For ULA only, INKs are mapped to indices 0 through 7, BRIGHT INKs to
indices 8 through 15, PAPERs to indices 16 through 23 and BRIGHT
PAPERs to indices 24 through 31.  In EnhancedULA mode, INKs come from
a subset of indices from 0 through 127 and PAPERs from a subset of
indices from 128 through 255.

The number of active indices depends on the number of attribute bits
assigned to INK and PAPER out of the attribute byte.

In ULAplus mode, the last 64 entries (indices 192 to 255) hold the
ULAplus palette.  The ULA always takes border colour from PAPER for
standard ULA and Enhanced ULA

Register (R/W) $41 (41) => 8-bit Palette Data
* bits 7-0 = Colour Entry in RRRGGGBB format

The lower blue bit of the 9-bit internal colour will be the logical or
of bits 0 and 1 of the 8-bit entry. After each write, the palette
index auto-increments if aut-increment has been enabled (NextReg $43
bit 7), Reads do not auto-increment.

Register (R/W) $43 (43) => Palette Control
* bit 7 = Disable palette write auto-increment.
* bits 6-4 = Select palette for reading or writing:
** 000 = ULA first palette
** 100 = ULA second palette
** 001 = Layer 2 first palette
** 101 = Layer 2 second palette
** 010 = Sprite first palette
** 110 = Sprite second palette
** 011 = Layer 3 first palette
** 111 = Layer 3 second palette
* bit 3 = Select Sprite palette (0 = first palette, 1 = second
palette)
* bit 2 = Select Layer 2 palette (0 = first palette, 1 = second
palette)
* bit 1 = Select ULA palette (0 = first palette, 1 = second
palette)
* bit 0 = Enable EnhancedULA mode if 1. (0 after a reset)

Register (R/W) $44 (44) => 9-bit Palette Data
Non Level 2
 1st write
bits 7-0 = MSB (RRRGGGBB)
 2nd write
bits 7-1 = Reserved, must be 0
bit 0 = LSB (B)

Level 2
 1st write
bits 7-0 = MSB (RRRGGGBB)
 2nd write
bit 7 = Priority
bits 6-1 = Reserved, must be 0
bit 0 = LSB (B)

9-bit Palette Data is entered in two consecutive writes; the second
write autoincrements the palette index if auto-increment is enabled in
NextREG $43 bit 7

If writing an L2 palette, the second write's D7 holds the L2 priority
bit which if set (1) brings the colour defined at that index on top of
all other layers. If you also need the same colour in regular priority
(for example: for enviromental masking) you will have to set it up
again, this time with no priority.

Reads return the second byte and do not autoincrement. Writes to
nextreg $40, $41, $41, or $43 reset to the first write.

@node NODE008

@{h2}Scrolling

The ZX Spectrum Next has four sets of scrolling registers to
independently contol the display offsets of various video modes
(Layer2, ULA, Tilemap, and LoRes). When the video is offset, the
portion that is pushed off the screen (to the left and or top) then
becomes visible on the opposite side of the screen so that the video
offset values are effectively the coordinates of the origin in a
toroidal universe.

------------------------------------------

@node NODE009

@{h2}Clipping

The ZX Spectrum Next has four clipping registers create a window of
the layer that is visible. Clipping is managed by a set of four
successive writes to the clipping register applicable for the video
mode. If a section is masked off by clipping, it is as if the area
were the transparency colour and the video lyers behind it become
visible.

------------------------------------------

@node NODE010

@{h1}Layer 1

The Layer 1 consists of ZX Spectrum ULA video, Timex video modes, and
the Spectrum Next’s lores video modes all use 16k memory bank 5 or 7
with the data coming from some combination of addresses $0000-$17FF
(bitmap 1), $1800-$1AFF (attribute 1), $2000-$37FF (bitmap 2), and
$3800-$3AFF (attribute 2) within the selected bank.  Assuming
default memory mapping and the use of bank 5 this will be mapped as
some combination of memory $4000-$57FF, $5800-$5AFF,
$6000-$77FF, $780-$7AFF. All of the modes other than the lores
mode can either use the default ZX Spectrum colours, ULANext mode, or
an emulation of ULAplus. In the Spectrum and Timex modes all colours are
either Paper (foreground), paper (background), or border colours.

------------------------------------------

Subsections

@{ "Colour Attributes" LINK NODE11 }
* @{ "ULA Colour" LINK NODE12 }
* @{ "ULANext" LINK NODE13 }
* @{ "ULAplus" LINK NODE14 }
** @{ "I/O ports" LINK NODE15 }
** @{ "GRB palette entries" LINK NODE16 }
** @{ "Grayscale palette entries" LINK NODE17 }
** @{ "Limitations" LINK NODE18 }
** @{ "Emulation" LINK NODE19 }
** @{ "Palette file format" LINK NODE20 }
@{ "Layer 1 Scrolling" LINK NODE21 }
@{ "Layer 1 Clipping" LINK NODE22 }
@{ "ZX Spectrum Mode" LINK NODE23 }
@{ "Alternate Page Mode" LINK NODE24 }
@{ "Timex Hi-Colour Mode" LINK NODE25 }
@{ "Timex Hi-Resolution Mode" LINK NODE26 }
@{ "Lo-Resolution Mode" LINK NODE27 }

@node NODE011

@{h2}Colour Attributes

The ZX Spectrum Next has three major modes for colour attributes: the
ZX Spectrum attribute mapping, which is augmented by using the ZX
Spectrum Next's palette; ULANext, which allows the user to how many
foreground and how many background colous are to be selected by the
attribute bytes; and an emulation of ULAplus.

------------------------------------------

Subsections

* @{ "ULA Colour" LINK NODE12 }
* @{ "ULANext" LINK NODE13 }
* @{ "ULAplus" LINK NODE14 }
** @{ "I/O ports" LINK NODE15 }
** @{ "GRB palette entries" LINK NODE16 }
** @{ "Grayscale palette entries" LINK NODE17 }
** @{ "Limitations" LINK NODE18 }
** @{ "Emulation" LINK NODE19 }
** @{ "Palette file format" LINK NODE20 }

------------------------------------------

@node NODE012

@{h4}ULA Colour

In ULA colour INKs are mapped to indices 0-7, Bright INKS to indices
8-15, PAPERs to indices 16-23 and Bright PAPERs to indices 24-31. This
is the default state for interpreting ULA palettes.

------------------------------------------

@node NODE013

@{h4}ULANext

The ULANext modes use a varying number of bits from the attribute
byte to determine the ink colours as the palette index from the
appropriate bits (all others being zero) and the paper colours coming
from the indicated value+128 with palette format 255 being a special
case where all the bits determine the ink colour while the paper is
always palette index 128. The ULA always takes border colour from
paper. ULANext is enabled using bit 0 of nextreg $43 (palette
control) and controlled with nextreg $42 (ULA Next attribute byte
format)

------------------------------------------

@node NODE014

@{h4}ULAplus

The ZX Next emulates ULAPlus using the last 64 (192-255) entries of
the ULA palette. ULAplus is controlled using two ports: $BF3B (register
port) and $FF3B (data port)

------------------------------------------

Subsections

@{ "I/O ports" LINK NODE15 }
@{ "GRB palette entries" LINK NODE16 }
@{ "Grayscale palette entries" LINK NODE17 }
@{ "Limitations" LINK NODE18 }
@{ "Emulation" LINK NODE19 }
@{ "Palette file format" LINK NODE20 }

------------------------------------------

@node NODE015

@{h5}I/O ports

ULAplus is controlled by two ports.

$BF3B is the register port (write only)

The byte output will be interpreted as follows:

Bits 7-6: Select the register group. Two groups are currently available:
* 00=palette group
When this group is selected, the sub-group determines the entry in the
palette table (0-63).
* 01=mode group
The sub-group is (optionally) used to mirror the video functionality
of Timex port $FF as follows:

Bits 5-0: Select the register sub-group&nbsp;Mode group

Bits 5-3: Sets the screen colour in hi-res mode.
* 000=Black on White
* 001=Blue on Yellow
* 010=Red on Cyan
* 011=Magenta on Green
* 100=Green on Magenta
* 101=Cyan on Red
* 110=Yellow on Blue
* 111=White on Black

Bits 2-0: Screen mode.
* 000=screen 0 (bank 5)
* 001=screen 1 (bank 5)
* 010=hi-colour (bank 5)
* 100=screen 0 (bank 7)
* 101=screen 1 (bank 7)
* 110=hi-colour (bank 7)
* 110=hi-res (bank 5)
* 111=hi-res (bank 7)

$FF3B is the data port (read/write)

When the palette group is selected, the byte written will describe the
color.

When the mode group is selected, the byte output will be interpreted
as follows:

* Bit 0: ULAplus palette on (1) / off (0)
* Bit 1: (optional) grayscale: on (1) / off (0) (same as turing
the color off on the television)

Implementations that support the Timex video modes use the $FF
register as the primary means to set the video mode, as per the Timex
machines. It is left to the individual implementations to determine if
reading the port returns the previous write or the floating bus.

@node NODE016

@{h5}GRB palette entries

G3R3B2 encoding

For a device using the GRB colour space the palette entry is
interpreted as follows

* Bits 7-5: Green intensity.
* Bits 4-2: Red intensity.
* Bits 1-0: Blue intensity.

This colour space uses a sub-set of 9-bit GRB. The missing lowest blue
bit is set to OR of the other two blue bits (Bb becomes 000 for 00,
and Bb1 for anything else). This gives access to a fixed half the
potential 512 colour palette. The reduces the jump in intensity in the
lower range in the earlier version of the specification. It also means
the standard palette can now be represented by the ULAplus palette.

------------------------------------------

@node NODE017

@{h5}Grayscale palette entries

This is an optional ULAPlus feature that is not supported on the Next.

In grayscale mode, each palette entry describes an intensity from zero
to 255. This can be achieved by simply removing the colour from the
output signal.

------------------------------------------

@node NODE018

@{h5}Limitations

Although in theory 64 colours can be displayed at once, in practice
this is usually not possible except when displaying colour bars,
because the four CLUTs are mutually exclusive; it is not possible to
mix colours from two CLUTs in the same cell. However, with software
palette cycling it is possible to display all 256 colours on screen at
once.

------------------------------------------

@node NODE019

@{h5}Emulation

The 64 colour mode lookup table is organized as 4 palettes of 16
colours.

Bits 7 and 6 of each Spectrum attribute byte (normally used for FLASH
and BRIGHT) will be used as an index value (0-3) to select one of the
four colour palettes.

Each colour palette has 16 entries (8 for INK, 8 for PAPER). Bits 0 to
2 (INK) and 3 to 5 (PAPER) of the attribute byte will be used as
indexes to retrieve colour data from the selected palette.

With the standard Spectrum display, the BORDER colour is the same as
the PAPER colour in the first CLUT. For example BORDER 0 would set the
border to the same colour as PAPER 0 (with the BRIGHT and FLASH bits
not set).

The complete index can be calculated as

ink_colour = (FLASH * 2 + BRIGHT) * 16 + INK
paper_colour = (FLASH * 2 + BRIGHT) * 16 + PAPER + 8

------------------------------------------

@node NODE020

@{h5}Palette file format

The palette format doubles as the BASIC patch loader. This enables you
to edit patches produced by other people.

; 64 colour palette file format (internal) - version 1.0
; copyright (c) 2009 Andrew Owen
;
; The palette file is stored as a BASIC program with embedded machine code

header:

db 0x00 ; program file
db 0x14, 0x01, "64colour" ; file name
dw 0x0097 ; data length
dw 0x0000 ; autostart line
dw 0x0097 ; program length

basic:

; 0 RANDOMIZE USR ((PEEK VAL "2
; 3635"+VAL "256"*PEEK VAL "23636"
; )+VAL "48"): LOAD "": REM

db 0x00, 0x00, 0x93, 0x00, 0xf9, 0xc0, 0x28, 0x28
db 0xbe, 0xb0, 0x22, 0x32, 0x33, 0x36, 0x33, 0x35
db 0x22, 0x2b, 0xb0, 0x22, 0x32, 0x35, 0x36, 0x22
db 0x2a, 0xbe, 0xb0, 0x22, 0x32, 0x33, 0x36, 0x33
db 0x36, 0x22, 0x29, 0x2b, 0xb0, 0x22, 0x34, 0x38
db 0x22, 0x29, 0x3a, 0xef, 0x22, 0x22, 0x3a, 0xea

start:

di ; disable interrupts
ld hl, 38 ; HL = length of code
add hl, bc ; BC = entry point (start) from BASIC
ld bc, 0xbf3b ; register select
ld a, 64 ; mode group
out (c), a ;
ld a, 1 ;
ld b, 0xff ; choose register port
out (c), a ; turn palette mode on
xor a ; first register

setreg:

ld b, 0xbf ; choose register port
out (c), a ; select register
ex af, af' ; save current register select
ld a, (hl) ; get data
ld b, 0xff ; choose data port
out (c), a ; set it
ex af, af' ; restore current register
inc hl ; advance pointer
inc a ; increase register
cp 64 ; are we nearly there yet?
jr nz, setreg ; repeat until all 64 have been done
ei ; enable interrupts
ret ; return

; this is where the actual data is stored. The following is an example palette.

registers:

db 0x00, 0x02, 0x18, 0x1b, 0xc0, 0xc3, 0xd8, 0xdb ; INK
db 0x00, 0x02, 0x18, 0x1b, 0xc0, 0xc3, 0xd8, 0xdb ; PAPER
db 0x00, 0x03, 0x1c, 0x1f, 0xe0, 0xe3, 0xfc, 0xff ; +BRIGHT
db 0x00, 0x03, 0x1c, 0x1f, 0xe0, 0xe3, 0xfc, 0xff ;
db 0xdb, 0xd8, 0xc3, 0xc0, 0x1b, 0x18, 0x02, 0x00 ; +FLASH
db 0xdb, 0xd8, 0xc3, 0xc0, 0x1b, 0x18, 0x02, 0x00 ;
db 0xff, 0xfc, 0xe3, 0xe0, 0x1f, 0x1c, 0x03, 0x00 ; +BRIGHT/
db 0xff, 0xfc, 0xe3, 0xe0, 0x1f, 0x1c, 0x03, 0x00 ; +FLASH

terminating_byte:

db 0x0d

------------------------------------------

@node NODE021

@{h2}Layer 1 Scrolling

Layer 1 has two sets of scrolling registers. One for the the legacy
modes (ZX Spectrum, Alternate Page, Timex Hi-Resoulution, and Timex
Hi-colour) and a second set for the two ZX Spextrum Next specific
LoRes modes.  All modes scroll as if they were img1.svg"
ALT="$256\times 192$"> screens
located at global coordinates (32, 32) to (287, 223), The registers
for the legacy modes are $26 and $27 and the registers for the LoRes
modes are $32 and $33.

Register (R/W) $26 (26) => ULA Horizontal Scroll Control
* bits 7-0 = ULA X Offset (0-255) (0 on reset)

Register (R/W) $27 (27) => ULA Vertical Scroll Control
* bits 7-0 = ULA Y Offset (0-191) (0 on reset)

Register (R/W) $32 (32) => Layer 1,0 (LoRes) Horizontal Scroll Control)
* bits 7-0 = X Offset (0-255) ($00 on reset)
Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and
smoothness as Layer 2.

Register (R/W) $33 (33) => Layer 1,0 (LoRes) Vertical Scroll Control)
* bits 7-0 = Y Offset (0-191) ($00 on reset)
Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and
smoothness as Layer 2.

@node NODE022

@{h2}Layer 1 Clipping

All of the modes in the Layer 1 share a single clipping register,
$1A. The clip index may alternately be set using register $1C. This is
expecially useful for reading the current clipping coordinates as
reads on the clipping register do not change the index. Note that
clipping coordinates are based on a full display area for the mode of
256x192 resolution even though not all modes have that resolution.

Register (R/W) $1A (1A) => Layer 0 (ULA/LoRes) Clip Window Definition
* bits 7-0 = Coord. of the clip window
 1st write = X1 position
 2nd write = X2 position
 3rd write = Y1 position
 4rd write = Y2 position
The values are 0,255,0,191 after a Reset
Reads do not advance the clip position

Register (R/W) $1C (1C) => Clip Window Control
Read
* bits 7-6 = Layer 3 Clip Index
* bits 5-4 = Layer 0/1 Clip Index
* bits 3-2 = Sprite clip index
* bits 1-0 = Layer 2 Clip Index

Write
* bits 7-4 = Reserved, must be 0
* bit 3 - reset Layer 3 clip index
* bit 2 - reset Layer 0/1 clip index
* bit 1 - reset sprite clip index.
* bit 0 - reset Layer 2 clip index.

@node NODE023

@{h2}ZX Spectrum Mode

Timex mode 0

This is the default ULA mode and has its origins in the original ZX
Spectrum. It uses 256x192 pixels located at global coordinates (32,
32) to (287, 223) with 8x8 colour attribute areas mapped into a 32x24
grid. If Timex modes are not enabled, this and the LoRes mode are the
only ones available, so you would switch back to this mode by writing
000xxxxx to Next register $15 (21, the sprites and layers
register). If another Timex mode is enabled, then this is mode 0 so
you would write 0 to port $ff to enable it. This is a 256x192 video
mode. The bitmap 1 area is used for selection between ink and paper
colours with one bit per pixel and the attribute 1 area for colour
attributes.

The easiest way to visualize the mapping of this mode is to think of
256x192 area as being divided into a 32x24 grid of 8x8 characters.  IF
we consider X and Y as the position in the grid and R to the the row
within the character.  For ink/paper selection, 0=paper, 1=ink and the
entries are stored left to right as lsb to msb within the byte.  The
address for a pixel value is: 0R4R3Y2Y1Y0R2R1R0C4C3C2C1C0 . Each 8x8
cell has its own colour attribute where the address for an attribute
cell is 0110R4R3R2R1R0C4C3C2C1C0 in other words mapped lineally
column-wise starting at the beginning of the attribute 1 area.

Code:

;; from any other Timex mode:
ld a,$00
ld c,$ff
out (c),a

;; from LoRes mode:
ld bc,$243B ; next register select port
ld a,$15
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
and $7f
out (c),a

@node NODE024

@{h2}Alternate Page Mode

Timex mode 1

This mode is the same as ZX Spectrum mode except it is at an alternate
addresses. Alternate page mode is selected by enabling Timex modes by
writing 00xxxx1xx to Next register $08 (8, Peripheral 3 setting) then
writing 1 to the Timex ULA port ($ff).  It is identical to ZX
Spectrum mode except the pixel are mapped to the bitmap 2 area giving
use pixel addresses of <!-- MATH
$1R_4R_3Y_2Y_1Y_0R_2R_1R_0C_4C_3C_2C_1C_0$
-->
img18.svg"
ALT="$1R_4R_3Y_2Y_1Y_0R_2R_1R_0C_4C_3C_2C_1C_0$"> and
the attributes to the attribute 2 area with addresses of
[<!-- MATH]

$1110R_4R_3R_2R_1R_0C_4C_3C_2C_1C_0$
-->
img19.svg"
ALT="$1110R_4R_3R_2R_1R_0C_4C_3C_2C_1C_0$">.

Code:

;; disable LoRes mode:
ld bc,$243B ; next register select port
ld a,$15
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
and $7f
out (c),a
;; set Timex mode
ld bc,$243B ; next register select port
ld a,$08
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
or $04
out (c),a
;; set alternate page mode
ld c,$ff
ld a,$01
out (c),a


------------------------------------------
@node NODE025


@{h2}Timex Hi-Colour Mode

Timex mode 2

This mode is a img1.svg"
ALT="$256\times 192$"> video mode located at global coordinates
(32, 32) to (287, 223) with img20.svg"
ALT="$8\times1$"> colour attribute mapping on a
img21.svg"
ALT="$32\times192$"> grid. It is selected by writing 2 to the Timex ULA port
($ff).  Pixel mapping in this mode is the same as in ZX Spectrum mode
using the bitmap 1 area based on
[<!-- MATH]

$0R_4R_3Y_2Y_1Y_0R_2R_1R_0C_4C_3C_2C_1C_0$
-->
img16.svg"
ALT="$0R_4R_3Y_2Y_1Y_0R_2R_1R_0C_4C_3C_2C_1C_0$">.  The colour attributes use
the bitmap 2 area with img20.svg"
ALT="$8\times1$"> colour attribute areas corresponding
to the addresses <!-- MATH
$1R_4R_3Y_2Y_1Y_0R_2R_1R_0C_4C_3C_2C_1C_0$
-->
img18.svg"
ALT="$1R_4R_3Y_2Y_1Y_0R_2R_1R_0C_4C_3C_2C_1C_0$">.

Code:

;; disable LoRes mode:
ld bc,$243B ; next register select port
ld a,$15
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
and $7f
out (c),a
;; set Timex mode
ld bc,$243B ; next register select port
ld a,$08
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
or $04
out (c),a
;; set hi-colour mode
ld c,$ff
ld a,$02
out (c),a


------------------------------------------
@node NODE026


@{h2}Timex Hi-Resolution Mode

Timex mode 6

This is a monochrome img22.svg"
ALT="$512\times192$"> video mode located at global
coordinates (32, 32) to (287, 223) with each pixel being half
width. It is selected by writing to the Timex ULA port ($ff with
values that also select which two colours (or colour entries in
ULANext mode) you use.

Pixels are mapped into both the bitmap 1 and bitmap 2 areas where
8-pixel wide character columns alternate between the two bitmap areas.
The pixels within a byte being rendered left to right lsb to msb as in
other Spectrum video modes.  The addresses for each row within a
character are based on a img24.svg"
ALT="$64\times32$"> grid of img14.svg"
ALT="$8\times8$"> characters
which using a img25.svg"
ALT="$64\times24$"> R, C, and Y scheme gives us addresses of
the form <!-- MATH
$C_0R_4R_3Y_2Y_1Y_0R_2R_1R_0C_5C_4C_3C_2C_1$
-->
img26.svg"
ALT="$C_0R_4R_3Y_2Y_1Y_0R_2R_1R_0C_5C_4C_3C_2C_1$">.

Code:

;; disable LoRes mode:
ld bc,$243B ; next register select port
ld a,$15
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
and $7f
out (c),a
;; set Timex mode
ld bc,$243B ; next register select port
ld a,$08
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
or $04
out (c),a
;; set hi-res mode, black on white
ld c,$ff
ld a,$06
out (c),a


------------------------------------------
@node NODE027


@{h2}Lo-Resolution Mode

This is a Spectrum Next specific video mode with a resolution of
img27.svg"
ALT="$128\times96$"> located at global coordinates (32, 32) to (287, 223)
with each pixel being double height and double width replacing the old
Radistan mode.  It can either allow for 16 colours, in which case it
uses either the bitmap 1 area or the bitmap 2 area, or 256 colours
using both bitmap 1 and bitmap 2. The colour of each pixel can be
selected independently with data ordered linearly in a row major
fashion. In the case of 16 colour mode, the nybbles describing the
colours are X major (MSN LSN). Scrolling is by half pixels and uses
different registers ($32 and $33) from the rest of the ULA group
modes. LoRes mode is enabled by writing img28.svg"
ALT="$100xxxxx$"> to Next register
$15 (the sprites and layers register) with Next register $6A used to
decide whether it is 16 or 256 colours.

Register (R/W) $15 (15) => Sprite and Layer System Setup

* bit 7 = LoRes mode (0 on reset)

* bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on
top) (0 on reset)

* bit 5 = Enable sprite clipping in over border mode (0 on reset)

* bits 4-2 = set layers priorities (000 on reset)

** 000 - S L U

** 001 - L S U

** 010 - S U L

** 011 - L U S

** 100 - U S L

** 101 - U L S

** 110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7

** 111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]

* bit 1 = Enable Sprites Over border (0 on reset)

* bit 0 = Enable Sprites (0 on reset)

Register (R/W) $32 (32) => Layer 1,0 (LoRes) Horizontal Scroll Control)

* bits 7-0 = X Offset (0-255) ($00 on reset)

Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and
smoothness as Layer 2.

Register (R/W) $33 (33) => Layer 1,0 (LoRes) Vertical Scroll Control)

* bits 7-0 = Y Offset (0-191) ($00 on reset)

Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and
smoothness as Layer 2.

Register (R/W) $6A (6A) => Layer 1,0 (LoRes) Control

* bits 7-6 = reserved, must be 0

* bit 5 = Enable Radistan (16-colour) (0 on reset)

* bit 4 = Radistan DFILE switch (xor with bit 0 of port $ff) (0
on reset)

* bits 3-0 = Radistsan palette offset (0 on reset)

* bits 1-0 = ULAplus palette offset (0 on reset)

Code: 256 colour

;; enable LoRes mode:
nextreg $15,$80
;; 256-colour mode
ld bc,$243B ; next register select port
ld a,$6A
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
and $EF ; lores radistan control
out (c),a

Code: 16 colour

;; enable LoRes mode:
nextreg $15,$80
;; 16-colour mode
nextreg $6A,$10

@node NODE028


@{h1}Layer 2

Layer 2 is a for bitmapped graphics. It supports modes with
[<!-- MATH]

$256\times192\times256$
-->
img7.svg"
ALT="$256\times192\times256$"> resolution at global coordinates (32, 32) to
(287, 223) mapped linearly left to right/top to bottom,
[<!-- MATH]

$320\times256\times256$
-->
img8.svg"
ALT="$320\times256\times256$"> resolution at global coordinates (0, 0) to
(318, 255) mapped top to bottom/left to right, and
[<!-- MATH]

$640\times256\times16$
-->
img9.svg"
ALT="$640\times256\times16$"> resolution at global coordinates (0, 0) to
(319, 255) with half width pixels mapped so that the nybbles in a byte
are adjacent columns (MSN on the left) and bytes running top to
bottom/left to right. It can be mapped starting at any 16k memory
blocks. The <!-- MATH
$256\times192\times256$
-->
img7.svg"
ALT="$256\times192\times256$"> mode requires 3 consecutive blocks
(48k) while the others use 5 consecutive blocks (80k).


------------------------------------------
Subsections

@{ "Configuration" LINK NODE29 }

* 
@{ "Layer 2 <SPAN CLASS="MATH"><IMG STYLE="" SRC="img1.svg" ALT="$256\times 192$"></SPAN>, Write only overlaid on ROM" LINK NODE30 }

* 
@{ "Layer 2 <SPAN CLASS="MATH"><IMG STYLE="" SRC="img1.svg" ALT="$256\times 192$"></SPAN> resolution" LINK NODE31 }

* 
@{ "Layer 2 <SPAN CLASS="MATH"><IMG STYLE="" SRC="img2.svg" ALT="$320\times 256$"></SPAN> resolution" LINK NODE32 }

* 
@{ "Layer 2 <SPAN CLASS="MATH"><IMG STYLE="" SRC="img3.svg" ALT="$640\times 256$"></SPAN> resolution" LINK NODE33 }

@{ "Scrolling" LINK NODE34 }

@{ "Clipping" LINK NODE35 }


------------------------------------------
@node NODE029


@{h2}Configuration

Layer 2 is enabled using port $123B or register $69. The mode is
selected using register $70. How layer 2 memory is overlaid on main
memory is controled by port $123B and register $70. The location in
memory is controlled by register $12 with a shadow area pointed to by
register $13 for double buffering. Finally port $123B is used to
select either the main RAM area or the shadow RAM area for rendering
the layer.

Port $123B (123B) Layer 2

Bit 4 = 0
&nbsp;bits 7-6 = Video RAM bank select
&nbsp;00 = first 16k

&nbsp;01 = second 16k

&nbsp;10 = third 16k

&nbsp;11 = first 48k

&nbsp;bit 5 = Reserved, must be 0
&nbsp;bit 4 = 0
&nbsp;bit 3 = Shadow layer 2 select
&nbsp;bit 2 = Enable layer 2 read paging
&nbsp;bit 1 = Layer 2 visible (mirrored in register $69)
&nbsp;bit 0 = Enable layer 2 write paging

Bit 4 = 1
&nbsp;bits 7-5 = Reserved, must be 0
&nbsp;bit 4 = 1
&nbsp;bit 3 = Reserved, must be 0
&nbsp;bit 2-0 = 16k bank relative offset

Register (R/W) $12 (12) => Layer 2 Active RAM bank

* bits 7-6 = Reserved, must be 0

* bits 5-0 = RAM bank (point to bank 8 after a Reset, NextZXOS
modifies to 9)

Register (R/W) $13 (13) => Layer 2 Shadow RAM bank

* bits 7-6 = Reserved, must be 0

* bits 5-0 = RAM bank (point to bank 11 after a Reset, NextZXOS
modifies to 12)

Register (R/W) $69 (69) => Display Control 1

* bit 7 = Layer 2 Enable (Port $123B bit 1 alias)

* bit 6 = ULA Shadow display enable (Port $7FFD bit 3 alias)

* bits 5-0 = Timex alias (Port $FF alias)

Register (R/W) $70 (70) => Layer 2 Control

* bits 7-6 = Reserved, must be 0

* bits 5-4 = Resolution (00 on soft reset)

** 00 = <!-- MATH
$256\times192\times256$
-->
img7.svg"
ALT="$256\times192\times256$">

** 01 = <!-- MATH
$320\times256\times256$
-->
img8.svg"
ALT="$320\times256\times256$">

** 10 = <!-- MATH
$640\times256\times16$
-->
img9.svg"
ALT="$640\times256\times16$">

** 11 = Do not use

* bits 3-0 = Palette offset ($0 on soft reset)


------------------------------------------
Subsections

* 
@{ "Layer 2 <SPAN CLASS="MATH"><IMG STYLE="" SRC="img1.svg" ALT="$256\times 192$"></SPAN>, Write only overlaid on ROM" LINK NODE30 }

* 
@{ "Layer 2 <SPAN CLASS="MATH"><IMG STYLE="" SRC="img1.svg" ALT="$256\times 192$"></SPAN> resolution" LINK NODE31 }

* 
@{ "Layer 2 <SPAN CLASS="MATH"><IMG STYLE="" SRC="img2.svg" ALT="$320\times 256$"></SPAN> resolution" LINK NODE32 }

* 
@{ "Layer 2 <SPAN CLASS="MATH"><IMG STYLE="" SRC="img3.svg" ALT="$640\times 256$"></SPAN> resolution" LINK NODE33 }

@node NODE030


@{h4}Layer 2 img1.svg"
ALT="$256\times 192$">, Write only overlaid on ROM

p_layer2: defl $123b
start:
ld bc,p_layer2
ld a,$03       ; enable, wo, 1st 16k
out (c),a
call wrtpage
ld bc,p_layer2
ld a,$43       ; enable, wo, 2nd 16k
out (c),a
call wrtpage
ld bc,p_layer2
ld a,$83       ; enable, wo, 3rd 16k
out (c),a
call wrtpage
ret
wrtpage:  
ld hl,$0000
ld bc,$0040    ; 40*256 writes
loop:
ld (hl),b
inc hl
djnz loop
dec c
jr nz,loop


------------------------------------------
@node NODE031


@{h4}Layer 2 img1.svg"
ALT="$256\times 192$"> resolution

r_mmu_7:  defl $57
r_disp1:  defl $69
r_layer2: defl $70
start:
nextreg r_disp1,$80  ; enable layer 2
nextreg r_layer2,$00 ; 256x192x256
ld a,$12             ; page 18=bank 9
loop1:
nextreg r_mmu_7,a    ; map page into slot 7
ld bc,$0020          ; 20*256 = 8k
ld hl,$E000          ; address of slot 7
loop2:
ld (hl),b
inc hl
djnz loop2
dec c
jp NZ,loop2
inc a
cp $18               ; stop at page 24
jp NZ,loop1


------------------------------------------
@node NODE032


@{h4}Layer 2 img2.svg"
ALT="$320\times 256$"> resolution

r_mmu_7:  defl $57
r_disp1:  defl $69
r_layer2: defl $70
start:
nextreg r_disp1,$80  ; enable layer 2
nextreg r_layer2,$10 ; 320x256x256
ld a,$12             ; page 18=bank 9
loop1:
nextreg r_mmu_7,a    ; map page into slot 7
ld bc,$0020          ; 20*256 = 8k
ld hl,$E000          ; start of slot 7
loop2:
ld (hl),b
inc hl
djnz loop2
dec c
jp NZ,loop2
inc a
cp $1C               ; stop at page 28
jp NZ,loop1


------------------------------------------
@node NODE033


@{h4}Layer 2 img3.svg"
ALT="$640\times 256$"> resolution

r_mmu_7:  defl $57
r_disp1:  defl $69
r_layer2:  defl $70
start:
nextreg r_disp1, $80   ; enable layer 2
nextreg r_layer2, $20  ; 640x256x16
ld a, $12    ; page 18=bank 9
loop1:
nextreg r_mmu_7, a  ; map page into slot 7
ld bc, $0020    ; 20*256 = 8k
ld hl, $E000    ; start address for slot 7
loop2:
ld (hl), b
inc hl
djnz loop2
dec c
jp NZ, loop2
inc a
cp $1C      ; stop at page 28
jp NZ, loop1


------------------------------------------
@node NODE034


@{h2}Scrolling

Scrolling Layer 2 is controlled by registers $16 and $17. (Is there
a third scrolling register for layer 2?)

Register (R/W) $16 (16) => Layer 2 Horizontal Scroll Control

* bits 7-0 = X Offset (0-255)(0 on reset)

Register (R/W) $17 (17) => Layer 2 Vertical Scroll Control

* bits 7-0 = Y Offset (0-191)(0 on reset)


------------------------------------------
@node NODE035


@{h2}Clipping

The Clip area for is based on the local coordinate system for the mode
in question and is set using register $18 with the option of
selection which write in active using register $1C.

Register (R/W) $18 (18) => Layer 2 Clip Window Definition

* bits 7-0 = Coords of the clip window
&nbsp;1st write - X1 position

&nbsp;2nd write - X2 position

&nbsp;3rd write - Y1 position

&nbsp;4rd write - Y2 position

Reads do not advance the clip position

The values are 0,255,0,191 after a Reset

Register (R/W) $1C (1C) => Clip Window Control

Read

* bits 7-6 = Layer 3 Clip Index

* bits 5-4 = Layer 0/1 Clip Index

* bits 3-2 = Sprite clip index

* bits 1-0 = Layer 2 Clip Index

Write

* bits 7-4 = Reserved, must be 0

* bit 3 - reset Layer 3 clip index

* bit 2 - reset Layer 0/1 clip index

* bit 1 - reset sprite clip index.

* bit 0 - reset Layer 2 clip index.


------------------------------------------
@node NODE036


@{h1}Layer 3 (Tilemap) Mode

Started with documentation by Phoebus Dokos, February 25,
2019. Partially rewritten for clarity and to add core 3.00.00
features.


------------------------------------------
Subsections

@{ "General Description" LINK NODE37 }

@{ "Data Structures" LINK NODE38 }

* @{ "Tilemap" LINK NODE39 }

* @{ "Tile Definitions" LINK NODE40 }

@{ "Memory Organization &amp; Display Layer" LINK NODE41 }

@{ "Combining ULA &amp; Tilemap" LINK NODE42 }

@{ "Programming Tilemap mode" LINK NODE43 }

* @{ "Changes Since 2.00.26" LINK NODE44 }

* @{ "Future Direction" LINK NODE45 }


------------------------------------------
@node NODE037


@{h2}General Description

The tilemap is a hardware character oriented display. It uses a set of
user defined 4-bit, 16-colour, or 1-bit, 2-colour img14.svg"
ALT="$8\times8$">
tiles. The tiles can be dispplayed in two resolutions: img29.svg"
ALT="$40\times32$">
tiles (img2.svg"
ALT="$320\times 256$"> pixels) and img30.svg"
ALT="$80\times32$"> tiles (img3.svg"
ALT="$640\times 256$">
pixels).

The display area on screen is the same as the sprite layer, meaning it
overlaps the standard img1.svg"
ALT="$256\times 192$"> area by 32 pixels on all
sides. Vertically this is larger than the physical HDMI display, which
will cut off the top and bottom character rows making the visible area
img31.svg"
ALT="$40\times30$"> or img32.svg"
ALT="$80\times30$">, but the full area is visible on VGA.

The obvious application for the tilemap is for a fast, clearly
readable and wide multicoloured character display. Less obvious
perhaps is that it can also be used to make fast and wide resolution
full colour backgrounds with easily animated components such as have
historically been used in many games.

The tilemap is defined by two data structures and configured using
four NextRegs. The NextRegs are $6b (107), Tilemap Control; $6c
(108), Default Tilemap Attribute, $6c (110); Tilemap Base Address;
and $6d (111) Tile Definitions Base Address.


------------------------------------------
@node NODE038


@{h2}Data Structures


------------------------------------------
Subsections

* @{ "Tilemap" LINK NODE39 }

* @{ "Tile Definitions" LINK NODE40 }


------------------------------------------
@node NODE039


@{h4}Tilemap

The first data structure is the tilemap itself which indicates what
characters occupy each cell on screen. Each tilemap entry is either
one or two bytes.

If entries are two bytes each, the first byte for each entry is bits
0-7 of the tile number, while the second byte is an attribute byte
which is interpreted acctording to the mode set in the tilemap control
register ($6b). For img29.svg"
ALT="$40\times32$"> resolution, a full size tilemap will
occupy 2560 bytes, and for img30.svg"
ALT="$80\times32$"> resolution the space taken is
twice that at 5120 bytes. The tilemap entries are stored in X-major
order and each two-byte tilemap entry consists of a tile number byte
(bits 0-7 of the tile number) followed an attribute byte:

Tilemap Attribute Byte 4-bit
&nbsp;bits 7-4 : most significant 4-bits of palette entry
&nbsp;bit 3 : x mirror
&nbsp;bit 2 : y mirror
&nbsp;bit 1 : rotate
&nbsp;bit 0 : ULA over tilemap (in 512 tile mode, bit 8 of the tile
number)

Tilemap Attribute Byte 1-bit
&nbsp;bits 7-1 : most significan 7-bits of palette entry
&nbsp;bit 0 : ULA over tilemap (in 512 tile mode, bit 8 of the tile
number)

The character displayed is indicated by the “tile number” which can be
thought of as an ASCII code. The tile number is normally eight bits
allowing up to 256 unique tiles to be displayed but this can be
extended to nine bits for 512 unique tiles if 512 tile mode is enabled
via the Tilemap Control register ($6b).

The other bits are tile attributes that modify how the tile image is
drawn. Their function is the same as the equivalent sprite attributes
for sprites. Bits apply rotation then mirroring, and colour can be
shifted with a palette offset. If 512 tile mode is not enabled, bit 8
will determine if the tile is above or below the ULA display on a per
tile basis.

When using 1-byte tilemap entries, the map consists of the tile
numbers for tile in the map with the tilemap attribute byte for every
tile coming from the default tilemap attribute register ($6c).

@node NODE040


@{h4}Tile Definitions

The second data structure is the tile definitions themselves. To find
the difinition for a specific tile you would look at (base address) +
(tile number) * (definition size).

For 4-bit, 16-colour, tiles, each img14.svg"
ALT="$8\times8$"> tile takes up 32
bytes. Each pixel uses four bits to select one of 16 colours. A tile
is defined in X major order with packing in the X direction in the
same way that 4-bit sprites are defined. The 4-bit colour of each
pixel is augmented by the 4-bit palette offset from the tilemap in the
most significant bits to form an 8-bit colour index that is looked up
in the tilemap palette to determine the final 9-bit colour sent to the
display. Ane of the 16 colours for each tile is the transparency
color.

For 1-bit, 2-colour, tiles, each img14.svg"
ALT="$8\times8$"> tile takes up 8
bytes. Each pixel uses one bit to select one of two colours. A tile is
defined in X major order with packing in the X direction. The 1-bit
colour of each pixel is augmented by the 7-bit palette offset from the
tilemap in the most significant bits to form an 8-bit colour index
that is looked up in the tilemap palette to determine the final 9-bit
colour sent to the display. Transparency for each tile is according to
the global transparency colour.

@node NODE041


@{h2}Memory Organization &amp; Display Layer

The tilemap is a logical extension of the ULA and its data structures
are contained in 16k banks 5 and 7 (first half only). If both the ULA
and tilemap are enabled, this means that the tilemap's map and tile
definitions should be arranged within the 24k to avoid overlap with
the display ram used by the ULA.

The tilemap exists on the same display layer as the ULA. The graphics
generated by the ULA and tilemap are combined before being forwarded
to the SLU layer system as layer U.


------------------------------------------
@node NODE042


@{h2}Combining ULA &amp; Tilemap

The combination of the ULA and tilemap is done in one of two modes:
the standard mode or the stencil mode.

The standard mode uses bit 8 of a tile's tilemap entry to determine if
a tile is above or below the ULA. The source of the final pixel
generated is then the topmost non-transparent pixel. If the ULA or
tilemap is disabled then they are treated as transparent.

The stencil mode will only be applied if both the ULA and tilemap are
enabled. In the stencil mode, the final pixel will be transparent if
either the ULA or tilemap are transparent. Otherwise the final pixel
is a logical AND of the corresponding colour bits. The stencil mode
allows one layer to act as a cut-out for the other.


------------------------------------------
@node NODE043


@{h2}Programming Tilemap mode

Register (R/W) $6B (6B) => Layer 3 (Tilemap) Control

* bit 7 = Layer 3 Enable (0 on reset)

* bit 6 = Layer 3 Size control (0 on reset)

** 0 = 40x32

** 1 = 80x32

* bit 5 = Disable Arrtibute Entry (0 on reset)

* bit 4 = palette select (0 on reset)

* bit 3 = Enable Text mode (1-bit tilemap) (0 on reset)

* bit 2 = Reserved, must be 0

* bit 1 = Activate 512 tile mode (0 on reset)

* bit 0 = Enable Layer 3 on top of ULA (0 on reset)

Bits 7 &amp; 6 enable the tilemap and select resolution. Bit 4 selects one
of two tilemap palettes used for final colour lookup. Bit 5 changes
the structure of the tilemap so that it contains only 8-bit tilemap
entries instead of 16-bit tilemap entries. If 8-bit, the tilemap only
contains tile numbers and the attributes are instead taken from
nextreg $6C.

Bit 5 determines whether the attribute byte for each tile come from
the tilemap (0) or from the default tile attribute register (1).

Bit 4 selects either the primary tilemap palette (0) or the secondary
tilemap palette (1).

Bit 3 selects whether to use 4-bit, 16-colour, or 1-bit 2-colour
tiles.

Bit 1 activates 512 tile mode. In this mode, the “ULA over tilemap”
bit in a tile’s attribute is re-purposed as the ninth bit of the tile
number, allowing up to 512 unique tiles to be displayed. In this mode,
the ULA is always on top of the tilemap.

Bit 0 forces the tilemap to be on top of the ULA. It can be useful in
512 tile mode to change the relative display order of the ULA and
tilemap.

Register (R/W) $6C (6C) => Default Layer 3 Attribute*

* bits 7-4 = Palette Offset ($00 on reset)

* bit 3 = X mirror (0 on reset)

* bit 2 = Y mirror (0 on reset)

* bit 1 = Rotate (0 on reset)

* bit 0 = Bit 8 of the tile number (512 tile mode) (0 on reset)

* bit 0 = ULA over tilemap (256 tile mode) (0 on reset)

*Active tile attribute if bit 5 of nextreg $6B is set.

If bit 5 of nextreg $6B is set, the tilemap structure is modified to
contain only 8-bit tile numbers instead of the usual 16-bit tilemap
entries. In this case, the tile attributes used are taken from this
register instead.

Register (R/W) $6E (6E) => Layer 3 Tilemap Base Address

* bit 7 = Bank Select (3.01.08)
&nbsp;0 = Bank 5
&nbsp;1 = Bank 7

* bit 6 = Reserved, must be 0

* bits 5-0 = MSB of address of the tilemap in Bank 5 (16k) or 7 (8k)
($2C on reset)

Soft Reset default $2C - This is because the address is $6C00 so the
MSB is $6C. But the stored value is only the lower 6 bits so it's an
offset into the 16k Bank 5. To calculate therefore subtract $40
leaving you with $2C.

The value written is an offset into the 16k Bank 5 or the 8k lower
half of Bank 7 allowinf the tilemap to be placed at any multiple of
256 bytes.

This register determines the tilemapís base address in bank 5. The
base address is the MSB of an offset into the 16k bank, allowing the
tilemap to begin at any multiple of 256 bytes in the bank. Writing a
physical MSB address in $40-$7f or $c0-$ff, corresponding to
traditional ULA physical addresses, is permitted. The value read back
should be treated as a fully significant 8-bit value.

The tilemap will be img29.svg"
ALT="$40\times32$"> or img30.svg"
ALT="$80\times32$"> in size depending on
the resolution selected in nextreg $6B. Each entry in the tilemap is
normally two bytes but can be one byte if attributes are eliminated by
setting bit 5 of nextreg $6B.

Register (R/W) $6F (6F) => Layer 3 Tile Definitions Base Address

* bit 7 = Select bank (3.01.08)
&nbsp;0 = Bank 5
&nbsp;1 = Bank 7

* bit 6 = Reserved, must be 0

* bits 5-0 = MSB of address of the tile definitions in Bank 5 (16k) or 7
(8k) ($0C on reset)

Soft Reset default $0C - This is because the address is $4C00 so the
MSB is $4C. But the stored value is only the lower 6 bits so it's an
offset into the 16k Bank 5. To calculate therefore subtract $40
leaving you with $0C.

The value written is an offset into the 16k Bank 5 or the 8k lower
half of Bank 7 allowing the tilemap to be placed at any multiple of
256 bytes.

This register determines the base address of tile definitions in bank
5. As with nextreg $6E, the base address is the MSB of the an offset
into the 16k bank, allowing tile definitions to begin at any multiple
of 256 bytes in the bank. Writing a physical MSB address in $40-$7f
or $c0-$ff, corresponding to traditional ULA physical addresses, is
permitted. The value read back should be treated as a fully
significant 8-bit value.

Each tile definition is 32 bytes in size and is located at address:

Tile Def Base Addr + 32 * (Tile Number)

Register (R/W) $4C (4C) => Level 3 Transparency Index

* bits 7-4 = Reserved, must be 0

* bits 3-0 = Index value ($0F on reset)

Defines the transparent colour index for 4-bit tiles. The 4-bit pixels
of a tile definition are compared to this value to determine if they
are transparent. In the case of 1-bit tiles transparency is determined
by comparing the final pixel colour against the global transparency
colour.

For palette information see palette section.

Register (R/W) $1B (1B) => Layer 3 (Tilemap) Clip Window Definition

* bits 7-0 = Coord. of the clip window
&nbsp;1st write = X1 position

&nbsp;2nd write = X2 position

&nbsp;3rd write = Y1 position

&nbsp;4rd write = Y2 position

The values are 0,159,0,255 after a Reset

Reads do not advance the clip position

The X coords are internally doubled.

The tilemap display surface extends 32 pixels around the central
img1.svg"
ALT="$256\times 192$"> display. The origin of the clip window is the top left
corner of this area 32 pixels to the left and 32 pixels above the
central img1.svg"
ALT="$256\times 192$"> display. The X coordinates are internally
doubled to cover the full 320 pixel width of the surface. The clip
window indicates the portion of the tilemap display that is
non-transparent and its indicated extent is inclusive; it will extend
from X1*2 to X2*2+1 horizontally and from Y1 to Y2 vertically.

Register (R/W) $2F (2F) => Layer 3 (Tilemap) Horizontal Scroll Control MSB

* bits 7-2 = Reserved, must be 0

* bits 1-0 = X Offset MSB ($00 on reset)

Meaningful Range is 0-319 in 40 char mode, 0-639 in 80 char mode

Register (R/W) $30 (30) => Layer 3 (Tilemap) Horizontal Scroll Control LSB

* bits 7-0 = X Offset LSB ($00 on reset)

Meaningful range is 0-319 in 40 char mode, 0-639 in 80 char mode

Register (R/W) $31 (31) => Layer 3 (Tilemap) Vertical Scroll Control

* bits 7-0 = Y Offset (0-255) )$00 on reset)

Register (R/W) $68 (68) => ULA Control

bit 7 = Disable ULA output (0 on reset)
bit 6-5 = Color blending control for layering modes 6 &amp; 7 (3.01.01)

* 00 = ULA as blend colour

* 01 = No blending

* 10 = ULA/Tilemap mix result as blend colour

* 11 = Tilemap as blend colour

bit 4 = Cancel entries in 8x5 matrix for extended keys (3.01.04)
bit 3 = Enable ULAplus (0 on reset)
bit 2 = Enable ULA half pixel scroll (0 on reset)&nbsp;may change
bit 1 = Reserved (must be 0)
bit 0 = Enable stencil mode (0 on reset)
&nbsp;When ULA and Layer 3 are enabled, if either are transparent,
the result is transparent, otherwise the result is the logical AND
of both colours.

Bit 0 can be set to choose stencil mode for the combined output of the
ULA and tilemap. Bit 6 determines what colour is used in SLU modes 6 &amp;
7 where the ULA is combined with Layer 2 to generate highlighting
effects.


------------------------------------------
Subsections

* @{ "Changes Since 2.00.26" LINK NODE44 }

* @{ "Future Direction" LINK NODE45 }

@node NODE044


@{h4}Changes Since 2.00.26

512 Tile Mode. In 2.00.26, the 512 tile mode was automatically
selected when the ULA was disabled. With the ULA disabled, the
tilemap attribute bit “ULA on top” was re-purposed to be bit 8 of
the tile number. In 2.00.27, selection of the 512 tile mode is moved
to bit 1 of Tilemap Control nextreg $6B. This way 512 tile mode can
be independently chosen without disabling the ULA. The “ULA on top”
bit is still taken as bit 8 of the tile number and in the 512 mode,
the tilemap is always displayed underneath the ULA.

Tilemap Always On Top of ULA. In 2.00.27, bit 0 of Tilemap
Control nextreg $6B is used to indicate that the tilemap should
always be displayed on top of the ULA. This allows the tilemap to
display over the ULA when in 512 mode.

1-bit tilemaps. In 3.00.00, a number of modifications were made
to accomidate 1-bit tilemaps.


------------------------------------------
@node NODE045


@{h4}Future Direction

The following compatible changes may be applied at a later date:

Addition of a bit to Tilemap Control to select a reduced tilemap
area of size img15.svg"
ALT="$32\times24$"> or img25.svg"
ALT="$64\times24$"> that covers the ULA
screen.

Addition of a bit to Tilemap Control to select split addressing
where the tilemap’s tiles and attributes as well as the tile
definitions are split between the two 8k halves of the 16k ULA ram
in the same way that the two Timex display files are split. The
intention is to make it easier for the tilemap to co-exist with all
the display modes of the ULA.


------------------------------------------
@node NODE046


@{h1}Sprites

February 25, 2019  Victor Trucco

The Spectrum Next has a hardware sprite system with the following
characteristics:

* Total of 128 sprites

* Display surface is img2.svg"
ALT="$320\times 256$"> overlapping the ULA screen by
32 pixels on each side

* Minimum of 100 sprites per scanline*

* Choice of 512 colours for each pixel

* Site of each sprite is img33.svg"
ALT="$16\times16$"> pixels but sprites can be
magnified img34.svg"
ALT="$2\times$">, img35.svg"
ALT="$4\times$"> or img36.svg"
ALT="$8\times$"> horizontally and
vertically

* Sprites can be mirrored and rotated

* Sprites can be grouped together to form larger sprites under the
control of a single anchor

* A 16K pattern memory can contain 64 8-bit sprite images or 128
4-bit sprite images and combinations in-between

* A per sprite palette offset allows sprites to share images but
colour them differently

* A nextreg interface allows the copper to move sprites during the
video frame

*A minimum of 100 img33.svg"
ALT="$16\times16$"> sprites is guaranteed to be displayed
in any scanline. Any additional sprites will not be displayed with the
hardware ensuring sprites are not partially plotted.

The actual limit is determined by how many 28MHz clock cycles there
are in a scanline. The sprite hardware is able to plot one pixel cycle
and uses one cycle to qualify each sprite. Since the number of cycles
there are in a scanline varies with video timing (HDMI, VGA), the
number of pixels that can be plotted also varies but the minimum will
be 1600 pixels per line including overhead cycles needed to qualify
100 sprites. Since sprites magified horizontally involve plotting more
pixels, img34.svg"
ALT="$2\times$">, img35.svg"
ALT="$4\times$">, and img36.svg"
ALT="$8\times$"> sprites will take more
cycles to plot and the presence of these sprites in a line will reduce
the total number of sprites that can be plotted.


------------------------------------------
Subsections

@{ "Sprite Patterns" LINK NODE47 }

* @{ "Pattern Number" LINK NODE48 }

** @{ "8-Bit Sprite Patterns" LINK NODE49 }

** @{ "4-Bit Sprite Patterns" LINK NODE50 }

@{ "Sprite Palette" LINK NODE51 }

@{ "Sprite Attributes" LINK NODE52 }

@{ "Relative Sprites" LINK NODE53 }

@{ "Programming Sprites" LINK NODE54 }

@{ "Global Control of Sprites" LINK NODE55 }

@node NODE047


@{h2}Sprite Patterns

Sprite patterns are the images that each sprite can take on. The
images are stored in a 16K memory internal to the FPGA and are
identified by pattern number. A particular sprite chooses a pattern by
storing a pattern number in its attributes.

All sprites are img33.svg"
ALT="$16\times16$"> pixels in size but the come in two
flavours: 4-bit and 8-bit. The bit width describes how many bits are
used to code the colour of each pixel.

An 8-bit sprite uses a full byte to colour each of its pixels so that
each pixel can be one of 256 colours. In this case, a img33.svg"
ALT="$16\times16$">
sprite requires 256 bytes of pattern memory to store its image.

A 4-bit sprite uses a nibble to colour each of its pixels so that each
pixel can be one of 16 colours. In this case, a img33.svg"
ALT="$16\times16$"> sprite
requires just 128 bytes of pattern memory to store its image.

The 16K pattern memory can contain any combination of these images,
whether they are 128 bytes or 256 bytes and their locations in the
pattern memory are described by a pattern number. This pattern number
is 7 bits with bits named as follows:


------------------------------------------
Subsections

* @{ "Pattern Number" LINK NODE48 }

** @{ "8-Bit Sprite Patterns" LINK NODE49 }

** @{ "4-Bit Sprite Patterns" LINK NODE50 }

@node NODE048


@{h4}Pattern Number

N5 N4 N3 N2 N1 N0 N6

N6, despite the name, is the least significant bit.

This 7-bit pattern number can identify 128 patterns in the 16k pattern
memory, each of which are 128 bytes in size. The full 7-bits are
therefore used for 4-bit sprites.

For 8-bit sprites, N6=0 always. The remaining 6 bits can identify 64
patterns, each of which is 256 bytes in size.

The N5:N0,N6 bits are stored in a particular sprite’s attributes to
identify which image a sprite uses.


------------------------------------------
Subsections

@{ "8-Bit Sprite Patterns" LINK NODE49 }

@{ "4-Bit Sprite Patterns" LINK NODE50 }


------------------------------------------
@node NODE049


@{h5}8-Bit Sprite Patterns

The img33.svg"
ALT="$16\times16$"> pixel image uses 8-bits for each pixel so that each
pixel can be one of 256 colours. One colour indicates transparency and
this is programmed into the Sprite Transparency Index register
(nextreg $4B). By default the transparent value is $E3.

As an example of an 8-bit sprite, let’s have a look at figure 1.1.

Using the default palette, which is initialised with RGB332 colours
from 0-255, the hexadecimal values for this pattern arranged in a
img33.svg"
ALT="$16\times16$"> array are shown below:

04040404040404E3E3E3E3E3E3E3E3E3
04FFFFFFFFFF04E3E3E3E3E3E3E3E3E3
04FFFBFBFBFF04E3E3E3E3E3E3E3E3E3
04FFFBF5F5FBFF04E3E3E3E3E3E3E3E3
04FFFBF5A8A8FBFF04E3E3E3E3E3E3E3
04FFFFFBA844A8FBFF04E3E3E3E3E3E3
040404FFFBA844A8FBFF04E3E3E3E3E3
E3E3E304FFFBA84444FBFF04E304E3E3
E3E3E3E304FFFB444444FBFF044D04E3
E3E3E3E3E304FFFB44444444FA4D04E3
E3E3E3E3E3E304FFFB44FFF54404E3E3
E3E3E3E3E3E3E304FF44F5A804E3E3E3
E3E3E3E3E3E3E3E304FA4404A804E3E3
E3E3E3E3E3E3E3044D4D04E304F504E3
E3E3E3E3E3E3E3E30404E3E3E304FA04
E3E3E3E3E3E3E3E3E3E3E3E3E3E30404

Here $E3 is used as the transparent index.

These 256 bytes would be stored in pattern memory in left to right,
top to bottom order.


------------------------------------------
@node NODE050


@{h5}4-Bit Sprite Patterns

The img33.svg"
ALT="$16\times16$"> pixel image uses 4-bits for each pixel so that each
pixel can be one of 16 colours. One colour indicates transparency and
this is programmed into the lower 4-bits of the Sprite Transparency
Index register (nextreg $4B). By default the transparency value is
$3. Note that the same register is shared with 8-bit patterns to
identify the transparent index.

Since each pixel only occupies 4-bits, two pixels are stored in each
byte. The leftmost pixel is stored in the upper 4-bits and the
rightmost pixel is stored in the lower 4-bits.

As an example we will use the same sprite image as was given in the
8-bit pattern example. Here only the lower 4 bits of each pixel is
retained to confine each pixel’s color to 4-bits:

4444444333333333
4FFFFF4333333333
4FBBBF4333333333
4FB55BF433333333
4FB588BF43333333
4FFB848BF4333333
444FB848BF433333
3334FB844BF43433
33334FB444BF4D43
333334FB4444AD43
3333334FB4F54433
33333334F4584333
333333334A448433
33333334DD434543
33333333443334A4
3333333333333344

$3 is used as the transparent index.

These 128 bytes would be stored in pattern memory in left to right,
top to bottom order.

The actual colour that will appear on screen will depend on the
palette, described below. The default palette will not likely generate
suitable colours for 4-bit sprites.


------------------------------------------
@node NODE051


@{h2}Sprite Palette

Each pixel of a sprite image is 8-bit for 8-bit patterns or 4-bit for
4-bit patterns. The pixel value is known as a pixel colour index. This
colour index is combined with the sprite’s palette offset. The palette
offset is a 4-bit value added to the top 4-bits of the pixel colour
index. The purpose of the palette offset is to allow a sprite to
change the colour of an image.

The final sprite colour index generated by the sprite hardware is then
the sum of the pixel index and the 4-bit palette offset. In pictures
using binary math:

8-bit Sprite
PPPP0000
+ IIIIIIII
----------
SSSSSSSS

4-bit Sprite
PPPP0000
+ 0000IIII
----------
SSSSSSSS = PPPPIIII

Where “PPPP” is the 4-bit palette offset from the sprite’s attributes
and the “I”s represent the pixel value from the sprite pattern. The
final sprite index is represented by the 8-bit value “SSSSSSSS”.

For 4-bit sprites the palette offset can be thought of as selecting
one of 16 different 16-colour palettes.

This final 8-bit sprite index is then passed through the sprite
palette which acts like a lookup table that returns the 9-bit RGB333
colour associated with the sprite index.

At power up, the sprite palette is initialized such that the sprite
index passes through unchanged and is therefore interpretted as an
RGB332 colour. The missing third blue bit is generated as the logical
OR of the two other blue bits. In short, for 8-bit sprites, the sprite
index also acts like the colour when using the default palette.

@node NODE052


@{h2}Sprite Attributes

A sprite’s attributes is a list of properties that determine how and
where the sprite is drawn.

Each sprite is described by either 4 or 5 attribute bytes listed
below:

Sprite Attribute 0

X X X X X X X X

The least significant eight bits of the sprite’s X coordinate. The
ninth bit is found in sprite attribute 2.

Sprite Attribute 1

Y Y Y Y Y Y Y Y

The least significant eight bits of the sprite’s Y coordinate. The
ninth bit is optional and is found in attribute 4.

Sprite Attribute 2

P P P P XM YM R X8/PR

P = 4-bit Palette Offset

XM = 1 to mirror the sprite image horizontally

YM = 1 to mirror the sprite image vertically

R = 1 to rotate the sprite image 90 degrees clockwise

X8 = Ninth bit of the sprite’s X coordinate

PR = 1 to indicate P is relative to the anchor’s palette offset
(relative sprites only)

Rotation is applied before mirroring.

Relative sprites, described below, replace X8 with PR.

Sprite Attribute 3

V E N5 N4 N3 N2 N1 N0

V = 1 to make the sprite visible

E = 1 to enable attribute byte 4

N = Sprite pattern to use 0-63

If E=0, the sprite is fully described by sprite attributes 0-3. The
sprite pattern is an 8-bit one identified by pattern N=0-63. The
sprite is an anchor and cannot be made relative. The sprite is
displayed as if sprite attribute 4 is zero.

If E=1, the sprite is further described by sprite attribute 4.

Sprite Attribute 4

A.
Extended Anchor Sprite

H N6 T X X Y Y Y8

H = 1 if the sprite pattern is 4-bit

N6 = 7th pattern bit if the sprite pattern is 4-bit

T = 0 if relative sprites are composite type else 1 for unified type

XX = Magnification in the X direction (00 = img37.svg"
ALT="$1\times$">, 01 = img34.svg"
ALT="$2\times$">,
10 = img38.svg"
ALT="$4\times4$">, 11 = img36.svg"
ALT="$8\times$">)

YY = Magnification in the Y direction (00 = img37.svg"
ALT="$1\times$">, 01 = img34.svg"
ALT="$2\times$">,
10 = img35.svg"
ALT="$4\times$">, 11 = img36.svg"
ALT="$8\times$">)

Y8 = Ninth bit of the sprite’s Y coordinate

H,N6 must not equal 0,1 as this combination is used to indicate a
relative sprite.

B.
Relative Sprite, Composite Type

0 1 N6 X X Y Y PO

N6 = 7th pattern bit if the sprite pattern is 4-bit

XX = Magnification in the X direction (00 = img37.svg"
ALT="$1\times$">, 01 = img34.svg"
ALT="$2\times$">,
10 = img35.svg"
ALT="$4\times$">, 11 = img36.svg"
ALT="$8\times$">)

YY = Magnification in the Y direction (00 = img37.svg"
ALT="$1\times$">, 01 = img34.svg"
ALT="$2\times$">,
10 = img35.svg"
ALT="$4\times$">, 11 = img36.svg"
ALT="$8\times$">)

PO = 1 to indicate the sprite pattern number is relative to the
anchor’s

C.
Relative Sprite, Unified Type

0 1 N6 0 0 0 0 PO

N6 = 7th pattern bit if the sprite pattern is 4-bit

PO = 1 to indicate the sprite pattern number is relative to the
anchor’s

The display surface for sprites is img2.svg"
ALT="$320\times 256$">. The X coordinate of
the sprite is nine bits, ranging over 0-511, and the Y coordinate is
optionally nine bits again ranging over 0-511 or is eight bits ranging
over 0-255. The full extent 0-511 wraps on both axes, meaning a sprite
16 pixels wide plotted at X coordinate 511 would see its first pixel
not displayed (coordinate 511) and the following pixels displayed in
coordinates 0-14.

The full display area is visible in VGA. However, the HDMI display is
vertically shorter so the top eight pixel rows (Y = 0-7) and the
bottom eight pixel rows (Y = 248-255) will not be visible on an HDMI
display.

Sprites can be fully described by sprite attributes 0-3 if the E bit
in sprite attribute 3 is zero. These sprites are compatible with the
original sprite module from core versions prior to 2.00.26.

If the E bit is set then a fifth sprite attribute, sprite attribute 4,
becomes active. This attribute introduces scaling, 4-bit patterns, and
relative sprites. Scaling is self-explanatory and 4-bit patterns were
described in the last section. Relative sprites are described in the
next section.

@node NODE053


@{h2}Relative Sprites

Normal sprites (sprites that are not relative) are known as anchor
sprites. As the sprite module draws sprites in the order 0-127 (there
are 128 sprites), it internally stores characteristics of the last
anchor sprite seen. If following sprites are relative, they inherit
some of these characteristics, which allows relative sprites to have,
among other things, coordinates relative to the anchor. This means
moving the anchor sprite also causes its relatives to move with it.

There are two types of relative sprites supported known as “Composite
Sprites” and “Unified Sprites”. The type is determined by the anchor
in the T bit of sprite attribute 4.

A.
Composite Sprites

The sprite module records the following information from the anchor:

* Anchor.visible

* Anchor.Y

* Anchor.palette_offset

* Anchor.N (pattern number)

* Anchor.H (indicates if the sprite uses 4-bit patterns)

These recorded items are not used by composite sprites:

* Anchor.rotate

* Anchor.xmirror

* Anchor.ymirror

* Anchor.xscale

* Anchor.yscale

The anchor determines if all its relative sprites use 4-bit patterns or not.

The visibility of a particular relative sprite is the result of
ANDing the anchor’s visibility with the relative sprite’s
visibility. In other words, if the anchor is invisible then so are
all its relatives.

Relative sprites only have 8-bit X and Y coordinates (the ninth bits
are taken for other purposes). These are signed offsets from the
anchor’s X,Y coordinate. Moving the anchor moves all its relatives
along with it.

If the relative sprite has its PR bit set in sprite attribute 2,
then the anchor’s palette offset is added to the relative sprite’s
to determine the active palette offset for the relative
sprite. Otherwise the relative sprite uses its own palette offset as
usual.

If the relative sprite has its PO bit set in sprite attribute 4,
then the anchor’s pattern number is added to the relative sprite’s
to determine the pattern used for display. Otherwise the relative
sprite uses its own pattern number as usual. The intention is to
supply a method to easily animate a large sprite by manipulating the
pattern number in the anchor.

A composite sprite is like a collection of independent sprites tied
to an anchor.

B.
Unified Sprites

Unified sprites are a further extension of the
composite type. The same information is recorded from the anchor and
the same behaviour as described under composite sprites applies.

The difference is the collection of anchor and relatives is treated
as if it were a single img33.svg"
ALT="$16\times16$"> sprite. The anchor’s rotation,
mirror, and scaling bits apply to all its relatives. Rotating the
anchor causes all the relatives to rotate around the
anchor. Mirroring the anchor causes the relatives to mirror around
the anchor. The sprite hardware will automatically adjust X,Y coords
and rotation, scaling and mirror bits of all relatives according to
settings in the anchor.

Unified sprites should be defined as if all its parts are
img33.svg"
ALT="$16\times16$"> in size with the anchor controlling the look of the
whole.

A unified sprite is like a big version of an individual img33.svg"
ALT="$16\times16$">
sprite controlled by the anchor.

@node NODE054


@{h2}Programming Sprites

Sprites are created via three io registers and a nextreg interface.

Port $303B (303B) Sprite Slot/Flags

Write: Sprite Slot Select

select sprite slot for Sprite Attribute and Sprite Pattern ports which
independently auto-increment

Read: Sprite status
&nbsp;bits 7-2 = reserved
&nbsp;bit 1 = Max sprites per line
&nbsp;bit 0 = Collision flag

X S S S S S S S
N6 X N N N N N N

A write to this port has two effects.

One is it selects one of 128 sprites for writing sprite attributes via
port $57.

The other is it selects one of 128 4-bit patterns in pattern memory
for writing sprite patterns via port $5B. The N6 bit shown is the
least significant in the 7-bit pattern number and should always be
zero when selecting one of 64 8-bit patterns indicated by N.

Port $57 (57) Sprite Attributes

Byte 1
&nbsp;bits 7-0 = LSB of X coordinate (bit 8 is in byte 3)

Byte 2
&nbsp;bits 7-0 = LSB of Y coordinate (bit 8 is in byte 5)

Byte 3
&nbsp;bits 7-4 = Palette Offset
&nbsp;bit 3 = Enable X Mirror
&nbsp;bit 2 = Enable Y Mirror
&nbsp;bit 1 = Enable Roration
&nbsp;bit 0 = By Sprite Type
&nbsp;Anchor = MSB of X coordinate

&nbsp;Relative = Enable relative palette offset

Byte 4
&nbsp;bit 7 = Enable visibility
&nbsp;bit 6 = Enable Byte 5
&nbsp;bit 5-0 = Pattern Index (&ldquo;name&rdquo;)

Byte 5 (optional)

Anchor
&nbsp;bit 7-6 = type and pattern
&nbsp;00 = 8-bit color

&nbsp;01 = relative

&nbsp;10 = 4-bit color, lower half of pattern (bytes 0-127)

&nbsp;11 = 4-bit color, upper half of pattern (byets 128-255)

&nbsp;bit 5 = Attached relative sprite type
&nbsp;0 = composite

&nbsp;1 = big sprite

&nbsp;bit 4-3 = X-axis scale factor
&nbsp;00 = img37.svg"
ALT="$1\times$">

&nbsp;01 = img34.svg"
ALT="$2\times$"> 

&nbsp;10 = img35.svg"
ALT="$4\times$"> 

&nbsp;11 = img36.svg"
ALT="$8\times$">

&nbsp;bit 2-1 = Y-axis scale factor
&nbsp;bit 0 = MSB of Y coordinate

Composite Relative
&nbsp;bits 7-6 = 01
&nbsp;bit 5 = N6

8-bit
&nbsp;Reserved, must be 0

4-bit
&nbsp;0 = lower half of pattern (bytes 0-127)

&nbsp;1 = upper half of pattern (bytes 128-255)

&nbsp;bit 4-3 = X-axis scale factor
&nbsp;bit 2-1 = Y-axis scale factor
&nbsp;bit 0 = Enable relative pattern offset

Big-sprite Relative
&nbsp;bits 7-6 = 01
&nbsp;bit 5 = N6

8-bit
&nbsp;Reserved, must be 0

4-bit
&nbsp;0 = lower half of pattern (bytes 0-127)

&nbsp;1 = upper half of pattern (bytes 128-255)

&nbsp;bit 4-1 = Reserved, must be 0
&nbsp;bit 0 = Enable relative pattern offset

Once a sprite is selected via port $303B, its attributes can be
written to this port one byte after another. Sprites can have either
four or five attribute bytes and the internal attribute pointer will
move onto the next sprite after those four or five attribute bytes are
written. This means you can select a sprite via port $303B and write
attributes for as many sequential sprites as desired. The attribute
pointer will roll over from sprite 127 to sprite 0.

Port $5B (5B) Sprite Pattern

Load data into sprite pattern memory auto-incrementing. Port $303B
can be used to set the starting sprite pattern number.

Once a pattern number is selected via port $303B, the 256-byte or
128-byte pattern can be written to this port. The internal pattern
pointer auto-increments after each write so as many sequential
patterns as desired can be written. The internal pattern pointer will
roll over from pattern 127 to pattern 0 (4-bit patterns) or from
pattern 63 to pattern 0 (8-bit patterns) automatically.

Port $303B (R)

0 0 0 0 0 0 M C

M = 1 if the maximum number of sprites per line was exceeded

C = 1 if any two displayed sprites collide on screen

Reading this port automatically resets the M and C bits.

Besides the i/o interface, there is a nextreg interface to sprite
attributes. The nextreg interface allows the copper to manipulate
sprites and grants the program random access to a sprite’s individual
attribute bytes.

Register (R/W) $34 (34) => Sprite Number

Lockstep (NextReg $09 bit 4 set)

bit 7 = Pattern address offset (Add 128 to pattern address)
bits 6-0 = Sprite number 0-127, Pattern number 0-63&nbsp;effectively performs an out to port $303B

No Lockstep (NextReg $09 bit 4 clear)

* bit 7 = Reserved, must be 0

* bits 6-0 = Sprite number 0-127

This register selects which sprite has its attributes connected to the
sprite attribute registers

Register (W) $35 (35) => Sprite Attribute 0

* bits 7-0 = Sprite X coordinate LSB (MSB in NextReg $37)

Register (W) $75 (75) => Sprite Attribute 0 (Auto-incrementing)

See nextreg $35

Register (W) $36 (36) => Sprite Attribute 1

* bits 7-0 = Sprite Y coordinate LSB (MSB in NextReg $39)

Register (W) $76 (76) => Sprite Attribute 1 (Auto-incrementing)

See nextreg $36

Register (W) $37 (37) => Sprite Attribute 2

* bits 7-4 = 4-bit Palette offset

* bit 3 = Enable horizontal mirror (reverse)

* bit 2 = Enable vertical mirror (reverse)

* bit 1 = Enable 90img39.svg"
ALT="$^O$"> Clockwise Rotation

Normal Sprites

* bit 0 = X coordinate MSB

Relative Sprites

* bit 0 = Palette offset is relative to anchor sprite

Rotation is applied before mirroring

Register (W) $77 (77) => Sprite Attribute 2 (Auto-incrementing)

See nextreg $37

Register (W) $38 (38) => Sprite Attribute 3

* bit 7 = Enable Visiblity

* bit 6 = Enable Attribute 4 (0 = Attribute 4 effectively $00)

* bits 5-0 = Sprite Pattern Number

Register (W) $78 (78) => Sprite Attribute 3 (Auto-incrementing)

See nextreg $38

Register (W) $39 (39) => Sprite Attribute 4

Normal Sprites

* bit 7 = 4-bit pattern switch (0 = 8-bit sprite, 1 = 4-bit sprite)

* bit 6 = Pattern number bit-7 for 4-bit, 0 for 8-bit

* bit 5 = Type of attached relative sprites (0 = Composite, 1 =
Unified)

* bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)

* bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)

* bit 0 = MSB of Y coordinate

Relative, Composite Sprites

* bit 7-6 = 01

* bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit

* bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)

* bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)

* bit 0 = Pattern number is relative to anchor

Relative, Unified Sprites

* bit 7-6 = 01

* bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit

* bits 4-1 = 0000

* bit 0 = Pattern number is relative to anchor

Register (W) $79 (79) => Sprite Attribute 4 (Auto-incrementing)

See nextreg $39

@node NODE055


@{h2}Global Control of Sprites

The following nextreg are also of interest for sprites.

Register (R/W) $09 (09) => Peripheral 4 setting:

bit 7 = PSG 2 Mono Enable (0 on hard reset)
bit 6 = PSG 1 Mono Enable (0 on hard reset)
bit 5 = PSG 0 Mono Enable (0 on hard reset)
bit 4 = Sprite ID lockstep enable (1 = Nextreg $34 and IO Port
$303B are in lockstep, 0 on reset)
bit 3 = divMMC mapRAM bit Control (reset bit 7 of port $E3)
bit 2 = HDMI audio mute (0 on hard reset)
bits 1-0 = scanlines

* 00 = scanlines off

* 01 = scanlines 12.5%

* 10 = scanlines 25%

* 11 = scanlines 50%

&nbsp;In Sprite lockstep, NextREG $34 and Port $303B are in
lockstep

Register (R/W) $15 (15) => Sprite and Layer System Setup

* bit 7 = LoRes mode (0 on reset)

* bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on
top) (0 on reset)

* bit 5 = Enable sprite clipping in over border mode (0 on reset)

* bits 4-2 = set layers priorities (000 on reset)

** 000 - S L U

** 001 - L S U

** 010 - S U L

** 011 - L U S

** 100 - U S L

** 101 - U L S

** 110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7

** 111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]

* bit 1 = Enable Sprites Over border (0 on reset)

* bit 0 = Enable Sprites (0 on reset)

The sprite module draws sprites in the order 0-127 in each
scanline. Bit 6 determines whether sprite 0 is topmost or sprite 127
is topmost.

Bits 4:2 determine layer priority and how sprites overlay or are
obscured by other layers.

Register (R/W) $19 (19) => Sprite Clip Window Definition

* bits 7-0 = Cood. of the clip window
&nbsp;1st write - X1 position

&nbsp;2nd write - X2 position

&nbsp;3rd write - Y1 position

&nbsp;4rd write - Y2 position

The values are 0,255,0,191 after a Reset

Reads do not advance the clip position

When the clip window is enabled for sprites in "over border" mode, the
X coords are internally doubled and the clip window origin is moved to
the sprite origin inside the border.

When the clip window is enabled for sprites in “over border” mode, the
X coords are internally doubled and the clip window origin is moved to
the sprite origin inside the border.

Sprites will only be visible inside the clipping window. When not in
over-border mode (bit 1 of nextreg $15) the clipping window is given
in ULA screen coordinates with 0,0 correspoding to the top left corner
of the ULA screen. In over-border mode, the clipping window’s origin
is moved to the sprite coordinate origin 32 pixels to the left and 32
pixels above the ULA screen origin.

Regardless, sprite position is always in sprite coordinates with 32,32
corresponding to the top left corner of the ULA screen.

Register (R/W) $1C (1C) => Clip Window Control

Read

* bits 7-6 = Layer 3 Clip Index

* bits 5-4 = Layer 0/1 Clip Index

* bits 3-2 = Sprite clip index

* bits 1-0 = Layer 2 Clip Index

Write

* bits 7-4 = Reserved, must be 0

* bit 3 - reset Layer 3 clip index

* bit 2 - reset Layer 0/1 clip index

* bit 1 - reset sprite clip index.

* bit 0 - reset Layer 2 clip index.

Register (R/W) $4B (4B) => Sprite Transparency Index

* bits 7-0 = Index value ($E3 if reset)

For 4-bit sprites only the bottom 4-bits are relevant.

@node NODE056


@{h1}Audio


------------------------------------------
Subsections

@{ "ZX Spectrum 1-bit" LINK NODE57 }

@{ "Sampled 8-bit" LINK NODE58 }

@{ "Turbosound" LINK NODE59 }

* @{ "Pi Audio" LINK NODE60 }


------------------------------------------
@node NODE057


@{h1}ZX Spectrum 1-bit

The baseline sound of the ZX Spectrum was produced by toggling the Ear
bit (bit 4) of $fe (254) The ULA port to produce 1-bit audio.  It is
enabled by bit 4 of Next register $08 (8).  While this does work on
the ZX Spectrum Next, there are other much better methods and this is
only supported for backward compatibility.

Code:

;; enable internal speaker
ld bc,$243B
ld a,$08
out (c),a
ld bc,$253B
in a,(c)
or $10
out (c),a


------------------------------------------
@node NODE058


@{h1}Sampled 8-bit

The ZX Next has four 8-bit D/A audio channels connected to provide
sampled stereo sound. Channels A and B are the left channels, while C
and D are the right channels. In order use 8-bit sound, it must first
be enabled by setting bit 3 on nextreg $08. In order to emulate
legacy hardware there are a number of ports that can be used to
control the four channels additionally these are mirrored to three
nextregs to enable driving audio using the copper.  Channel A is
mapped to ports $0f, $3f, and $f1; channel B to ports $1f and $f3
and nextreg $2C; channel C to ports $4f, and $f9 and nextreg $2E;
and channel D to: $5f and $fb; with port $df connected to both
channel A and C and nextreg $2D connected to both channel A and D.

Code:

;; enable SpecDrum/Convox audio
ld bc,$243B
ld a,$08
out (c),a
ld bc,$253B
in a,(c)
or $08
out (c),a


------------------------------------------
@node NODE059


@{h1}Turbosound

TurboSound consists of the implementation of three AY-3-8912 chips. To
enable TurboSound set bit 1 of Next Register $08 (8). Once enabled
the sound chips and registers of the sound chips are selected using
port $fffd (65533) TurboSound Next Control while the registers are
accessed using $bffd () Sound Chip Register Access.  To enable access
to a particular chip write 111111xx to the control register where
01=AY1, 10=AY2, and 11=AY3.  Access to particular registers of the
selected chip is selected by writing the register number to the
control register. You can then access a chip register using the access
port.

Code:

;; enable TurboSound audio
ld bc,$243B
ld a,$08
out (c),a
ld bc,$253B
in a,(c)
or $02
out (c),a

Each of the three AY chips has three channels, A, B, and C whose
mapping is controlled by bit 5 of Next register 0x08 (8).

Register (R/W) $00 (00) => Channel A fine tune
Register (R/W) $01 (01) => Channel A coarse tune (4 bits)

Register (R/W) $02 (02) => Channel B fine tune

Register (R/W) $03 (03) => Channel B coarse tune (4 bits)

Register (R/W) $04 (04) => Channel C fine tune

Register (R/W) $05 (05) => Channel C coarse tune (4 bits)

Register (R/W) $06 (06) => Noise period (5 bits)

Register (R/W) $07 (07) => Tone Enable

* bit 5 = Channel C tone enable (0=enable, 1=disable)

* bit 4 = Channel B tone enable (0=enable, 1=disable)

* bit 3 = Channel A tone enable (0=enable, 1=disable)

* bit 2 = Channel C noise enable (0=enable, 1=disable)

* bit 1 = Channel B noise enable (0=enable, 1=disable)

* bit 0 = Channel A noise enable (0=enable, 1=disable)

Register (R/W) $08 (08) => Channel A amplitude

* bit 4 = enable fixed amplitude

** 0 = fixed amplitude

** 1 = use envelope generator (bits 0-3 ignored)

* bits 3-0 = value of fixed amplitude

Register (R/W) $09 (09) => Channel B amplitude

* bit 4 = enable fixed amplitude

** 0 = fixed amplitude

** 1 = use envelope generator (bits 0-3 ignored)

* bits 3-0 = value of fixed amplitude

Register (R/W) $0A (0A) => Channel C amplitude

* bit 4 = enable fixed amplitude

** 0 = fixed amplitude

** 1 = use envelope generator (bits 0-3 ignored)

* bits 3-0 = value of fixed amplitude

Register (R/W) $0B (0B) => Envelope period fine

Register (R/W) $0C (0C) => Envelope period coarse

Register (R/W) $0D (0D) => Envelope shape

* bit 3 = Continue

** 0 = drop to amplitude 0 after 1 cycle

** 1 = use ‘Hold’ value

* bit 2 = Attack

** 0 = generator counts down

** 1 = generator counts up

* bit 1 = Alternate

hold = 0

** 0 = generator resets after each cycle

** 1=generator reverses direction each cycle

hold=1

** 0 = hold final value

** 1 = hold initial value

* bit 0 = Hold

** 0 = cycle continuously

** 1 = perform one cycle and hold


------------------------------------------
Subsections

@{ "Pi Audio" LINK NODE60 }

@node NODE060


@{h2}Pi Audio

If connected the Pi Zero is configured to use the ZX Next as a
soundcard over an  I2S interface making the Raspberry Pi a fully
configurable audio source for the ZX Spectrum Next.


------------------------------------------
@node NODE061


@{h1}Memory

The ZX Spectrum Next commonly has with either 1MB or 2MB SRAM
memory. This is more the 64kB directly addressable by its Z80N CPU. It
is therefore necessary to use some form of memory paging to address
all of the memory. This is accomplished using 8k pages or 16k
banks. 256k of the total memory is used by the ROM images and device
specific RAM leaving either 768k (pages 0-95/banks 0-47) or 1792k
(pages 0-223/banks 0-111) that can be paged in as RAM. Pages 10, 11,
and 14 are a little odd in that rather than coming from the normal
SRAM, they come from BRAM internal to the FPGA.


------------------------------------------
Subsections

@{ "Memory Management" LINK NODE62 }

* @{ "Default Layout" LINK NODE63 }

* @{ "RAM" LINK NODE64 }

** @{ "ZX Spectrum Next Native" LINK NODE65 }

** @{ "ZX Spectrum 128" LINK NODE66 }

* @{ "ROM" LINK NODE70 }

** @{ "ZX Next native" LINK NODE71 }

** @{ "ZX Spectrum 128k" LINK NODE72 }

** @{ "divMMC" LINK NODE74 }

** @{ "Multiface" LINK NODE75 }

@{ "Interactions between paging methods" LINK NODE76 }

@{ "Memory Map" LINK NODE77 }

* @{ "Global Memory Map" LINK NODE78 }

* @{ "Z80 Visible Memory Map" LINK NODE79 }


------------------------------------------
@node NODE062


@{h1}Memory Management

There are a number of different systems for controling memory papping
into the 64k memory space of the Z80N CPU in the ZX Next: ZX Next
native memory paging, ZX Spectrum 128, ZX Spectrum +3, divMMC, and
Multiface.


------------------------------------------
Subsections

@{ "Default Layout" LINK NODE63 }

@{ "RAM" LINK NODE64 }

* @{ "ZX Spectrum Next Native" LINK NODE65 }

* @{ "ZX Spectrum 128" LINK NODE66 }

** @{ "Spectrum 128 Standard Paging" LINK NODE67 }

** @{ "Paging out ROM" LINK NODE68 }

** @{ "Spectrum 128 Special Paging" LINK NODE69 }

@{ "ROM" LINK NODE70 }

* @{ "ZX Next native" LINK NODE71 }

* @{ "ZX Spectrum 128k" LINK NODE72 }

** @{ "ROM paging and selection" LINK NODE73 }

* @{ "divMMC" LINK NODE74 }

* @{ "Multiface" LINK NODE75 }


------------------------------------------
@node NODE063


@{h2}Default Layout

The default mapping of memory banks is the same as on 128k Spectrum
models with a ROM0 (128k editor and menu system) mapped in at
$0000-$3FFF, bank 5 at $4000-$7FFF, bank 2 at $8000-$BFFF, and
bank 0 at $C000-$FFFF.


------------------------------------------
@node NODE064


@{h2}RAM


------------------------------------------
Subsections

* @{ "ZX Spectrum Next Native" LINK NODE65 }

* @{ "ZX Spectrum 128" LINK NODE66 }

** @{ "Spectrum 128 Standard Paging" LINK NODE67 }

** @{ "Paging out ROM" LINK NODE68 }

** @{ "Spectrum 128 Special Paging" LINK NODE69 }


------------------------------------------
@node NODE065


@{h4}ZX Spectrum Next Native

Registers $50 to $57 control the which SRAM pages are in each of the
eight memory slots.  Registers $50 and $51 support the special value
$FF which indicates that the currently selected ROM is to be mapped
into slots 0 and/or 1 ($0000-$3FFF).

Register (R/W) $50 (50) => MMU Slot 0 Control

* bits 7-0 = 8k RAM page at position $0000 to $1FFF ($ff on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

A 255 value causes the ROM to become visible.
Register (R/W) $51 (51) => MMU Slot 1 Control

* bits 7-0 = 8k RAM page at position $2000 to $3FFF ($ff on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

A 255 value causes the ROM to become visible.

Register (R/W) $52 (52) => MMU Slot 2 Control

* bits 7-0 = 8k RAM page at position $4000 to $5FFF ($0A on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

Register (R/W) $53 (53) => MMU Slot 3 Control

* bits 7-0 = 8k RAM page at position $6000 to $7FFF ($0B on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

Register (R/W) $54 (54) => MMU Slot 4 Control

* bits 7-0 = 8k RAM page at position $8000 to $9FFF ($04 on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

Register (R/W) $55 (55) => MMU Slot 5 Control

* bits 7-0 = 8k RAM page at position $A000 to $BFFF ($05 on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

Register (R/W) $56 (56) => MMU Slot 6 Control

* bits 7-0 = 8k RAM page at position $C000 to $DFFF ($00 on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

Register (R/W) $57 (57) => MMU Slot 7 Control

* bits 7-0 = 8k RAM page at position $E000 to $FFFF ($01 on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

Writing to ports $1FFD, $7FFD and $DFFD writes $FF to MMU0 and
MMU1 and writes appropriate values to MMU6 and MMU7 to map in the
selected 16k bank.

+3 special modes override the MMUs if used.

In addition the ZX Next has special controls which allow the data area
for Layer 2 to be overlaied on memory in a fashion that permits
selective read or write access. For details see the section on Layer 2
video.

@node NODE066


@{h4}ZX Spectrum 128

In addition to the native memory management, the ZX Next supports a
memory management system that is an expanded, and backward compatible,
version of the the system used on earlier ZX Spectrum models. This
system uses registers $1FFD, $7FFD, and $DFFD.

Port $1FFD (1FFD) Plus 3 Memory Paging Control
&nbsp;bits 7-3 = Unused, nust be 0
&nbsp;bit 2 = High bit of ROM selection (low bit is in Port $7FFD)
&nbsp;00 = ROM0 = 128k editor and menu system

&nbsp;01 = ROM1 = 128k syntax checker

&nbsp;10 = ROM2 = +3DOS

&nbsp;11 = ROM3 = 48k BASIC

&nbsp;bit 1 = Special mode: Low bit of memory configuration number
&nbsp;bit 0 = Paging mode
&nbsp;0 = Normal

&nbsp;1 = Special

You should echo writes to $5B67

Port $7FFD (7FFD) Memory Paging Control
&nbsp;bits 6-7 = reserved
&nbsp;bit 5 = Lock memory paging
&nbsp;bit 4 = low bit of ROM Select (high bit is in Port $1FFD) 
&nbsp;00 = ROM0 = 128k editor and menu system

&nbsp;01 = ROM1 = 128k syntax checker

&nbsp;10 = ROM2 = +3DOS

&nbsp;11 = ROM3 = 48k BASIC

&nbsp;bit 3 = Shadow screen toggle
&nbsp;bits 2-0 = LSB of Bank number for slot 4 (MSB is in Port $DFFD)

Disable with bit 5 port $7FFD

Port $DFFD (DFFD) Next Memory Bank Select
&nbsp;bits 7-4 = Reserved, must be 0
&nbsp;bits 3-0 = MSB of bank number for slot 4 (LSB is in Port $7FFD)


------------------------------------------
Subsections

@{ "Spectrum 128 Standard Paging" LINK NODE67 }

@{ "Paging out ROM" LINK NODE68 }

@{ "Spectrum 128 Special Paging" LINK NODE69 }

@node NODE067


@{h5}Spectrum 128 Standard Paging

128-style memory management can only alter the bank addressed at
$c000 (16k-slot 4, or 8k-slots 7-8). The active 16k-bank at $c000 is
selected by writing the 3 LSBs of the 16k-bank number to the bottom 3
bits of Memory Paging Control ($7FFD), and the 4 MSBs to the bottom 4
bits of Next Memory Bank Select ($DFFD). (The reason for the division
is that the original Spectrum 128, having only 128k of memory, only
needed 3 bits.)

If you are using the standard interrupt handler or OS routines, then
any time you write to Memory Paging Control ($7FFD) you should also
store the value at $5B5C. Any time you write to Plus 3 Memory Paging
Control ($1FFD) you should also store the value at $5B67. There is
no corresponding system variable for the Next-only Next Memory Bank
Select ($DFFD) and standard OS routines may not support the extended
banks properly.


------------------------------------------
@node NODE068


@{h5}Paging out ROM

ROM can be paged out by enabling AllRam mode, or by using Next memory
management. Beware that some programs may assume that they can find
ROM service routines at fixed addresses between $0000-$3fff. More
importantly, if the default interrupt mode (IM 1) is set, the Z80 will
jump the program counter to $0038 every frame expecting to find an
interrupt handler there. If it does not, pain and suffering will
likely result. DI is your friend. On the plus side, this does allow
you to write your own interrupt handler without the nuisance of using
IM 2.


------------------------------------------
@node NODE069


@{h5}Spectrum 128 Special Paging

&ldquo;Special paging mode&rdquo; (also called &ldquo;AllRam mode&rdquo; or &ldquo;CP/M mode&rdquo;)
is enabled by writing a value with the LSB set to Plus 3 Memory Paging
Control ($1FFD). Depending on the 3 low bits of this value a memory
configuration is selected as follows:


------------------------------------------
@node NODE070


@{h2}ROM

The ZX Spectrum Next had several ROMS: ROM0 (16k) - 128k editor and
menu system, ROM1 (16k) - 128k syntax checker, ROM2 (16k) - +3DOS,
ROM3 (16k) - 48k BASIC, divMMC/esxDOS ROM (8k), divMMC RAM (128k),
Multiface ROM (8k) and Alternate ROM (16k).


------------------------------------------
Subsections

* @{ "ZX Next native" LINK NODE71 }

* @{ "ZX Spectrum 128k" LINK NODE72 }

** @{ "ROM paging and selection" LINK NODE73 }

* @{ "divMMC" LINK NODE74 }

* @{ "Multiface" LINK NODE75 }


------------------------------------------
@node NODE071


@{h4}ZX Next native

Slots 0 and 1 select use by ROM by selecting page $FF. Which what ROM
is mapped in is determined by the other memory management system. If
the rest of the system selected the 48k ROM, Nextreg $8C determines
whether the actual 48k ROM, or the ZX Next Alternate ROM is in use. In
addition, it is possible to enable writing to the Alternate ROM.

Register (R/W) $8C (8C) => Alternate ROM

Immediate

* bit 7 = Alt ROM Enable (0 on hard reset)

* bit 6 = Alt ROM visible ONLY during writes (0 on hard reset)

* bit 5 = Reserved, must be 0

* bit 4 = 48k ROM Lock (0 on hard reset)

After Soft Reset (copied into bits 7-4)

* bit 3 = Alt ROM Enable (0 on hard reset)

* bit 2 = Alt ROM visible ONLY during writes (0 on hard reset)

* bit 1 = Reserved, must be 0

* bit 0 = 48k ROM Lock (0 on hard reset)


------------------------------------------
@node NODE072


@{h4}ZX Spectrum 128k


------------------------------------------
Subsections

@{ "ROM paging and selection" LINK NODE73 }


------------------------------------------
@node NODE073


@{h5}ROM paging and selection

$0000-$3fff is usually mapped to ROM. This area can only be fully
remapped using Next memory management. ROM is not considered one of
the numbered banks; it is mapped to the two 8k-banks by default, or by
setting their 8k-bank numbers to 255.

The 128k Spectrum has 2 ROM pages. Which of these is mapped is
selected by altering Bit 4 of Memory Paging Control ($7FFD). The
+2a/+3 has 4 ROM pages; the extra bit needed to select between these
is bit 2 of Plus 3 Memory Paging Control ($1FFD). This maintains
compatibility with the original machines' ROM paging as long as the
ROM is not paged out.


------------------------------------------
@node NODE074


@{h4}divMMC

The divMMC ROM mapping can take priority when it is enabled by port
$E3 or, when automapping has been enabled by nextreg $06, when it
has been automapped due to reading one of the appropriate
addresses. Port $E3 also controls whether the divMMC maps the esxDOS
ROM or divMMC RAM page 3 into slot 0 and which divMMC RAM page is
mapped into slot 1.

Port $E3 (E3) divMMC Control

Disable with bit 2 of Nextreg $09
&nbsp;bit 7 = conmem, enable divMMC memory
&nbsp;bit 6 = mapram, enable divMMC allRAM mode
&nbsp;bits 3-0 = bank, selected divMMC ram bank for $2000-$3FFF region
conmem can be used to manually control divMMC mapping. When enabled
$0000-$1FFF contains esxDOS ROM or esxDOS page 3
$2000-$3FFF contains esxDOS RAM page selected by bits 3-0
divMMC automatically maps itself in when instruction fetches hit
specific addresses in the ROM. When this happens, the esxDOS ROM (or divMMC
bank 3 if mapram is set) appears in $0000-$1FFF and the selected divMMC
bank appears as RAM in $2000-$3FFF
bit 6 can only be set, once set only a power cycle can reset it.
nextreg $09 bit 3 can be set to reset this bit.

divMMC automapping is normally disabled by NextZXOS see nextreg $06 bit 4.

Register (R/W) $06 (06) => Peripheral 2 Settings

* bit 7 = F8 CPU Speed Hotkey Enable (1 on reset)

* bit 6 = Enable classic audio mode (beep and tape to internal speaker,
other audio to ear and HDMI, 3.01.02)

* bit 5 = F3 50Hz/60Hz Hotkey Enable (1 on reset)

* bit 4 = divMMC Automap/NMI Enable (0 on hard reset)

* bit 3 = NMI Button Enable (0 on hard reset)

* bit 2 = PS/2 Mode (0 = keyboard, 1 = mouse)

* bits 1-0 = PSG Mode (00 = YM, 01 = AY, 11 = hold all PSGs in Reset)

@node NODE075


@{h4}Multiface

Need to find useful docs on the Multiface memory.

9f 1-In, 128-In2

1f 1-Out

bf 128-In, 3-Out

3f 128-Out, 3-In, 3-button

7f3f 3-7ffd

1f3f 3-1ffd


------------------------------------------
@node NODE076


@{h1}Interactions between paging methods

Changes made in 128 style and Next style memory management are
synchronized. The most recent change always has priority. This means
that

using 128-style memory management to select a new 16k-bank in 16k-slot
4 will update the MMU registers for the two 8k-slots with the
corresponding 8k-bank numbers.  enabling AllRam mode will update all
of the 8k-bank values with the appropriate 8k-slot numbers. These may
then be overwritten using Next memory management without needing to
alter the value at port $1FFD.  Since the 128-style memory management
ports are not readable, there is no synchronization applicable in the
other direction.


------------------------------------------
@node NODE077


@{h1}Memory Map


------------------------------------------
Subsections

@{ "Global Memory Map" LINK NODE78 }

@{ "Z80 Visible Memory Map" LINK NODE79 }


------------------------------------------
@node NODE078


@{h2}Global Memory Map

Physical Address
Size
Description

$000000-$00FFFF
64k
ZX Spectrum ROM (ROM0-3)

$010000-$011FFF
8k
EsxDOS ROM

$012000-$013FFF
8k
Multiface ROM

$014000-$017FFF
16k
EsxDOS Extra ROM

$018000-$01BFFF
16k
Alternate ROM

$01C000-$01FFFF
16k
Multiface RAM

$020000-$03FFFF
128k
DivMMC RAM

$040000-$0FFFFF
768k
Standard RAM

$100000-$1FFFFF
1024k
Expanded RAM

Normal RAM is divided into 8k pages or 16k banks which may be mapped
into the 64k memory space by the memory management hardware of the
Next. Some of these pages have special properties.

Pages 10, 11 and 14 are used by Layer 1/0 (ULA) video modes with 10
used by standard Spectrum ULA video, 10 and 11 used by Timex Hi-res
and Hi-colour modes, 11 used by Timex alternate video and page 14 used
by the ULA shadow mode. Pages 10 an 11 are usable by Layer 3 (Tilemap)
video.


------------------------------------------
@node NODE079


@{h2}Z80 Visible Memory Map


------------------------------------------
@node NODE080


@{h1}zxnDMA

February 25, 2019  Phoebus Dokos  Off  Hardware, Resources,

The ZX Spectrum Next DMA (zxnDMA)


------------------------------------------
Subsections

@{ "Overview" LINK NODE81 }

@{ "Accessing the zxnDMA" LINK NODE82 }

@{ "Description" LINK NODE83 }

@{ "Modes of Operation" LINK NODE84 }

@{ "Programming the zxnDMA" LINK NODE85 }

@{ "zxnDMA Registers" LINK NODE86 }

* @{ "WR0 – Write Register Group 0" LINK NODE87 }

* @{ "WR1 – Write Register Group 1" LINK NODE88 }

* @{ "WR2 – Write Register Group 2" LINK NODE89 }

* @{ "WR3 – Write Register Group 3" LINK NODE90 }

* @{ "WR4 – Write Register Group 4" LINK NODE91 }

* @{ "WR5 – Write Register Group 5" LINK NODE92 }

* @{ "WR6 – Command Register" LINK NODE93 }

* @{ "Operating speed" LINK NODE94 }

* @{ "The DMA and Interrupts" LINK NODE95 }

@{ "Programming examples" LINK NODE96 }


------------------------------------------
@node NODE081


@{h1}Overview

The ZX Spectrum Next DMA (zxnDMA) is a single channel dma device that
implements a subset of the Z80 DMA functionality. The subset is large
enough to be compatible with common uses of the similar Datagear
interface available for standard ZX Spectrum computers and
compatibles. It also adds a burst mode capability that can deliver
audio at programmable sample rates to the DAC device.


------------------------------------------
@node NODE082


@{h1}Accessing the zxnDMA

The zxnDMA is mapped to a single Read/Write IO Port 0x6B which is the
same one used by the Datagear but unlike the Datagear it doesn't also
map itself to a second port 0x0B similar to the MB-02 interface.

PORT $6b: zxnDMA


------------------------------------------
@node NODE083


@{h1}Description

The normal Z80 DMA (Z8410) chip is a pipelined device and because of
that it has numerous off-by-one idiosyncrasies and requirements on the
order that certain commands should be carried out. These issues are
not duplicated in the zxnDMA. You can continue to program the zxnDMA
as if it is were a Z8410 DMA device but it can also be programmed in a
simpler manner.

The single channel of the zxnDMA chip consists of two ports named A
and B. Transfers can occur in either direction between ports A and B,
each port can describe a target in memory or IO, and each can be
configured to autoincrement, autodecrement or stay fixed after a byte
is transferred.

A special feature of the zxnDMA can force each byte transfer to take a
fixed amount of time so that the zxnDMA can be used to deliver sampled
audio.


------------------------------------------
@node NODE084


@{h1}Modes of Operation

The zxnDMA can operate in a z80-dma compatibility mode.

The z80-dma compatibility mode is selected by setting bit 6 of nextreg
$06. In this mode, all transfers involve length+1 bytes which is the
same behaviour as the z80-dma chip. In zxn-dma mode, the transfer
length is exactly the number of bytes programmed. This mode is mainly
present to accommodate existing spectrum software that uses the
z80-dma and for cp/m programs that may have a z80-dma option.

The zxnDMA can also operate in either burst or continuous modes.

Continuous mode means the DMA chip runs to completion without allowing
the CPU to run. When the CPU starts the DMA, the DMA operation will
complete before the CPU executes its next instruction.

Burst mode nominally means the DMA lets the CPU run if either port is
not ready. This condition can't happen in the zxnDMA chip except when
operated in the special fixed time transfer mode. In this mode, the
zxnDMA will let the CPU run while it waits for the fixed time to
expire between bytes transferred.

Note that there is no byte transfer mode as in the Z80 DMA.


------------------------------------------
@node NODE085


@{h1}Programming the zxnDMA

Like the Z80 DMA chip, the zxnDMA has seven write registers named
WR0-WR6 that control the device. Each register WR0-WR6 can have zero
or more parameters associated with it.

In a first write to the zxnDMA port, the write value is compared
against a bitmask to determine which of the WR0-WR6 is the
target. Remaining bits in the written value can contain data as well
as a list of associated parameter bits. The parameter bits determine
if further writes are expected to deliver parameter values. If there
are multiple parameter bits set, the expected order of parameter
values written is determined by parameter bit position from right to
left (bit 0 through bit 7). Once all parameters are written, the
zxnDMA again expects a regular register write selecting WR0-WR6.

The table X.Y describes the registers and the bitmask required to
select them on the zxnDMA.


------------------------------------------
@node NODE086


@{h1}zxnDMA Registers

These are described below following the same convention used by Zilog
for its DMA chip:


------------------------------------------
Subsections

* ** 
@{ "WR0 – Write Register Group 0" LINK NODE87 }

** @{ "WR1 – Write Register Group 1" LINK NODE88 }

** @{ "WR2 – Write Register Group 2" LINK NODE89 }

** @{ "WR3 – Write Register Group 3" LINK NODE90 }

** @{ "WR4 – Write Register Group 4" LINK NODE91 }

** @{ "WR5 – Write Register Group 5" LINK NODE92 }

** @{ "WR6 – Command Register" LINK NODE93 }

** @{ "Operating speed" LINK NODE94 }

** @{ "The DMA and Interrupts" LINK NODE95 }


------------------------------------------
@node NODE087


@{h4}WR0 – Write Register Group 0

D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
0   |   |   |   |   |   |   |
|   |   |   |   |   0   0  Do not use
|   |   |   |   |   0   1  Transfer (Prefer this for Z80 DMA compatibility)
|   |   |   |   |   1   0  Do not use (Behaves like Transfer, Search on Z80
|   |   |   |   |                       DMA)
|   |   |   |   |   1   1  Do not use (Behaves like Transfer, Search/Trans-
|   |   |   |   |                      fer on Z80 DMA)
|   |   |   |   0 = Port B -&gt; Port A (Byte transfer direction)
|   |   |   |   1 = Port A -&gt; Port B
|   |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  PORT A STARTING ADDRESS (LOW BYTE)
|   |   V
D7  D6  D5  D4  D3  D2  D1  D0  PORT A STARTING ADDRESS (HIGH BYTE)
|   V
D7  D6  D5  D4  D3  D2  D1  D0  BLOCK LENGTH (LOW BYTE)
V
D7  D6  D5  D4  D3  D2  D1  D0  BLOCK LENGTH (HIGH BYTE)

Several registers are accessible from WR0. The first write to WR0 is
to the base register byte. Bits D6:D3 are optionally set to indicate
that associated registers in this group will be written next. The
order the writes come in are from D3 to D6 (right to left). For
example, if bits D6 and D3 are set, the next two writes will be
directed to PORT A STARTING ADDRESS LOW followed by BLOCK LENGTH HIGH.


------------------------------------------
@node NODE088


@{h4}WR1 – Write Register Group 1

D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
0   |   |   |   |   1   0   0
|   |   |   |
|   |   |   0 = Port A is memory
|   |   |   1 = Port A is IO
|   |   |
|   0   0 = Port A address decrements
|   0   1 = Port A address increments
|   1   0 = Port A address is fixed
|   1   1 = Port A address is fixed
|
V
D7  D6  D5  D4  D3  D2  D1  D0  PORT A VARIABLE TIMING BYTE
0   0   0   0   0   0   |   |
0   0 = Cycle Length = 4
0   1 = Cycle Length = 3
1   0 = Cycle Length = 2
1   1 = Do not use

The cycle length is the number of cycles used in a read or write
operation. The first cycle asserts signals and the last cycle
releases them. There is no half cycle timing for the control signals.


------------------------------------------
@node NODE089


@{h4}WR2 – Write Register Group 2

D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
0   |   |   |   |   0   0   0
|   |   |   |
|   |   |   0 = Port B is memory
|   |   |   1 = Port B is IO
|   |   |
|   0   0 = Port B address decrements
|   0   1 = Port B address increments
|   1   0 = Port B address is fixed
|   1   1 = Port B address is fixed
|
V
D7  D6  D5  D4  D3  D2  D1  D0  PORT B VARIABLE TIMING BYTE
0   0   |   0   0   0   |   |
|               0   0 = Cycle Length = 4
|               0   1 = Cycle Length = 3
|               1   0 = Cycle Length = 2
|               1   1 = Do not use
|
V
D7  D6  D5  D4  D3  D2  D1  D0  ZXN PRESCALAR (FIXED TIME TRANSFER)

The ZXN PRESCALAR is a feature of the zxnDMA implementation. If
non-zero, a delay will be inserted after each byte is transferred such
that the total time needed for each transfer is determined by the
prescalar. This works in both the continuous mode and the burst
mode. If the DMA is operated in burst mode, the DMA will give up any
waiting time to the CPU so that the CPU can run while the DMA is idle.

The rate of transfer is given by the formula &ldquo;Frate = 875kHz /
prescalar&rdquo; or, rearranged, &ldquo;prescalar = 875kHz / Frate&rdquo;. The formula
is framed in terms of a sample rate (Frate) but Frate can be inverted
to set a transfer time for each byte instead. The 875kHz constant is a
nominal value assuming a 28MHz system clock; the system clock actually
varies from this depending on the video timing selected by the user
(HDMI, VGA0-6) so for complete accuracy the constant should be
prorated according to documentation for nextreg $11.

In a DMA audio setting, selecting a sample rate of 16kHz would mean
setting the prescalar value to 55. This sample period is constant
across changes in CPU speed.

@node NODE090


@{h4}WR3 – Write Register Group 3

D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
1   |   0   0   0   0   0   0
|
1 = DMA Enable

The Z80 DMA defines more fields but they are ignored by the zxnDMA.

The two other registers defined by the Z80 DMA in this group on D4 and
D3 are implemented by the zxnDMA but they do nothing.

It is preferred to start the DMA by writing an Enable DMA command to
WR6.


------------------------------------------
@node NODE091


@{h4}WR4 – Write Register Group 4

D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
1   |   |   0   |   |   0   1
|   |       |   |
0   0 = Do not use (Behaves like Continuous mode, Byte mode on Z80 DMA)
0   1 = Continuous mode
1   0 = Burst mode
1   1 = Do not use
|   |
|   V
D7  D6  D5  D4  D3  D2  D1  D0  PORT B STARTING ADDRESS (LOW BYTE)
|
V
D7  D6  D5  D4  D3  D2  D1  D0  PORT B STARTING ADDRESS (HIGH BYTE)

The Z80 DMA defines three more registers in this group through D4 that
define interrupt behaviour. Interrups and pulse generation are not
implemented in the zxnDMA nor are these registers available for
writing.


------------------------------------------
@node NODE092


@{h4}WR5 – Write Register Group 5

D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
1   0   |   |   0   0   1   0
|   |
|   0 = /ce only
|   1 = /ce &amp; /wait multiplexed
|
0 = Stop on end of block
1 = Auto restart on end of block

The /ce &amp; /wait mode is implemented in the zxnDMA but is not currently
used. This mode has an external device using the DMA's /ce pin to
insert wait states during the DMA's transfer.

The auto restart feature causes the DMA to automatically reload its
source and destination addresses and reset its byte counter to zero to
repeat the last transfer when a previous one is finished.


------------------------------------------
@node NODE093


@{h4}WR6 – Command Register

D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
1   ?   ?   ?   ?   ?   1   1
|   |   |   |   |
1   0   0   0   0 = \$C3 = Reset
1   0   0   0   1 = \$C7 = Reset Port A Timing
1   0   0   1   0 = \$CB = Reset Port B Timing
0   1   1   1   1 = \$BF = Read Status Byte
0   0   0   1   0 = \$8B = Reinitialize Status Byte
0   1   0   0   1 = \$A7 = Initialize Read Sequence
1   0   0   1   1 = \$CF = Load
1   0   1   0   0 = \$D3 = Continue
0   0   0   0   1 = \$87 = Enable DMA
0   0   0   0   0 = \$83 = Disable DMA
+-- 0   1   1   1   0 = \$BB = Read Mask Follows
|
D7  D6  D5  D4  D3  D2  D1  D0  READ MASK
0   |   |   |   |   |   |   |
|   |   |   |   |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  Status Byte
|   |   |   |   |   |
|   |   |   |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  Byte Counter Low
|   |   |   |   |
|   |   |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  Byte Counter High
|   |   |   |
|   |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  Port A Address Low
|   |   |
|   |   V
D7  D6  D5  D4  D3  D2  D1  D0  Port A Address High
|   |
|   V
D7  D6  D5  D4  D3  D2  D1  D0  Port B Address Low
|
V
D7  D6  D5  D4  D3  D2  D1  D0  Port B Address High

Unimplemented Z80 DMA commands are ignored.

Prior to starting the DMA, a LOAD command must be issued to copy the
Port A and Port B addresses into the DMA's internal pointers. Then an
ìEnable DMAî command is issued to start the DMA.

The ìContinueî command resets the DMA’s byte counter so that a
following ìEnable DMAî allows the DMA to repeat the last transfer but
using the current internal address pointers. I.e. it continues from
where the last copy operation left off.

Registers can be read via an IO read from the DMA port after setting
the read mask. (At power up the read mask is set to $7f). Register
values are the current internal dma counter values. So ìPort Address A
Lowî is the lower 8-bits of Port A’s next transfer address. Once the
end of the read mask is reached, further reads loop around to the
first one.

The format of the DMA status byte is as follows:

00E1101T

E is set to 0 if the total block length has been transferred
at least once.

T is set to 1 if at least one byte has been transferred.


------------------------------------------
@node NODE094


@{h4}Operating speed

The zxnDMA operates at the same speed as the CPU, that is 3.5MHz, 7MHz
or 14MHz. This is a contended clock that is modified by the ULA and
the auto-slowdown by Layer2.

Auto-slowdown occurs without user intervention if speed exceeds 7Mhz
and the active Layer2 display is being generated (higher speed
operation resumes when the active Layer2 display is not
generated). Programmers do NOT need to account for speed differences
regarding DMA transfers as this happens automatically.

Because of this, the cycle lengths for Ports A and B can be set to
their minimum values without ill effects. The cycle lengths specified
for Ports A and B are intended to selectively slow down read or write
cycles for hardware that cannot operate at the DMA's full speed.


------------------------------------------
@node NODE095


@{h4}The DMA and Interrupts

The zxnDMA cannot currently generate interrupts.

The other side of this is that while the DMA controls the bus, the Z80
cannot respond to interrupts. On the Z80, the nmi interrupt is edge
triggered so if an nmi occurs the fact that it occurred is stored
internally in the Z80 so that it will respond when it is woken up. On
the other hand, maskable interrupts are level triggered. That is, the
Z80 must be active to regularly sample the /INT line to determine if a
maskable interrupt is occurring. On the Spectrum and the ZX Next, the
ULA (and line interrupt) are only asserted for a fixed amount of time
&nbsp;30 cycles at 3.5MHz. If the DMA is executing a transfer while the
interrupt is asserted, the CPU will not be able to see this and it
will most likely miss the interrupt. In burst mode, the CPU will never
miss these interrupts, although this may change if multiple channels
are implemented.


------------------------------------------
@node NODE096


@{h1}Programming examples

A simple way to program the DMA is to walk down the list of registers
WR0-WR5, sending desired settings to each. Then start the DMA by
sending a LOAD command followed by an ENABLE_DMA command to WR6. Once
more familiar with the DMA, you will discover that the amount of
information sent can be reduced to what changes between transfers.

Assembly

Short example program to DMA memory to the screen then DMA a sprite
image from memory to sprite RAM, and then showing said sprite scroll
across the screen.

;------------------------------------------------------------------------------
device zxspectrum48
;------------------------------------------------------------------------------
; DEFINE testing
;------------------------------------------------------------------------------
; DMA (Register 6)
;
;------------------------------------------------------------------------------
;zxnDMA programming example
;------------------------------------------------------------------------------
;(c) Jim Bagley
;------------------------------------------------------------------------------
DMA_RESET equ $c3
DMA_RESET_PORT_A_TIMING equ $c7
DMA_RESET_PORT_B_TIMING equ $cb
DMA_LOAD equ $cf ; %11001111
DMA_CONTINUE equ $d3
DMA_DISABLE_INTERUPTS equ $af
DMA_ENABLE_INTERUPTS equ $ab
DMA_RESET_DISABLE_INTERUPTS equ $a3
DMA_ENABLE_AFTER_RETI equ $b7
DMA_READ_STATUS_BYTE equ $bf
DMA_REINIT_STATUS_BYTE equ $8b
DMA_START_READ_SEQUENCE equ $a7
DMA_FORCE_READY equ $b3
DMA_DISABLE equ $83
DMA_ENABLE equ $87
DMA_WRITE_REGISTER_COMMAND equ $bb
DMA_BURST equ %11001101
DMA_CONTINUOUS equ %10101101
ZXN_DMA_PORT equ $6b
SPRITE_STATUS_SLOT_SELECT equ $303B
SPRITE_IMAGE_PORT equ $5b
SPRITE_INFO_PORT equ $57
;------------------------------------------------------------------------------

IFDEF testing
org $6000
ELSE
org $2000
ENDIF

start
ld hl,$0000
ld de,$4000
ld bc,$800
call TransferDMA ; copy some random data to the screen pointing
; to ROM for now, for the purpose of showing
; how to do a DMA copy.
ld a,0 ; sprite image number we want to update
ld bc,SPRITE_STATUS_SLOT_SELECT
out (c),a ; set the sprite image number
ld bc,1*256 ; number to transfer (1)
ld hl,testsprite ; from
call TransferDMASprite ; transfer to sprite ram

nextreg 21,1 ; turn sprite on. for more info on this check
; out https://www.specnext.com/tbblue-io-port-system/
ld de,0
ld (xpos),de ; set initial X position ( doesn't need it for
; this demo, but if you run the .loop again it
; will continue from where it was
ld a,$20
ld (ypos),a ; set initial Y position

.loop
ld a,0 ; sprite number we want to position
ld bc,SPRITE_STATUS_SLOT_SELECT
out (c),a
ld de,(xpos)
ld hl,(ypos) ; ignores H so doing this rather than
; ld a,(ypos):ld l,a
ld bc,(image) ; not flipped or palette shifted
call SetSprite

halt

ld de,(xpos)
inc de
ld (xpos),de
ld a,d
cp $01
jr nz,.loop ; if high byte of xpos is not 1 (right of
; screen )
ld a,e
cp $20+1
jr nz,.loop ; if low byte is not $21 just off the right of
; the screen, $20 is off screen but as the
; INC DE is just above and not updated sprite
; after it, it needs to be $21
xor a
ret ; return back to basic with OK

xpos dw 0 ; x position
ypos db 0 ; y position
; these next two BITS and IMAGE are swapped
; as bits needs to go into B register image
; db 0+$80 ; use image 0 (for the image we
; transfered)+$80 to set the sprite to active
bits db 0 ; not flipped or palette shifted

c1 = %11100000
c2 = %11000000
c3 = %10100000
c4 = %10000000
c5 = %01100000
c6 = %01000000
c7 = %00100000
c8 = %00000000

testsprite
db c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1
db c1,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c1
db c1,c2,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c2,c1
db c1,c2,c3,c4,c4,c4,c4,c4,c4,c4,c4,c4,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c5,c5,c5,c5,c5,c5,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c6,c6,c6,c6,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c7,c7,c7,c7,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c7,c8,c8,c7,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c7,c8,c8,c7,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c7,c7,c7,c7,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c6,c6,c6,c6,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c5,c5,c5,c5,c5,c5,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c4,c4,c4,c4,c4,c4,c4,c4,c4,c3,c2,c1
db c1,c2,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c2,c1
db c1,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c1
db c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1

;-------------------------------------------------
; de = X
; l = Y
; b = bits
; c = sprite image
SetSprite
push bc
ld bc,SPRITE_INFO_PORT
out (c),e ; Xpos
out (c),l ; Ypos
pop hl
ld a,d
and 1
or h
out (c),a
ld a,l:or $80
out (c),a ; image
ret

;--------------------------------
; hl = source
; de = destination
; bc = length
;--------------------------------
TransferDMA
di
ld (DMASource),hl
ld (DMADest),de
ld (DMALength),bc
ld hl,DMACode
ld b,DMACode_Len
ld c,ZXN_DMA_PORT
otir
ei
ret

DMACode db DMA_DISABLE
db %01111101 ; R0-Transfer mode, A -&gt; B, write adress
; + block length
DMASource dw 0 ; R0-Port A, Start address
; (source address)
DMALength dw 0 ; R0-Block length (length in bytes)
db %01010100 ; R1-write A time byte, increment, to
; memory, bitmask
db %00000010 ; 2t
db %01010000 ; R2-write B time byte, increment, to
; memory, bitmask
db %00000010 ; R2-Cycle length port B
db DMA_CONTINUOUS ; R4-Continuous mode (use this for block
; transfer), write dest adress
DMADest dw 0 ; R4-Dest address (destination address)
db %10000010 ; R5-Restart on end of block, RDY active
; LOW
db DMA_LOAD ; R6-Load
db DMA_ENABLE ; R6-Enable DMA

DMACode_Len equ $-DMACode

;------------------------------------------------------------------------------
; hl = source
; bc = length
; set port to write to with TBBLUE_REGISTER_SELECT
; prior to call
;------------------------------------------------------------------------------
TransferDMAPort
di
ld (DMASourceP),hl
ld (DMALengthP),bc
ld hl,DMACodeP
ld b,DMACode_LenP
ld c,ZXN_DMA_PORT
otir
ei
ret

DMACodeP db DMA_DISABLE
db %01111101 ; R0-Transfer mode, A -&gt; B, write adress
; + block length
DMASourceP dw 0 ; R0-Port A, Start address (source address)
DMALengthP dw 0 ; R0-Block length (length in bytes)
db %01010100 ; R1-read A time byte, increment, to
; memory, bitmask
db %00000010 ; R1-Cycle length port A
db %01101000 ; R2-write B time byte, increment, to
; memory, bitmask
db %00000010 ; R2-Cycle length port B
db %10101101 ; R4-Continuous mode (use this for block
; transfer), write dest adress
dw $253b ; R4-Dest address (destination address)
db %10000010 ; R5-Restart on end of block, RDY active
; LOW
db DMA_LOAD ; R6-Load
db DMA_ENABLE ; R6-Enable DMA

DMACode_LenP equ $-DMACodeP
;------------------------------------------------------------------------------
; hl = source
; bc = length
;------------------------------------------------------------------------------
TransferDMASprite
di
ld (DMASourceS),hl
ld (DMALengthS),bc
ld hl,DMACodeS
ld b,DMACode_LenS
ld c,ZXN_DMA_PORT
otir
ei
ret

DMACodeS db DMA_DISABLE
db %01111101 ; R0-Transfer mode, A -&gt; B, write adress
; + block length
DMASourceS dw 0 ; R0-Port A, Start address (source address)
DMALengthS dw 0 ; R0-Block length (length in bytes)
db %01010100 ; R1-read A time byte, increment, to
; memory, bitmask
db %00000010 ; R1-Cycle length port A
db %01101000 ; R2-write B time byte, increment, to
; memory, bitmask
db %00000010 ; R2-Cycle length port B
db %10101101 ; R4-Continuous mode (use this for block
; transfer), write dest adress
dw SPRITE_IMAGE_PORT ; R4-Dest address (destination address)
db %10000010 ; R5-Restart on end of block, RDY active
; LOW
db DMA_LOAD ; R6-Load
db DMA_ENABLE ; R6-Enable DMA
DMACode_LenS equ $-DMACodeS
;------------------------------------------------------------------------------
; de = dest, a = fill value, bc = lenth
;------------------------------------------------------------------------------
DMAFill
di
ld (FillValue),a
ld (DMACDest),de
ld (DMACLength),bc
ld hl,DMACCode
ld b,DMACCode_Len
ld c,ZXN_DMA_PORT
otir
ei
ret

FillValue db 22
DMACCode db DMA_DISABLE
db %01111101
DMACSource dw FillValue
DMACLength dw 0
db %00100100,%00010000,%10101101
DMACDest dw 0
db DMA_LOAD,DMA_ENABLE
DMACCode_Len equ $-DMACCode

;------------------------------------------------------------------------------
; End of file
;------------------------------------------------------------------------------

IFDEF testing
savesna "dmatest.sna",start
ELSE
fin
savebin "DMATEST",start,fin-start
ENDIF


------------------------------------------
@node NODE097


@{h1}Copper and Display Timing

From: KevB (aka 9bitcolour)


------------------------------------------
Subsections

* ** 
*** @{ "Introduction" LINK NODE98 }

*** @{ "Overview" LINK NODE99 }

@{ "Timing" LINK NODE100 }

* @{ "Machines" LINK NODE101 }

* @{ "Display" LINK NODE102 }

* @{ "Resolution" LINK NODE103 }

* @{ "Dot Clock" LINK NODE104 }

* @{ "Coordinates" LINK NODE105 }

* @{ "Compare" LINK NODE106 }

* @{ "Overscan" LINK NODE107 }

@{ "Instructions" LINK NODE108 }

* @{ "NOOP" LINK NODE109 }

* @{ "MOVE" LINK NODE110 }

* @{ "WAIT" LINK NODE111 }

* @{ "Example" LINK NODE112 }

@{ "Control" LINK NODE113 }

* @{ "STOP" LINK NODE114 }

* @{ "RESET" LINK NODE115 }

* @{ "START" LINK NODE116 }

* @{ "FRAME" LINK NODE117 }

@{ "Configuration" LINK NODE118 }

* @{ "Refresh Rate" LINK NODE119 }

* @{ "Video Modes" LINK NODE120 }

* @{ "Machine Type" LINK NODE121 }

* @{ "Summary" LINK NODE122 }


------------------------------------------
@node NODE098


@{h4}Introduction

The ZX Spectrum Next includes a co-processor named &ldquo;COPPER&rdquo;. It
functions in a similar way to the Copper found in the Commodore Amiga
Agnus custom chip.  It's role is to free the Z80 of tasks that require
the writing of hardware registers at precise pixel co-ordinates.


------------------------------------------
@node NODE099


@{h4}Overview

The ZX Spectrum Next COPPER has three instructions: NOOP, MOVE, WAIT. 

NOOP is used to fine tune timing. MOVE writes data to a specific range
of hardware registers. WAIT waits for a pixel position on the video
display.

These instructions are stored in 2k (2048 BYTES) of dedicated
write-only program RAM also known as a &ldquo;Copper list&rdquo;.

Each instruction is 16 bits (WORD) in size allowing for a maximum of
1024 instructions to be stored in the program RAM. The COPPER uses an
internal 10 bit program counter (PC) which wraps to zero at the end of
the list. The PC can be reset to zero, this is the default value after
a hard/soft reset.

The instructions are stored in big endian format and transferred to
the 2k program RAM using the Z80 or DMA (bits 15..8 followed by bits
7..0).

Three write-only hardware registers control access to the program RAM
as well as the operating modes.

System performance is not affected when the COPPER is executing instructions.

The hardware registers and COPPER program RAM are not connected to the
main memory BUS. The overall design of this system together with the
use of alternate clock edges means that contention between the COPPER,
Z80 and DMA has been eliminated.

The COPPER has a base clock speed of 13.5Mhz for HDMI and 14Mhz for VGA.

The bandwidth is around 14 million single cycle NOOP/WAIT instructions
and 7 million two cycle MOVE instructions per second.

@node NODE100


@{h1}Timing

To fully understand the COPPER, you must first understand the display
timing for each of the machines and video modes found in the ZX
Spectrum Next.

There are several display timing configurations due to the four
machine types, two refresh rates, two video systems (VGA/HDMI) and
Timex HIRES mode.

Details of these timings are outlined in this chapter.


------------------------------------------
Subsections

* ** 
@{ "Machines" LINK NODE101 }

** @{ "Display" LINK NODE102 }

** @{ "Resolution" LINK NODE103 }

** @{ "Dot Clock" LINK NODE104 }

** @{ "Coordinates" LINK NODE105 }

** @{ "Compare" LINK NODE106 }

** @{ "Overscan" LINK NODE107 }


------------------------------------------
@node NODE101


@{h4}Machines

The ZX Spectrum Next has four machine types (48k, 128k, Pentagon, and
HDMI). The machine timing and HDMI determine the number of T-states
per line which determines the base dot clock frequency and Z80/DMA
clock speed.

This guide groups machine types by their timing for convenience. The
HDMI video mode overrides the default machine timing so it is included
as an extra machine type which does not exist in the official
documentation.


------------------------------------------
@node NODE102


@{h4}Display

The ZX Spectrum Next doesn't have video modes based on resolution that
you would expect to find on graphics card based hardware. There is one
fixed resolution of img1.svg"
ALT="$256\times 192$"> which can be doubled to
img22.svg"
ALT="$512\times192$"> in Timex HIRES mode. What it does have is the ability
to set the refresh rate from 50Hz to 60Hz and horizontal dot
clock. This in turn together with the VGA and HDMI timing affects the
vertical line count giving several combinations in total.

VGA modes 0..6 are included as one single VGA mode as the internal
machine timing is constant across those seven refresh rate steps.

More details can be found in Video modes.


------------------------------------------
@node NODE103


@{h4}Resolution

There are two main horizontal resolutions: standard img1.svg"
ALT="$256\times 192$"> and
Timex HIRES img22.svg"
ALT="$512\times192$">. Details of LORES img27.svg"
ALT="$128\times96$"> are not
included to simplify this guide.

The frame buffer height is fixed at 192 pixels and surrounded by a
large border and overscan as well as horizontal and vertical blanking
periods.

There are five vertical line counts: 261, 262, 311, 312, 320. Several
pixels are hidden in the overscan and blanking periods beyond the
visible border.

The result is img1.svg"
ALT="$256\times 192$"> and img22.svg"
ALT="$512\times192$"> pixel resolutions with
a large border.

The colour of the visible border beyond the frame buffer can be
manipulated. Visual changes will not show during the overscan and
blanking periods.


------------------------------------------
@node NODE104


@{h4}Dot Clock

The dot clock on the ZX Spectrum Next runs at 13.5Mhz for HDMI and
around 14Mhz for VGA. The COPPER clock runs at the same frequency as
the dot clock. For v3.00 the copper runs at twice the frequency of the
dot clock.

The number of dot clocks per line is calculated by multiplying the
number of 3.5Mhz Z80 T-states per line by four. Example: 228Ts * 4 =
912 dot clocks.

The number of dot clocks per second is calculated by the following:

T-states per line * 4 * line count * refresh rate

In standard img1.svg"
ALT="$256\times 192$"> resolution the duration of one pixel is two
dot clocks. In Timex HIRES img22.svg"
ALT="$512\times192$"> resolution the duration of
one pixel is one dot clock.

Details of the dot clock counts can be found in tables 5.1 and 5.2.


------------------------------------------
@node NODE105


@{h4}Coordinates

The top left pixel of the frame buffer is line 0 and horizontal dot
clock 0. This is also known as &ldquo;0,0&rdquo;.

The bottom right pixel of the frame buffer in standard img1.svg"
ALT="$256\times 192$">
resolution is line 191 and horizontal dot clocks 510+511.

The bottom right pixel of the frame buffer in Timex HIRES
img22.svg"
ALT="$512\times192$"> resolution is line 191 and horizontal dot clock 511.

The line one pixel above the frame buffer is the last line of the
video frame and equal to the total line count minus one (312-1 for
example).

The line one pixel below the frame buffer is line 192.

The COPPER horizontal dot clock compare is locked to every eight
pixels in standard img1.svg"
ALT="$256\times 192$"> resolution and every sixteen pixels
in Timex HIRES img22.svg"
ALT="$512\times192$"> resolution. The NOOP instruction can be
used to fine tune timing in single dot clock steps.


------------------------------------------
@node NODE106


@{h4}Compare

The COPPER uses a 9 bit vertical line compare allowing it to handle
the various line counts.

The COPPER horizontal compare is 6 bits meaning that it can wait for
64 positions across each line. The range of this value is limited by
the machine timing as that determines the number of dot clocks per
line.

Each horizontal compare is in steps of 16 dot clocks to cover the full
range across a raster line.

16 dot clocks = 4 pixels in lo img27.svg"
ALT="$128\times96$"> resolution

16 dot clocks = 8 pixels in standard img1.svg"
ALT="$256\times 192$"> resolution

16 dot clocks = 16 pixels in high img22.svg"
ALT="$512\times192$"> resolution

There is some slack to consider after the maximum horizontal compare
value. The slack is calculated using the following:

dot clocks per line - maximum horizontal compare * 16

Table 5.5 provides details of the horizontal display, left/right
border, blanking and COPPER dot clock/pixel position compare values:

Table 5.6 provides a detailed list of vertical display, top/bottom
border and blanking as well as maximum COPPER line compare. It also
provides the ULA VBLANK interrupt line number.

Note: The HDMI overscan and blanking period is larger than that of a
VGA monitor which can auto-adjust alignment. The following data is
based on visible results from various monitors thus subject to
refinement.

Pixels are visible during DISPLAY/BORDER and hidden during BLANKING.

@node NODE107


@{h4}Overscan

The visible area of the display can extend to resolutions exceeding
img1.svg"
ALT="$256\times 192$">.

The 50/60 Hz refresh rate mode dictates the vertical limit.

VGA and HDMI differ with VGA providing more visible pixels beyond the
range of HDMI. Table 5.7 provides ideal
extended pixel resolutions:

Maximum Extended VGA Resolutions

50Hz = img48.svg"
ALT="$352\times288$"> (standard 256 resolution)

60Hz = img49.svg"
ALT="$352\times240$"> (standard 256 resolution)

Table 5.8 provides COPPER horizontal position and vertical
line compare parameters for ideal extended resolutions:


------------------------------------------
@node NODE108


@{h1}Instructions

This section describes the behaviour of the COPPER instructions as
well as the bit definitions and execution time.

The three 16 bit COPPER instructions are comprised of the following
bit definitions:


------------------------------------------
Subsections

* ** 
@{ "NOOP" LINK NODE109 }

** @{ "MOVE" LINK NODE110 }

** @{ "WAIT" LINK NODE111 }

** @{ "Example" LINK NODE112 }


------------------------------------------
@node NODE109


@{h4}NOOP

NOOP (no-operation) executes in one dot clock. It is useful for fine
tuning timing, initialising COPPER RAM and 'NOP' out COPPER program
instructions.

It can be used to align colour and display changes to half pixel
positions in standard img1.svg"
ALT="$256\times 192$"> resolution. Its duration is equal
to one Timex HIRES pixel.

This guide uses the name 'NOOP' to avoid confusion with the Z80 opcode
NOP.


------------------------------------------
@node NODE110


@{h4}MOVE

MOVE executes in two dot clocks. It moves 8 bits of data into any of
the Next hardware registers in the range $00 (0) .. $7F (127).

The WORD value $0000 is reserved for the NOOP instruction so no
register access is carried out for that special case. Register $00 is
read-only so not affected by the restriction of not being able to
write zero to it.

This instruction can perform 7 million register writes per second for
VGA and 6.75 million register writes per second for HDMI.


------------------------------------------
@node NODE111


@{h4}WAIT

WAIT executes in one dot clock. It performs a compare with the current
vertical line number and the current horizontal dot clock.

WAIT will hold until the current raster line matches the 9 bit value
stored in bits 8..0. When the line compare matches, WAIT will still
hold if the current horizontal dot clock is less than the value in
bits 14..9.

This compare logic means that out of order vertical line compares will
cause the COPPER to wait until the next video frame as the test is for
an exact match of the line number. The COPPER will continue to the
next instruction after an out of order horizontal pixel position
compare as the test checks for the current dot clock being greater
than or equal to the compare value.

WAIT will stop the COPPER when a compare is made against an out of
range vertical line or horizontal dot clock position as they will
never occur

A standard way to terminate a COPPER program is to wait for line 511
and horizontal position 63. This encodes into the instruction WORD
$FFFF.

The horizontal dot clock position compare includes an adjustment
meaning that the compare completes three dot clocks early in standard
img1.svg"
ALT="$256\times 192$"> resolution and two dot clocks early in Timex HIRES
img22.svg"
ALT="$512\times192$"> resolution. In practice, a pixel position can be
specified with clocks to spare to write a register value before the
pixel is displayed. This saves software having to auto-adjust
positions to arrive early. It also means that a wait for 0,0 can
affect the first pixel of the frame buffer before it is displayed and
set the scroll registers without visual artefacts.

@node NODE112


@{h4}Example

The following example provides a simple COPPER program to move data to
a hardware register at two specific pixel positions. The BYTES for the
program are listed in the left column:

PAL8 equ   0x41           ; 8 bit palette hardware register

$80,$00       WAIT  0,0            ; wait for pixel position 0,0 (H,V)
$00,$00       NOOP                 ; fine tune timing by one dot clock
$41,$E0       MOVE  PAL8,11100000b ; write RED to palette register

$C0,$BF       WAIT  32,191         ; wait for pixel position 256,191
$00,$00       NOOP                 ; fine tune timing by one dot clock
$41,$00       MOVE  PAL8,00000000b ; write BLACK to palette register

$FF,$FF       WAIT  63,511         ; wait for an out of range position


------------------------------------------
@node NODE113


@{h1}Control

The COPPER is controlled by the following three write-only registers:

&nbsp;$60 (96)   Copper data
&nbsp;$61 (97)   Copper control LO BYTE
&nbsp;$62 (98)   Copper control HI BYTE

The COPPER instructions are written one BYTE at a time to the program
RAM using register $60 (Copper data).

An index system is used to select the destination write address within
the 2K program RAM. Eleven bits are needed to represent the
index. Registers $61 and $62 hold this 11 bit index.

The index increments each time one BYTE is written to register
$60. The index wraps to zero when the last BYTE of program RAM is
written.

The instruction data is normally written in big endian format although
there is no rule stating that partial instruction BYTES cannot be
written. It is safe to write to the COPPER program RAM while the
COPPER is executing as long the instruction data written does not
create a mall formed instruction which comprises of one half of the
current executing instruction and one half the new instruction - this
could result in unexpected behaviour.

The Z80 and DMA can be used to write the instruction data.

Writing to program RAM while the COPPER is running has no impact on
system performance as the RAM is contention free. COPPER timing is not
affected by the Z80 or DMA writing to the program RAM. Program RAM is
write-only.

The contents of the 2k program RAM are preserved during a hard/soft reset.

Register $61 holds the lower 8 bits of the index. Register $62 holds
the upper 3 bits of the index as well as two control bits which set
the COPPER operating mode.

The COPPER has an internal 10 bit program counter (PC). Each
instruction advances the program counter by one after completion. The
program counter wraps to zero after the last instruction at location
1023. This causes the copper list to loop.

The program counter defaults to zero during a hard/soft reset.

The control bits require a change to update the operating mode. This
feature preserves COPPER operation when setting the program RAM index
address.

The program counter is preserved when stopping the COPPER. Two of the
four control settings reset the internal PC to zero.

Table 5.11 describes the control bits:

Here is a detailed description of the control bits:


------------------------------------------
Subsections

* ** 
@{ "STOP" LINK NODE114 }

** @{ "RESET" LINK NODE115 }

** @{ "START" LINK NODE116 }

** @{ "FRAME" LINK NODE117 }

@node NODE114


@{h4}STOP

This is the default operating mode set during a hard/soft reset. The
COPPER is idle in this state and will STOP if currently executing when
entering this mode. It is safe to write to any location within the 2K
program RAM when the COPPER is stopped.

Entering STOP mode preserves the internal program counter so that the
COPPER may continue when restarted.


------------------------------------------
@node NODE115


@{h4}RESET

The program counter is RESET to zero when entering this mode. The
COPPER is started if idle otherwise entering this mode acts as a jump
to location zero when the COPPER is running.


------------------------------------------
@node NODE116


@{h4}START

Entering this mode causes an idle COPPER to start executing
instructions from the current program counter. Entering this mode
while the COPPER is running has no effect other than to disable FRAME
mode if active.


------------------------------------------
@node NODE117


@{h4}FRAME

The program counter is RESET to zero when entering this mode. The
COPPER is started if idle otherwise entering this mode acts as a jump
to location zero when the COPPER is running.

Entering this state enables FRAME mode. The program counter will be
reset to zero each frame at 0,0.


------------------------------------------
@node NODE118


@{h1}Configuration

Hardware registers provide timing and configuration data allowing
software to build and configure COPPER programs that function
correctly across the various video modes and machine types. It is not
essential to detect the machine type but it should be noted that
software should not assume that it is running on a specific machine as
the COPPER hardware is available across all four machine types.

Three registers can be read to determine the machine configuration for
Ts per line, dot clocks, refresh rate, line count and maximum
horizontal dot clock/pixel position compare.


------------------------------------------
Subsections

* ** 
@{ "Refresh Rate" LINK NODE119 }

** @{ "Video Modes" LINK NODE120 }

** @{ "Machine Type" LINK NODE121 }

** @{ "Summary" LINK NODE122 }


------------------------------------------
@node NODE119


@{h4}Refresh Rate

The refresh rate must be taken into account and can change real-time
so should be monitored and auto-configured when the COPPER is active
as the line count will change with the refresh rate. This could lead
to the COPPER waiting for lines that never occur.

Register (R/W) $05 (05) => Peripheral 1 Settings

* bits 7-6 = joystick 1 mode (MSB)

* bits 5-4 = joystick 2 mode (MSB)

* bit 3 = joystick 1 mode (LSB)

* bit 2 = 50/60 Hz mode (0 = 50Hz, 1 = 60Hz)

* bit 1 = joystick 2 mode (LSB)

* bit 0 = Enable Scandoubler

Joystick modes

* 000 = Sinclair 2 (67890)

* 001 = Kempston 2 (port $37)

* 010 = Kempston 1 (port $1F)

* 011 = Megadrive 1 (port $1F)

* 100 = Cursor

* 101 = Megadrive 2 (port $37)

* 110 = Sinclair 1 (12345)

* 111 = I/O Mode (3.01.04)
Both joysticks are places in I/O Mode if either is set to I/O
Mode. The underlying joystick type is not changed and reads of this
register will continue to return the last joystick type. Ehether the
joystick is in io mode or not is invisible but this state can be
cleared either through reset or by re-writing the gegister with
joystick type not equal to 111. Recovery time for a normal joystick
read after leaving I/O Mode is at most 64 scan lines.

@node NODE120


@{h4}Video Modes

The video mode can only be changed during the boot process so one
initial read is required of this register during software start up
phase.

The machine timing is identical for the seven VGA modes although the
physical refresh rate of the video output speeds up for each mode in
turn by roughly 1Hz. The internal timing of the machine remains
constant and as close to the original hardware as possible. VGA is a
perfect Amstrad ZX Spectrum 128k +3 for example as far as timing is
concerned across the seven VGA modes.

The effect of this speed up means that mode 0 will execute in one
second of time whereas mode 6 will execute in a shorter time
period. Mode 0 is as close to 50/60 Hz as possible where mode 6 is
closer to 60/70 Hz. That would mean that one second of machine time
for mode 6 will execute in 0.83 seconds of human time when running 50
frames per second at 60Hz.

The eighth mode (mode 7) is used for HDMI timing. Machine
configuration is forced for this mode. Line counts, Ts and various
other settings are set to meet the rigid HDMI timing
specification. For mode 7, 50/60 Hz are rock solid but the original
hardware timing loses Ts across all machines to meet HDMI display
requirements.

Software that was previously written for specific hardware with
hard-coded software timing loops may fail. This is one of the risks of
coding timing loops counting Ts. We saw evidence of this with the
release of the 1985 Sinclair ZX Spectrum 128k+ and the later Amstrad
models as previous software written for the ZX Spectrum 48k/48k+ would
fail when trying to display colour attribute and border effects as the
number of Ts per line was changed from 224Ts (1982 original 48k) to
228Ts (128k models). The ZX Spectrum Next runs slower in HDMI
mode. Demos may fail to display correctly and games may slow down
although setting the Z80 to 7Mhz can solve the game slow down, demos
should be run in VGA mode for maximum compatibility.

Video timing also affects audio output as the sample rate can vary
depending on the output timing method.

The following register allows software to read the video timing mode:

Register (R/W) $11 (11) => Video Timing (writable in config mode only)

bits 7-3 = Reserved, must be 0
bits 2-0 = Mode (VGA = 0..6, HDMI = 7)

* 000 = Base VGA timing, clk28 = 28000000

* 001 = VGA setting 1, clk28 = 28571429

* 010 = VGA setting 2, clk28 = 29464286

* 011 = VGA setting 3, clk28 = 30000000

* 100 = VGA setting 4, clk28 = 31000000

* 101 = VGA setting 5, clk28 = 32000000

* 110 = VGA setting 6, clk28 = 33000000

* 111 = HDMI, clk28 = 27000000

&nbsp;50/60Hz selection depends on bit 2 of register $05
&nbsp;Only writable in config mode

@node NODE121


@{h4}Machine Type

The machine type register can be used to provide the number of Ts per
line, line count, dot clock and maximum horizontal COPPER wait.

The dot clock (DC) is the number of Ts per line * 4.

The maximum horizontal COPPER wait (H) is in multiples of 16 clocks.

Video mode 7 (HMDI) overrides the timing.

The following list shows the various parameters that can be gained
from reading the machine register combined with the refresh register
and video mode bits:

Register (R/W) $03 (03) => Machine Type

A write to this register disables the boot rom in config mode

bits 2-0 select machine type when in config mode

bit 7 = (W) Display Timing change enable (allow changes to
bits 6-4) (0 on hard reset)
bits 6-4 = Display Timing
bit 3 = Display Timing user lock control
&nbsp;Read

* 0 = No user lock on display timing

* 1 = User lock on display timing

&nbsp;Write

* 1 = Apply user lock on display timing (0 on hard reset)

bits 2-0 = Machine Type (config mode only)

determines roms loaded
&nbsp;Machine Types/Display Timings

* 000 or 001 = ZX 48K

* 010 = ZX 128K/+2 (Grey)

* 011 = ZX +2A-B/+3e/Next Native

* 100 = Pentagon 128K

@node NODE122


@{h4}Summary

Table 5.13 provides a full list of video timing configuration
data:


------------------------------------------
@node NODE123


@{h1}Interrupts


------------------------------------------
Subsections

@{ "Interrupt Types" LINK NODE124 }

* 
@{ "<!-- MATH $\overline{\hbox{RESET}}$ --><SPAN CLASS="MATH"><IMG STYLE="" SRC="img4.svg" ALT="$\overline {\hbox {RESET}}$"></SPAN>" LINK NODE125 }

* 
@{ "<!-- MATH $\overline{\hbox{NMI}}$ --><SPAN CLASS="MATH"><IMG STYLE="" SRC="img5.svg" ALT="$\overline {\hbox {NMI}}$"></SPAN>" LINK NODE126 }

* 
@{ "<!-- MATH $\overline{\hbox{INT}}$ --><SPAN CLASS="MATH"><IMG STYLE="" SRC="img6.svg" ALT="$\overline {\hbox {INT}}$"></SPAN>" LINK NODE127 }

@{ "Interrupt Modes" LINK NODE128 }

* @{ "IM0" LINK NODE129 }

* @{ "IM1" LINK NODE130 }

* @{ "IM2" LINK NODE131 }

@{ "Z80 CTC" LINK NODE132 }

* @{ "Programming" LINK NODE133 }


------------------------------------------
@node NODE124


@{h1}Interrupt Types

The Z80 has three different hardware interrupt signals:
[<!-- MATH]

$\overline{\hbox{RESET}}$
-->
img4.svg"
ALT="$\overline {\hbox {RESET}}$">, <!-- MATH
$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$">, and <!-- MATH
$\overline{\hbox{INT}}$
-->
img6.svg"
ALT="$\overline {\hbox {INT}}$">.


------------------------------------------
Subsections

* ** 

@{ "<!-- MATH $\overline{\hbox{RESET}}$ --><SPAN CLASS="MATH"><IMG STYLE="" SRC="img4.svg" ALT="$\overline {\hbox {RESET}}$"></SPAN>" LINK NODE125 }

** 
@{ "<!-- MATH $\overline{\hbox{NMI}}$ --><SPAN CLASS="MATH"><IMG STYLE="" SRC="img5.svg" ALT="$\overline {\hbox {NMI}}$"></SPAN>" LINK NODE126 }

** 
@{ "<!-- MATH $\overline{\hbox{INT}}$ --><SPAN CLASS="MATH"><IMG STYLE="" SRC="img6.svg" ALT="$\overline {\hbox {INT}}$"></SPAN>" LINK NODE127 }


------------------------------------------
@node NODE125


@{h4}[<!-- MATH]

$\overline{\hbox{RESET}}$
-->
img4.svg"
ALT="$\overline {\hbox {RESET}}$">

[<!-- MATH]

$\overline{\hbox{RESET}}$
-->
img4.svg"
ALT="$\overline {\hbox {RESET}}$"> is used to return the CPU to a known state. When
the <!-- MATH
$\overline{\hbox{RESET}}$
-->
img4.svg"
ALT="$\overline {\hbox {RESET}}$"> line is pulled low, a <!-- MATH
$\overline{\hbox{RESET}}$
-->
img4.svg"
ALT="$\overline {\hbox {RESET}}$"> is
generated. The CPU then does several things. I, and R are set to $00.
PC is set to $0000. SP becomes $FFFF. A and F are set to $FF.  The
interrupt mode is set to 0. And (maskable) interrupts are disabled by
clearing IFF1 and IFF2.


------------------------------------------
@node NODE126


@{h4}[<!-- MATH]

$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$">

[<!-- MATH]

$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$"> is the non-maskable interrupt. Upon receiving a
non-maskable interrupt (<!-- MATH
$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$"> being pulled low) one of
two sequences occur depending on the calue of bit 3 of the interrupt
control register (nextreg $C0).

Register (R/W) $C0 (C0) => Interrupt Control (3.01.09)
($00 on reset)

* bits 7-5 = Programmable portion of IM2 vector *

* bit 4 = Reserved, must be 0

* bit 3 = Enable stackless <!-- MATH
$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$"> response

* bits 2-1 = Reserved, must be 0

* bit 0 = Maskable interrupt mode
&nbsp;0 - pulse
&nbsp;1 - IM2

* In IM2 mode vector generated is:

* bits 7-5 = nextreg $C0 bits 7-5

* bits 4-1 = Interrupt source
&nbsp;0 - line interrupt (highest priority)
&nbsp;1 - UART 0 Rx
&nbsp;2 - UART 1 Rx
&nbsp;3&ndash;10 - CTC channels 0-7
&nbsp;11 - ULA
&nbsp;12 - UART 0 Tx
&nbsp;13 - UART 1 Tx (lowest priority)

* bit 0 = 0

If bit 3 is clear (0) PC is pushed on the stack, IFF1 is copied to
IFF2, IFF1 is cleared (inhibiting maskable interrupts). The
[<!-- MATH]

$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$"> should end with RETN which copies the contents of
IFF2 to IFF1 (returning the interrupt state to what it was before the
[<!-- MATH]

$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$">) and PC is popped off the stack.

If bit 3 is set (1) PC is stored in the <!-- MATH
$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$"> return
address registers (nextregs $C2 and $C3), IFF1 is copied to IFF2,
IFF1 is cleared (inhibiting maskable interrupts). The
[<!-- MATH]

$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$"> should end with RETN which copies the contents of
IFF2 to IFF1 (returning the interrupt state to what it was before the
[<!-- MATH]

$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$">) and PC is compied from the <!-- MATH
$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$">
return address registers.

Register (R/W) $C2 (C2) => <!-- MATH
$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$"> Return Address LSB (3.01.09)
($00 on reset)

Register (R/W) $C3 (C3) => <!-- MATH
$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$"> Return Address MSB (3.01.09)
($00 on reset)

@node NODE127


@{h4}[<!-- MATH]

$\overline{\hbox{INT}}$
-->
img6.svg"
ALT="$\overline {\hbox {INT}}$">

The interrupt generally of most interest to programmers is
[<!-- MATH]

$\overline{\hbox{INT}}$
-->
img6.svg"
ALT="$\overline {\hbox {INT}}$">. So much so that if programmers talk about
interrupts on the Z80, they are probebly only talking about
[<!-- MATH]

$\overline{\hbox{INT}}$
-->
img6.svg"
ALT="$\overline {\hbox {INT}}$">. The processing of <!-- MATH
$\overline{\hbox{INT}}$
-->
img6.svg"
ALT="$\overline {\hbox {INT}}$"> is controlled
by IFF1 and IFF2 which are set using EI to enable interrupts and reset
using DI to disable interrupts. Interrupts can happen at any time and
should preserve register contents.  If none of your code uses the
alternate registers the EXX and EX AF,AF’ instructions can make this
faster and easier. Interrupt routined should end with EI and RETI to
reenable interrupts, potentially inform the interrupting device that
its interrupt has been serviced, and return from the interrupt
routine. In general the Spectrum machines do not make any distingtion
between RET and RETI, but future developments in the ZX Spectrum Next
may make the distinction important.

The ZX Spectrum Next has 14 internal sources for <!-- MATH
$\overline{\hbox{INT}}$
-->
img6.svg"
ALT="$\overline {\hbox {INT}}$">
signals. This can be enabled and disabled using nextregs $C4 &ndash;
$C6. Which signals have been received can be read/cleared using
nexregs $C8 &ndash; $CA.

Interrupt Enable

Register (R/W) $C4 (C4) => Interrupt Enable 0 (3.01.08)
($83 on reset)

* bit 7 = Expansion bus <!-- MATH
$\overline{\hbox{INT}}$
-->
img6.svg"
ALT="$\overline {\hbox {INT}}$">

* bits 6-2 = Reserved must be zero

* bit 1 = Line

* bit 0 = ULA

Register (R/W) $C5 (C5) => Interrupt Enable 1 (3.01.08)
($00 on reset)

* bit 7 = ctc channel 7 zc/to

* bit 6 = ctc channel 6 zc/to

* bit 5 = ctc channel 5 zc/to

* bit 4 = ctc channel 4 zc/to

* bit 3 = ctc channel 3 zc/to

* bit 2 = ctc channel 2 zc/to

* bit 1 = ctc channel 1 zc/to

* bit 0 = ctc channel 0 zc/to

Register (W) $C6 (C6) => Interrupt Enable 2 (3.01.08)
($00 on reset)

* bit 7 = Reserved, must be 0

* bit 6 = UART1 Tx empty

* bit 5 = UART1 Rx half full *

* bit 4 = UART1 Rx available *

* bit 3 = Reserved, must be 0

* bit 2 = UART0 Tx empty

* bit 1 = UART0 Rx half full *

* bit 0 = UART0 Rx available *

* For each UART, Rx half full and Rx available are shared interrupts

Interupt Status

Register (R/W) $C8 (C8) => Interrupt Status 0 (3.01.09)
($00 on reset)

* bits 7-2 = Reserved, must be zero

* bit 1 = Line

* bit 0 = ULA

* Set bits indicate the device generated an interrupt in the past
* Writes clear bits where bits are set except in IM2 mode

Register (R/W) $C9 (C9) => Interrupt Status 1 (3.01.09)

* bit 7 = ctc channel 7 zc/to

* bit 6 = ctc channel 6 zc/to

* bit 5 = ctc channel 5 zc/to

* bit 4 = ctc channel 4 zc/to

* bit 3 = ctc channel 3 zc/to

* bit 2 = ctc channel 2 zc/to

* bit 1 = ctc channel 1 zc/to

* bit 0 = ctc channel 0 zc/to

* Set bits indicate the device generated an interrupt in the past
* Writes clear bits where bits are set except in IM2 mode

Register (R/W) $CA (CA) => Interrupt Status 2 (3.01.09)
($00 on reset)

* bit 7 = Reserved, must be zero

* bit 6 = UART1 Tx empty

* bit 5 = UART1 Rx almost full *

* bit 4 = UART1 Rx available *

* bit 3 = Reserved must be zero

* bit 2 = UART0 Tx empty

* bit 1 = UART0 Rx almost full *

* bit 0 = UART0 Rx available *

* For each UART Rx half full and Rx available are shared interrupts
** Set bits indicate the device generated an interrupt in the past
** Writes clear bits where bits are set except in IM2 mode

Internal Interrupt Sources
&nbsp;0 = Line (highest priority)
&nbsp;1 = UART 0 Rx
&nbsp;2 = UART 1 Rx
&nbsp;3-10 = CTC channels 0-7
&nbsp;11 = ULA
&nbsp;12 = UART 0 Tx
&nbsp;13 = UART 1 Tx (lowest priority)

@node NODE128


@{h1}Interrupt Modes


------------------------------------------
Subsections

* ** 
@{ "IM0" LINK NODE129 }

** @{ "IM1" LINK NODE130 }

** @{ "IM2" LINK NODE131 }


------------------------------------------
@node NODE129


@{h4}IM0

When an interrupt is received by the CPU it disables interrupts and
executes the instruction placed on the bus by the interrupting device
and (no known use on the Next) It is enabled with the IM0 instruction
and enabling interrupts (EI).


------------------------------------------
@node NODE130


@{h4}IM1

When an interrupt is received, the CPU disables interrupts and jumps
to an interrupt handler at $0038 (normally in ROM). The ROM interrupt
handler updates the frame counter and scans the keyboard. This is the
default interrupt handling method for the ZX Spectrum and is probably
the method to use if you don’t need the ROMs for anything. It is
enabled using the IM1 instruction and enabling interrupts.


------------------------------------------
@node NODE131


@{h4}IM2

The ZX Spectrum Next has both a legacy method for handling IM2 and an
updated one which makes better use of the capabilities of IM2 which
was added in Core 3.01.09.

The ZX Spectrum Next has 14 interrupt devices which can all be given
independent interrupt vectors when using IM2. These interrupts are
controlled by nextregs $C0 &ndash; $CF.  The address of the vector for a
given interrupt is created by composing the I register (bits 15-0),
nextreg $C0 bits 7-5 (bits 7-5) and the interrupt number of the
interrupt device (bits 4-1). This means that even if you use all 14
internal interrupt sources, your interrupt vector table is no more
than 28 bytes which can be at any 32 byte boundry. It also means that
far less processing has to be done on interrupts which are
received. External interrupts are a little different. If no vector is
supplied by a device the implied LSB will be $FF.

While in IM2 mode, it is possible for interrupts to interrupt DMA
transfers. This capability is controlled by The DMA Interrupt enable
registers (nextregs $CC &ndash; $CE). When DMA is interrupted, one
instruction of the main program will be processed, then the interrupt
will be taken. On return, DMA will continue.

Register (R/W) $CC (CC) => DMA Interrupt Enable 0 (3.01.09)
($00 on reset)

* bits 7-2 = Reserved, must be 0

* bit 1 = Line

* bit 0 = ULA

* Set bits indicate the specified interrupt will interrupt a DMA
operation when in IM2 mode

Register (R/W) $CD (CD) => DMA Interrupt Enable 1 (3.01.09)
($00 on reset)

* bit 7 = CTC channel 7 zc/to

* bit 6 = CTC channel 6 zc/to

* bit 5 = CTC channel 5 zc/to

* bit 4 = CTC channel 4 zc/to

* bit 3 = CTC channel 3 zc/to

* bit 2 = CTC channel 2 zc/to

* bit 1 = CTC channel 1 zc/to

* bit 0 = CTC channel 0 zc/to

* Set bits indicate the corresponding interrupt will interrupt a DMA
operation when in IM2 mode

Register (R/W) $CE (CE) => DMA Interrupt Enable 2 (3.01.09)
($00 on reset)

* bit 7 = Reserved, must be 0

* bit 6 = UART1 Tx empty

* bit 5 = UART1 Rx half full

* bit 4 = UART1 Rx available

* bit 3 = Reserved, must be 0

* bit 2 = UART0 Tx empty

* bit 1 = UART0 Tx half full

* bit 0 = UART0 Tx available

* Set bits indicate the corresponding interrupt will interrupt a DMA
operation when in IM2 mode.

In legacy mode, when the CPU receives an interrupt it disables
interrupts and jumps to an interrupt routine starting at the contents
of the jump table at I. The start of the interrupt routine is the
contents of I*$100+bus and I*$100+bus+1. Most devices that can
supply interrupts on the ZX Spectrum leave the data bus in a floating
state.  As a result the interpreted state of the data bus while
generally $FF is not entirely predictable.  The solution to place
your interrupt routine at an address where the MSB and LSB are the
same ($0101, $0202, … $FFFF) then place 257 copies of that value in
a block starting at I*$100 (you can set the value of the I register).

Code:

;; my program
org $8000
;; enable interrupt mode im2
ld i,$fe
im2
ei
;; program body
;; interrupt routine
handler:
;; preserve registers used
;; handle interrupt
;; restore registers
ei
reti
;; jump to interrupt routine
org $fdfd
jp handler
;; im2 jump table
org $fe00 ; not actually legal
defs $101,$fd

@node NODE132


@{h1}Z80 CTC

(3.01.08) Untested, assuming it acts like two Z80 CTCs.

Eight independent CTC channels are available on ports $183B through
$1F3B.  These perform counter/timer functions that can be used to
generate timer interrupts or to generate interrupts from physical
signals.

The CTC is a standard Zilog part.  Its datasheet can be found at
http://www.zilog.com/docs/z80/ps0181.pdf .  The Zilog documentation is
ambiguous around how soft resets are treated so the following
clarifies some points in the Next's implementation.

Hard reset requires both a control word and a time constant to
be written to a channel even if bit 2 = 0 in the first control word.

Soft reset with bit 2 = 0 causes the entire control register to
be modified.  Soft reset with bit 2 = 1 does not change the control
register contents.  In both cases a time constant must follow to
resume operation.

Changing the trigger edge selection in bit 4 while the channel
is in operation counts as a clock edge.  A pending timer trigger
will be fired and, in counter mode, an edge will be received.

ZC/TO is asserted for one clock cycle and not for the entire
duration that the count is at zero.

At the moment, any interrupt generated by the CTC will assert the
z80's /INT line for 32 cpu cycles.  This is the same way that the ULA
and line interrupts operate.

At the moment, the ZC/TO output of each channel is fed into the
CLK/TRG input of the succeeding channel so that time and count periods
can be cascaded.


------------------------------------------
Subsections

* ** 
@{ "Programming" LINK NODE133 }

@node NODE133


@{h4}Programming

Initial values are set by a write of a channel control word followed
by a time constant. In timer mode, the counter decrements every time
it is triggered. In counter mode it decrements every time the
prescaler counter reaches zero.

Channel Control Word
&nbsp;bit 7 = Enable Interrupt
&nbsp;bit 6 = Mode

* 0 = Timer mode

* 1 = Counter mode

&nbsp;bit 5 = Prescalar value (Timer mode only)

* 0 = 16

* 1 = 256

&nbsp;bit 4 = CLK/TRG edge selection

* 0 = Falling Edge

* 1 = Rising Edge

&nbsp;bit 3 = Timer Trigger (Timer mode only)

* 0 = Starts on loading of time constant

* 1 = Starts on CLK/TRG

&nbsp;bit 2 = Time constant follows
&nbsp;bit 1 = Software reset
&nbsp;bit 0 = 0 (Control Word)

If we are running at 28MHz (Mode 0) and wish to trigger an interrupt
every 1 sec, that is 28 million T-States/cycles we could program CTC 5
as a counter with a prescalar of 16 and a period of 175, CTC 6 as a
counter with a prescalar of 16 and a period of 125, and CTC 7 as a
timer with a period of 5.

CTC 5 triggers ZC5 every 280 cycles or 10 usec.

CTC 6 triggers ZC6 every 560,000 cycles or 20 msec.

CTC 7 triggers ZC7 and an interrupt every 28,000,000 cycles or 1 sec.

di
; set up interrupt routine
im 2
ld bc,$183B     ; CTC 0
ld hl,$FFFA     ; address pointing to start of interrupt routine
ld de,interrupt ; start of interrupt routine
ld (hl),de
ld i,$FF
ld a,l          ; Vector to address at on this interrupt
out (c),a
; set up CTC 5
ld b,$1D        ; CTC 5
ld a,$87
out (c),a       ; Interrupt mode, timer mode, time constant, soft, control
ld a,$05
out (c),a       ; once every 5 times 
; set up CTC 6
inc b           ; CTC 6
ld a,$47
out (c),a       ; 16x, counter mode, time constant, soft, control
ld a,$7D        ; 125 = once every 2000 times
out (c),a
; set up CTC 7
inc b           ; CTC 7
ld a,$47
out (c),a       ; 16x, counter mode, time constant, soft, control
ld a,$AF        ; 175 = once every 2800 times
ei

@node NODE134


@{h1}Serial Communication

The Spectrum Next has two independent fully featured UARTs. The UARTS
share I/O ports so it is important to select the correct one before
communicating with it. Each has its own 64 byte Tx buffer and 512 byte
Rx buffer. One UART can be connected to either the ESP of joystick
port while the other can be connected to the Raspberry Pi accelerator
or joystick port. The UARTS are controlled using ports $37, $133B,
$143B, $153B, and $163B. The UARTs are connected to the IM2
interrupt system.  Nextreg $c6 allows interrupts to be enabled for
the status of each UART. UART interrupts correspond to interrupts 1,
2, 12, and 13 (see Interrupts).

Port $37 (37) Kempston/Mega Drive Joystick 2

Read
&nbsp;bit 7 = &rdquo;start&rdquo; button
&nbsp;bit 6 = A/X button
&nbsp;bit 5 = C/Z button
&nbsp;bit 4 = Fire/C/Y button
&nbsp;bit 3 = Up
&nbsp;bit 2 = Down
&nbsp;bit 1 = Left
&nbsp;bit 0 = Right

Disable with Nextreg $05

Write ($00 on reset, 3.01.04)
&nbsp;bits 7-6 = Select I/O Mode
&nbsp;00 = Bit Bang

&nbsp;01 = Clock

&nbsp;10 = UART

&nbsp;11 = Reserved (don't use)

&nbsp;bit 5 = Reserved, must be 0
&nbsp;bit 4 = Select Joystick Port for Read
&nbsp;0 = Left

&nbsp;1 = Right

&nbsp;bits 3-1 = Reserved, must be $00
&nbsp;bit 0 = Pin 7 state (both ports)

* Bit Bang - bit 0 on pin 7

* Clock - clock on pin 7

0 = Slow clock (Fsys/2048 = 12.672 kHz)

1 = Fast clock (Fsys/8 = 3.5 MHz)

* UART - Pin 7 = TX, Pin 9 = RX
0 = ESP

1 = Pi

** A Runt clock may appear in the first cycle

The I/O mode should be set by writing this port first followed by
enabling io mo de on the joysticks with a write to nextreg 0x05.

Port $133B (133B) UART tx

Read: UART Status
&nbsp;bits 7-4 = Reserved (0)
&nbsp;bit 3 = UART at least half full (3.01.09)
&nbsp;bit 2 = UART full
&nbsp;bit 1 = UART transmit busy
&nbsp;bit 0 = UART receive has data

Write: UART Transmit

Port $143B (143B) UART rx

Read: UART Receive

Write: UART Prescalar
&nbsp;bit 7 = select prescalar part
&nbsp;0 = Bits 6-0 of prescalar

&nbsp;1 = Bits 13-7 of prescalar

&nbsp;bits 6-0 = Prescalar bits

Port $153B (153B) UART select
&nbsp;bit 7 = Reserved (0)
&nbsp;bit 6 = UART select (0 on soft reset) **
&nbsp;0 = ESP

&nbsp;1 = Pi *

&nbsp;bit 5 = Reserved (0)
&nbsp;bit 4 = Prescalar valid in this write
&nbsp;bit 3 = Reserved (0)
&nbsp;bits 2-0 = Bits 16-14 of prescalar (0 on hard reset)

* Pi GPIO must be configured for UART, see nextreg $A0
** Either UART can be redirected to the joystick ports, see port $037

Port $153B (153B) UART frame (upcoming)
($18 on hard reset)
&nbsp;bit 7 = Immediately reset Rx and Tx to idle and empty FIFOs
&nbsp;bit 6 = Assert break (Tx=0) when Tx reaches idle
&nbsp;bit 5 = Enable hardware flow control *
&nbsp;bits 4-3 = Number of bits in a frame
&nbsp;00 = 5 bits

&nbsp;01 = 6 bits

&nbsp;10 = 7 bits

&nbsp;11 = 8 bits

&nbsp;bit 2 = Enable parity
&nbsp;bit 1 = Parity
&nbsp;0 = Even parity

&nbsp;1 = Odd parity

&nbsp;bit 0 = Number of stop bits
&nbsp;0 = 1 stop bit

&nbsp;1 = 2 stop bits

Register (R/W) $C0 (C0) => Interrupt Control (3.01.09)
($00 on reset)

* bits 7-5 = Programmable portion of IM2 vector *

* bit 4 = Reserved, must be 0

* bit 3 = Enable stackless <!-- MATH
$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$"> response

* bits 2-1 = Reserved, must be 0

* bit 0 = Maskable interrupt mode
&nbsp;0 - pulse
&nbsp;1 - IM2

* In IM2 mode vector generated is:

* bits 7-5 = nextreg $C0 bits 7-5

* bits 4-1 = Interrupt source
&nbsp;0 - line interrupt (highest priority)
&nbsp;1 - UART 0 Rx
&nbsp;2 - UART 1 Rx
&nbsp;3&ndash;10 - CTC channels 0-7
&nbsp;11 - ULA
&nbsp;12 - UART 0 Tx
&nbsp;13 - UART 1 Tx (lowest priority)

* bit 0 = 0

Register (W) $C6 (C6) => Interrupt Enable 2 (3.01.08)
($00 on reset)

* bit 7 = Reserved, must be 0

* bit 6 = UART1 Tx empty

* bit 5 = UART1 Rx half full *

* bit 4 = UART1 Rx available *

* bit 3 = Reserved, must be 0

* bit 2 = UART0 Tx empty

* bit 1 = UART0 Rx half full *

* bit 0 = UART0 Rx available *

* For each UART, Rx half full and Rx available are shared interrupts

@node NODE135


@{h1}Raspberry Pi0 Acceleration

The Spectrum Next has a header (with male pins) which can be attached
to a Raspberry Pi Zero. There is a modified version of DietPi called
NextPi which is the standard distro for the Raspberry Pi0
accelerator. Software for the general public should be written
assuming that it will be interfacing with a Pi0 running this distro.

If you are more adventurous, you may choose to use another distro, or
even another accelerator that uses the Raspberry Pi style (40 pin)
expansion bus.  Chief concers when doing this is that you have a
console presented on the UART that defaults to 115,200 bps, you don't
need to login, the machine is configured with a driver to treat the
I2S interface as a sound card, and the presence of the nextpi
scripts.

The Raspberry Pi 0 has a Broadcom BCM2835 SoC with an ARMv6 core, a
Videocore 4 GPU, and its own 512 MB memory and HDMI output. It has its
own SD card from which it boots. For this application the Pi 0 ships
with a 1GB microSD card containing NextPi a customized version of
DietPi.

The Pi Zero, if installed, is a smart peripheral for the ZX Spectrum
Next. Available interfaces are: low level access to the GPIO pins,
higher level access to standardized I/O interfaces, and use of the Pi
Zero as a sound card.

When using the low level GPIO interface Pi Zero GPIO pins 2-27 can be
configured as either inputs or outputs using nextregs $90-$93. If
they are outputs, the output state can be set by writing to nextregs
$98-$9b. The current status of the GPIO pins can be read from
nextregs $98-$9b whether it is the state driven by the ZX Spectrum
Next or the state drive by some other peripherial attached to the bus
(normally the Raspberry Pi Zero).

Register (R/W) $90 (90) => Pi GPIO output enable 1/4

* bit 7 = Enable Pin 7 (0 on reset)

* bit 6 = Enable Pin 6 (0 on reset)

* bit 5 = Enable Pin 5 (0 on reset)

* bit 4 = Enable Pin 4 (0 on reset)

* bit 3 = Enable Pin 3 (0 on reset)

* bit 2 = Enable Pin 2 (0 on reset)

* bit 1 = Enable Pin 1 (cannot be enabled) (0 on reset)

* bit 0 = Enable Pin 0 (cannot be enabled) (0 on reset)

Register (R/W) $91 (91) => Pi GPIO output enable 2/4

* bit 7 = Enable Pin 15 (0 on reset)

* bit 6 = Enable Pin 14 (0 on reset)

* bit 5 = Enable Pin 13 (0 on reset)

* bit 4 = Enable Pin 12 (0 on reset)

* bit 3 = Enable Pin 11 (0 on reset)

* bit 2 = Enable Pin 10 (0 on reset)

* bit 1 = Enable Pin 9 (0 on reset)

* bit 0 = Enable Pin 8 (0 on reset)

Register (R/W) $92 (92) => Pi GPIO output enable 3/4

* bit 7 = Enable Pin 23 (0 on reset)

* bit 6 = Enable Pin 22 (0 on reset)

* bit 5 = Enable Pin 21 (0 on reset)

* bit 4 = Enable Pin 20 (0 on reset)

* bit 3 = Enable Pin 19 (0 on reset)

* bit 2 = Enable Pin 18 (0 on reset)

* bit 1 = Enable Pin 17 (0 on reset)

* bit 0 = Enable Pin 16 (0 on reset)

Register (R/W) $93 (93) => Pi GPIO output enable 4/4

* bits 7-4 = Reserved

* bit 3 = Enable Pin 27 (0 on reset)

* bit 2 = Enable Pin 26 (0 on reset)

* bit 1 = Enable Pin 25 (0 on reset)

* bit 0 = Enable Pin 24 (0 on reset)

Register (R/W) $98 (98) => Pi GPIO Pin State 1/4

* bit 7 = Pin 7 Data (1 on reset)

* bit 6 = Pin 6 Data (1 on reset)

* bit 5 = Pin 5 Data (1 on reset)

* bit 4 = Pin 4 Data (1 on reset)

* bit 3 = Pin 3 Data (1 on reset)

* bit 2 = Pin 2 Data (1 on reset)

* bit 1 = Pin 1 Data (1 on reset)

* bit 0 = Pin 0 Data (1 on reset)

Register (R/W) $99 (99) => Pi GPIO Pin State 2/4

* bit 7 = Pin 15 Data (1 on reset)

* bit 6 = Pin 14 Data (1 on reset)

* bit 5 = Pin 13 Data (1 on reset)

* bit 4 = Pin 12 Data (1 on reset)

* bit 3 = Pin 11 Data (1 on reset)

* bit 2 = Pin 10 Data (1 on reset)

* bit 1 = Pin 9 Data (1 on reset)

* bit 0 = Pin 8 Data (1 on reset)

Register (R/W) $9A (9A) => Pi GPIO Pin State 3/4

* bit 7 = Pin 23 Data (1 on reset)

* bit 6 = Pin 22 Data (1 on reset)

* bit 5 = Pin 21 Data (1 on reset)

* bit 4 = Pin 20 Data (1 on reset)

* bit 3 = Pin 19 Data (1 on reset)

* bit 2 = Pin 18 Data (1 on reset)

* bit 1 = Pin 17 Data (1 on reset)

* bit 0 = Pin 16 Data (1 on reset)

Register (R/W) $9B (9B) => Pi GPIO Pin State 4/4

* bits 7-4 = Reserved

* bit 3 = Pin 27 Data (1 on reset)

* bit 2 = Pin 26 Data (1 on reset)

* bit 1 = Pin 25 Data (1 on reset)

* bit 0 = Pin 24 Data (1 on reset)

Standardized I/O access with the Pi Zero can use the  I2C , SPI, or
UART interfaces and is configured using nextreg $a0. Any enabled port
will disable low level (write) access to the corresponding GPIO
pins.

Register (R/W) $A0 (A0) => Pi Peripheral Enable

* bits 7-6 = Reserved, must be 0

* bit 5 = Enable UART on GPIO 14, 15 (0 on reset)*

* bit 4 = Communication Type (0 on reset)

** 0 = Rx to GPIO 15, Tx to GPIO 14 (Pi)

** 1 = Rx to GPIO 14, Tx to GPIO 15 (Pi Hats)

* bit 3 = Enable  I2C on GPIO 2, 3 (0 on reset)*

* bits 2-1 = Reserved, must be 0

* bit 0 = Enable SPI on GPIO 7, 8, 9, 10, 11 (0 on reset)*

*Overrides GPIO Enables

The  I2C interface is controlled using ports $103b (SCL) and $113b
(SDA). This is the same  I2C interface that is used for the optional
Real Time Clock. Interfacing with the Pi Zero over  I2C is
complicated by the fact that it is a master/slave interface, but both
the ZX Spectrum Next and Pi Zero are configured to be bus masters.

Port $103B (103B)  I2C SCL (rtc, rpi)

Port $113B (113B)  I2C SDA (rtc, rpi)

The SPI interface is controlled using ports $e7 (/CS) and $eb
(/DATA). The SPI interface is shared between the SD card(s), the flash
memory, and the Pi Zero. Interfacing with the Pi Zero over SPI is
complicated by the fact it is a master/slave interface and both the ZX
Spectrum Next and Pi Zero are configured to be bus masters.

Port $E7 (E7) SPI <!-- MATH
$\overline{\hbox{CS}}$
-->
img56.svg"
ALT="$\overline{\hbox{CS}}$"> (SD card, flash, rpi)

Disable with bit 2 of Nextreg $09

Port $EB (EB) SPI <!-- MATH
$\overline{\hbox{DATA}}$
-->
img57.svg"
ALT="$\overline{\hbox{DATA}}$"> (SD card, flash, rpi)

Disable with bit 2 of Nextreg $09

The default means of communication between the ZX Next and the Pi is
through the UART interface (see serial communications chapter). In
order to communicate withe the Pi the Pi UART must be connected to the
Pi by setting nextreg $a0 bits 5 and 4 to 1, selecting the Pi UART by
setting port $153b bit 6 to 1 and ensuring that both ends are using
matching communication protocols (by default 115,200 bps, 8N1 and no
flow control). On the Pi end the UART is connected to the serial
console.

;; enable UART connection with Pi Zero
ld c,$3b
ld b,$15 ; UART control
;; select Pi on UART control
in a,(c)
or $40
out (c),a
ld b,$24 ; Next Register Select
ld a,$a0
out (c),a
inc b ; Next Register Data
;; Enable UART on GPIO and select Pi
in a,(c)
or $30
out (c),a

The  I2S sound interface between the ZX Spectrum Next and the Pi Zero
is controlled by nextregs $a2 and $a3. Normally, one would control
the Pi through some other channel such as the UART recieve audio from
the Pi to either use as a fulloy programmable sound card or to allow
loading of tape files on the ZX Spectrum Next.

Register (R/W) $A2 (A2) => Pi  I2S Audio Control

* bits 7-6 =  I2S State ($00 on reset)

** 00 =  I2S Disabled

** 01 =  I2S is mono, source R

** 10 =  I2S is mono, source L

** 11 =  I2S is stereo

* bit 5 = Reserved, must be 0

* bit 4 = Audio Flow Direction (0 on reset)

** 0 = PCM_DOUT to Pi, PCM_DIN from Pi (Hats)

** 1 = PCM_DOUT from Pi, PCM_DIN to Pi (Pi)

* bit 3 = Mute left (0 on reset)

* bit 2 = Mute right (0 on reset)

* bit 1 = Slave mode, Reserved must be 1 (remove in 3.01.05)

* bit 0 = Direct  I2S audio to EAR on port $FE (0 on reset)

Register (R/W) $A3 (A3) => Pi  I2S Clock Divide (Master Mode) (removed in 3.01.05)

* bits 7-0 = Clock divide value ($0B on reset)

[<!-- MATH]

$\hbox{Divider}=\frac{538461}{\hbox{Rate}}-1$
-->
img58.svg"
ALT="$\hbox{Divider}=\frac{538461}{\hbox{Rate}}-1$"> or
[<!-- MATH]

$\hbox{Rate}=\frac{538461}{\hbox{Divider}+1}$
-->
img59.svg"
ALT="$\hbox{Rate}=\frac{538461}{\hbox{Divider}+1}$">

@node NODE136


@{h1}System Software


------------------------------------------
Subsections

@{ "CP/M" LINK NODE137 }

* @{ "Utilities" LINK NODE138 }

* @{ "BDOS" LINK NODE139 }

* @{ "BIOS" LINK NODE140 }

** @{ "System Initialization Functions" LINK NODE141 }

** @{ "Character I/O Functions" LINK NODE142 }

** @{ "Disk I/O Functions" LINK NODE143 }

* @{ "Memory Select and Move Functions" LINK NODE144 }

** @{ "Clock Support Function" LINK NODE145 }

@{ "NextZXOS" LINK NODE146 }

@{ "NextZXOS" LINK NODE147 }

* @{ "+3DOS compatible API" LINK NODE148 }

* @{ "esxDOS compatible API" LINK NODE149 }

* @{ "Next Extensions" LINK NODE150 }

* @{ "esxDOS compatible API" LINK NODE151 }


------------------------------------------
@node NODE137


@{h1}CP/M

The ZX Spextrum Next has support for CP/M+ 3.0. CP/M was the most
popular microcomputer coperating system prior to the advent of MS-DOS.


------------------------------------------
Subsections

@{ "Utilities" LINK NODE138 }

@{ "BDOS" LINK NODE139 }

@{ "BIOS" LINK NODE140 }

* @{ "System Initialization Functions" LINK NODE141 }

* @{ "Character I/O Functions" LINK NODE142 }

* @{ "Disk I/O Functions" LINK NODE143 }

@{ "Memory Select and Move Functions" LINK NODE144 }

* @{ "Clock Support Function" LINK NODE145 }


------------------------------------------
@node NODE138


@{h2}Utilities

From the Digital Research: CP/M 3 Command Reference Manual 1984

This section documents all standard CP/M+ 3 commands plus those extras
included with the ZX Spectrum Next CP/M system.

COLOURS

img60.svg"
ALT="\begin{labeledpar}{Parameters:}{\textbf{Syntax:}}
\textbf{COLOURS [RGB] \textit{paper} \textit{ink}}
\end{labeledpar}">

Function: Sets the screen colours

Parameters:

img61.svg"
ALT="\begin{labeledpar}{Parameters}{\textit{paper}}
Paper (background) colour
\end{labeledpar}">

img62.svg"
ALT="\begin{labeledpar}{Parameters:}{\textit{ink}}
Ink (foreground) colour
\end{labeledpar}">

Options:

img63.svg"
ALT="\begin{labeledpar}{Parameters:}{RGB}
Causes ink and paper colours to be interpreted as 9-bit octal RGB numbers
\end{labeledpar}">

Notes: Sets the screen colours using standard ZX colours
or octal 9-bit RGB numbers.

Examples:

colours 1 6

colours rgb 000 750

COPYSYS

img64.svg"
ALT="\begin{labeledpar}{Parameters:}{\textbf{Syntax:}}
\textbf{COPYSYS}
\end{labeledpar}">

Function: Copy CP/M system

Notes: COPYSYS copies the CP/M Plus system from a CP/M Plus
system diskette to another diskette.  The new diskette must have the
same format as the original system diskette.

DATE

img65.svg"
ALT="\begin{labeledpar}{Parameters:}{\textbf{Syntax:}}
\textbf{DATE}\\
\textbf{DATE ...
...
\textbf{DATE \textit{time-specification}}\\
\textbf{DATE SET}
\end{labeledpar}">

Function: The DATE command lets you display and set the date
and time of day.

Parameters:

img66.svg"
ALT="\begin{labeledpar}{Parameters}{\textit{time-specification}}
Time/date in the format MM/DD/YY HH:MM:SS
\end{labeledpar}">

Options:

img67.svg"
ALT="\begin{labeledpar}{Parameters:}{C}
Continuously show the date and time until a key is pressed
\end{labeledpar}">

img68.svg"
ALT="\begin{labeledpar}{Parameters:}{CONTINUOUS}
Continuously show the date and time until a key is pressed
\end{labeledpar}">

img69.svg"
ALT="\begin{labeledpar}{Parameters:}{SET}
Prompt the user for the current date and time
\end{labeledpar}">

Notes: The DATE command is a transient utility that lets you
display and set the date and time of day.  When you start CP/M 3, the
date and time are set to the creation date of your CP/M 3 system. Use
DATE to change this initial value to the current date and time.

Examples:

DATE

DATE C

DATE CONTINUOUS

DATE 08/13/82 09:15:37

DATE SET

DEVICE

=0.7cm Syntax:

DEVICE

DEVICE NAMES

DEVICE VALUES

DEVICE logical-dev {XONimg70.svg"
ALT="\(\vert\)">NOXONimg70.svg"
ALT="\(\vert\)">baud-rate},

DEVICE physical-dev {XONimg70.svg"
ALT="\(\vert\)">NOXONimg70.svg"
ALT="\(\vert\)">baud-rate}

DEVICE logical-dev=physical-dev {option} {,physical-dev {option},...}

DEVICE logical-dev = NULL

DEVICE CONSOLE {PAGE}

DEVICE CONSOLE {COLUMNS=n, LINES=n}

DEVICE displays current logical device assignments and physical device
names.

DIR (built-in)

=0.7cm Syntax:

DIR

DIR d:

DIR filespec

DIR d: options

DIR filespec,... filespec options

The DIR command displays the names of files catalogued in the
directory of an online disk that belong to current user number and
have the Directory (DIR) attribute. DIR accepts the * and ? wildcards
in the file specification.

The DIR command with options displays the names of files and the
characteristics associated with the files. DIR is a built-in
utility. DIR with options is a transient utility and must be loaded
into memory from the disk.

DIRSYS/DIRS (built-in)

=0.7cm Syntax:

DIRSYS

DIRSYS d:

DIRSYS filespec

The DIRSYS command lists the names of files in the current directory
that have the system (SYS) attribute. DIRSYS accept the * and ?
wildcards in the file specification. DIRSYS is a built-in utility.

DUMP

=0.7cm Syntax:

DUMP filespec

DUMP displays the contents of a file in and ASCII format.

ECHO (ZX Spectrum Next)

=0.7cm Syntax:

ECHO string

Echo characters to the terminal

The following special character sequences may be used

* \a alert (bell) (ASCII 7)

* \b backspace (ASCII 8)

* \e escape (ASCII 27)

* \n line feed (ASCII 10)

* \r carriage return (ASCII 13)

* \l interpret further characters as lower-case

* \u interpret further characters as upper-case

* \\backslash ('\')

Note that CP/M converts all your typed characters to upper-case before
providing them to ECHO.COM. Therefore you will need to use
\l and \u to specify the case of
characters if it is important (in ESCape sequences, for example).

ED

=0.7cm Syntax:

ED

ED input-filespec

ED input-filespec {d: img70.svg"
ALT="\(\vert\)"> output-filespec}

Character file editor. To redirect or rename the new version of the
file specify the destination drive or destination filespec.

ERASE/ERA (built-in)

=0.7cm Syntax:

ERASE

ERASE filespec

ERASE filespec [CONFIRM]

The ERASE command removes one or more files from the directory of a
disk. Wildcard characters are accepted in the filespec. Directory and
data space are automatically reclaimed for later use by another
file. The ERASE command can be abbreviated to ERA.

[CONFIRM] option informs the system to prompt for verification before
erasing each file that matches the filespec. CONFIRM can be
abbreviated to C.

EXIT (ZX Spectrum Next)

=0.7cm Syntax:

EXIT

The EXIT command leaves CP/M (rebooting the ZX Spectrum Next)

EXPORT (ZX Spectrum Next)

=0.7cm Syntax:

EXPORT cpm-filespec nextzxos-filespec

NextZXOS file export utility

Export file to a NextZXOS drive.

GENCOM

=0.7cm Syntax:

GENCOM COM-Eilespec RSX-filespec... RSX-Eilespec {[LOADER img70.svg"
ALT="\(\vert\)">
SCB=(Offset,value)]}

GENCOM RSX-filespec ... RSX-filespec {[NULL img70.svg"
ALT="\(\vert\)">
SCB=(Offset,value)l}

GENCOM filename

GENCOM filename [SCB=(offset,value)]

The GENCOM command attaches RSX files to a COM file, or creates a
dummy COM file containing only RSXS. It can also restore a previously
GENCOMed file to the original COM file without the header and RSXS,
add or replace RSXs in already GENCOMed files, and attach header
records to COM files without RSXS.

GENCPM

=0.7cm Syntax:

GENCPM {AUTOimg70.svg"
ALT="\(\vert\)">AUTO DISPLAY}

GENCPM creates a memory image CPM3.SYS file, containing the CP/M 3
BDOS and customized BIOS. The GENCPM utility performs late resolution
of intermodule references between system modules. GENCPM can accept
its command input interactively from the console or from a file
GENCPM.DAT.

In the nonbanked system, GENCPM creates a CPM3.SYS file from the
BDOS3.SPR and BIOS3.SPR files. In the banked system, GENCPM creates
the CPM3.SYS file from the RESBDOS3.SPR, the BNKBDOS3.SPR and the
BNKBIOS3.SPR files. Remember to back up your CPM3.SYS file before
executing GENCPM, because GENCPM deletes any existing CPM3.SYS file
before it generates a new system.

GET

=0.7cm Syntax:

GET {CONSOLE INPUT FROM} FILE filespec options

GET {CONSOLE INPUT FROM} CONSOLE

GET directs the system to take console input from a file for the next
system comand or user program entered at the console.

Console input is taken from a file until the program terminates. If
the file is exhausted before program input is terminated, the program
looks for subsequent input from the console. If the program terminates
before exhausting all its input, the system reverts back to the
console for console input.

HELP

=0.7cm Syntax:

HELP

HELP topic

HELP topic subtopic

HELP topic [NOPAGE]

HELP topic subtopic1...subtopic8

HELPimg71.svg"
ALT="\(&gt;\)">topic

HELPimg71.svg"
ALT="\(&gt;\)">.subtopic

HELP displays a list of topics and provides summarized information for
CP/M Plus commands.

Typing HELP topic displays information about that topic. Typing HELP
topic subtopic displays information about that subtopics One or two
letters is enough to identify the topics. After HELP displays
information for your topic, it displays the special prompt HELPimg71.svg"
ALT="\(&gt;\)">
on your screen, followed by a list of subtopics.

* Enter ? to display list of main topics.

* Enter a period and subtopic name to access subtopics.

* Enter a period to redisplay what you just read.

* Press RETURN to return to the CP/M Plus system prompt.

* [NOPAGE] option disables the 24 lines per page console display.

* Press any key to exit a display and return to the HELPimg71.svg"
ALT="\(&gt;\)"> prompt.

HEXCOM

=0.7cm Syntax:

HEXCOM filename

The HEXCOM Command generates a command file (filetype COM) from a HEX
input file. it names the output tile with the same filename as the
input file but with filetype COM. HEXCOM always looks for a file with
filetype HEX.

IMPORT (ZX Spectrum Next)

=0.7cm Syntax:

IMPORT nextzxos-filespec

IMPORT nextzxos-filespec cpm-filespec

NextZXOS file import utility

List or import files from a NextZXOS drive.

INITDIR (Not included)

=0.7cm Syntax:

INITDIR d:

The INITDIR command initializes a disk directory to allow date and
time stamping of files on that disk. INITDIR can also recover
time/date directory space.

NEXTREG (ZX Spectrum Next)

=0.7cm Syntax:

NEXTREG register {value}

NextReg Utility

Show or change a NextReg register (use at your own risk!)

LIB (Not included)

=0.7cm Syntax:

LIB filespec options

LIB filespec options=filespec img72.svg"
ALT="\(&lt;\)">modifierimg71.svg"
ALT="\(&gt;\)"> f,filespecimg72.svg"
ALT="\(&lt;\)">modifierimg71.svg"
ALT="\(&gt;\)">

A library is a file that contains a collection of object modules.

Use the LIB utility to create libraries, and to append, replace,
select, or delete modules from an existing library. Use LIB to obtain
information about the contents of library files.  LIB creates and
maintains library files that contain object modules in Microsoft REL
file format.  These modules are produced by the Digital Research
relocatable macro-assembler program, RMAC, or other language
translator that produces modules in Microsoft REL file format.

You can use LINK-80 to link the object modules contained in a library
to other object files.  LINK-80 automatically selects from the library
only those modules needed by the program being linked, and then forms
an executable file with a filetype of Com.

LINK (Not included)

=0.7cm Syntax:

LINK filespec [options]

LINK filespec [options],...filespec [options]

LINK filespec [options]=filespec [options],...

LINK combines relocatable object modules such as those produced by
RMAC and PL/I- 80 into a COM file ready for execution. Relocatable
files can contain external references and publics.  Relocatable files
can reference modules in library files. LINK searches the library
files and includes the referenced modules in the output file. See the
Programmer's Utilities Guide for the CP/M Family of Operating Systems
for a complete description of LINK-80.

Use LINK option switches to control execution parameters. Link options
follow the file specifications and are enclosed within square
brackets. Multiple switches are separated by commas.

MAC (Not included)

=0.7cm Syntax:

MAC filename [$options]

MAC, the CP/M Plus macro assembler, reads assembly language statements
from a file of type ASM, assembles the statements, and produces three
output files with the input filename and filetypes of HEX, PRN, and
SYM. Filename.HEX contains Intel hexadecimal format object
code. Filename.PRN contains an annotated source listing that you can
print or examine at the console. Filename.SYM contains a sorted list
of symbols defined in the program.

Use options to direct the input and output of MAC. Use a letter with
the option to indicate the source and destination drives, and console,
printer, or zero output. Valid drive names are A through 0. X, P, and
Z specify console, printer, and zero output, respectively.

PATCH

=0.7cm Syntax:

PATCH filename.typ n

The PATCH command displays or installs patch number n to the CP/M Plus
system or command files. The patch number n must be between 1 and 32
inclusive.

PIP

=0.7cm Syntax:

PIP Destination = Source

PIP d:[Gn]=filespec [options]

PIP filespec[Gn]=filespec [options]

PIP filespec[Gn]device=filespec [options] device

The file copy program PIP copies files, combines files, and transfers
files between disks, printers, consoles, or other devices attached to
your computer. The first filespec is the destination. The second
filespec is the source. Use two or more source filespecs separated by
commas to combine two or more files into one file. [options] is any
combination of the available options. The [Gn] option in the
destination filespec tells PIP to copy your file to that user
number. PIP with no command tail displays an * prompt and awaits your
series of commands, entered and processed one line at a time. The
source or destination can optionally be any CP/M Plus logical device.

PUT

=0.7cm Syntax:

PUT CONSOLE {OUTPUT TO} FILE filespec {option}

PUT PRINTER {OUTPUT TO} FILE filespec {option}

PUT CONSOLE {OUTPUT TO} CONSOLE

PUT PRINTER {OUTPUT TO} PRINTER

PUT puts console or printer output to a file for the next command
entered at the console, until the program terminates. Then console
output reverts to the console. Printer output is directed to a file
until the program terminates. Then printer output is put back to the
printer.

PUT with the SYSTEM option directs all subsequent console/printer
output to the specified file.  This option terminates when you enter
the PUT CONSOLE or PUT PRINTER command.

RENAME/REN (built-in)

=0.7cm Syntax:

RENAME

RENAME new-filespec=old-filespec

RENAME lets you change the name of a file in the directory of a
disk. To change several filenames in one command use the * or ?
wildcards in the file specifications. You can abbreviate the RENAME
command to REN. REN prompts you for input.

RMAC (Not included)

=0.7cm Syntax:

RMAC filespec options

RMAC, a relocatable macro assembler, assembles ASM files into REL
files that you can link to create COM files.

RMAC options specify the destination of the output files. Replace d
with the destination drive letter for the output files.

SAVE

=0.7cm Syntax:

SAVE

SAVE copies the contents of memory to a file. To use SAVE, first issue
the SAVE command, then run your program which reads a file into
memory. Your program exits to the SAVE utility which prompts you for a
filespec to which it copies the contents of memory, and the beginning
and ending address of the memory to be SAVED.

SET

=0.7cm Syntax:

SET [options]

SET d: [options]

SET filespec [options]

SET [option = modifier]

SET filespec [option = modifier]

SET initiates password protection and time stamping of files. It also
sets the file and drive attributes Read/Write, Read/Only, DIR and
SYS. It lets you label a disk and passord protect the label. To enable
time stamping of files, you must first run INITDIR to format the disk
directory.

SET Default password operation:

=0.7cm Syntax:

SET [DEFAULT=password]

Instructs the system to use a default password if you do not enter a
password for a password-protected file.

SET Time-stamp operations:

=0.7cm Syntax:

SET d: [CREATE=ONimg70.svg"
ALT="\(\vert\)">OFF]

SET d: [ACCESS=ONimg70.svg"
ALT="\(\vert\)">OFF]

SET d: [UPDATE=ONimg70.svg"
ALT="\(\vert\)">OFF]

The above set commands allw YOU to keep a record of the time and date
of file creation and update or of the last access update of your
files.

SET Drive operations:

=0.7cm Syntax:

SET d: [RO]

SET d: [RW]

Adds or removes write protection from a drive.

SETDEF

=0.7cm Syntax:

SETDEF

SETDEF [TEMPORARY=d:]

SETDEF d:i,d:i,d:i,d:i

SETDEF [ORDER= (typ1, typn)]

SETDEF [DISPLAY img70.svg"
ALT="\(\vert\)"> NO DISPLAY)

SETDEF [PAGE img70.svg"
ALT="\(\vert\)"> NOPAGE]

SETDEF allows the user to display or define up to four drives for the
program search order, the drive for temporary files, and the filetype
search order. The SETDEF definitions affect only the loading of
programs and/or execution of SUBMIT (SUB) files. SETDEF turns on/off
the system Display and Console Page modes. When on, the system
displays the location and name of programs loaded or SUBmit files
executed, and stops after displaying one full console screen of
information.

SHOW

=0.7cm Syntax:

SHOW

SHOW d:

SHOW d: [SPACE]

SHOW d: [LABEL]

SHOW d: [USERS]

SHOW d: [DIR]

SHOW d: [DRIVE]

The SHOW command displays the following disk drive information:

* access mode and the amount of free disk space

* disk label

* current user number

* number of files for each user number on the disk

* number of free directory entries for the disk

* drive characteristics

SID

=0.7cm Syntax:

SID [pgm-filespec],{sym-filespec}

The SID symbolic debugger allows you to monitor and test programs
developed for the 8080 microprocessor. SID supports real-time
breakpoints, fully monitored execution, symbolic disassembly,
assembly, and memory display and fill functions. SID can dynamically
load SID utility programs to provide traceback and histogram
facilities.

SUBMIT

=0.7cm Syntax:

SUBMIT

SUBMIT filespec

SUBMIT filespec argument ... argument

The SUBMIT command lets you execute a group (batch) of commands from a
SUBmit file (a file with filetype of SUB).

SUB files:

The SUB file can contain the following types of lines:

* any valid CP/M Plus command

* any valid CP/M Plus command with SUBMIT parameters ($0-$9)

* any data input line

* any program input line with parameters ($0 to $9)

The command line cannot exceed 135 characters.

TERMINFO (ZX Spectrum Next)

=0.7cm Syntax:

TERMINFO

This program provides information on the terminal facilities provided
by the BIOS on the ZX Spectrum Next.

TERMSIZE (ZX Spectrum Next)

=0.7cm Syntax:

TERMSIZE top left height width

Terminal resize utility

Size can be up to 32x80 (defaults to 24x80, suitable for many
programs). If setting a reduced size, the top and left parameters can
be used to make the image more centered on your screen.

TYPE/TYP (built-in)

=0.7cm Syntax:

TYPE

TYPE filespec

TYPE filespec [PAGE]

TYPE filespec [NOPAGE]

The TYPE command displays the contents of an ASCII character file on
your screen.

UPGRADE (ZX Spectrum Next)

=0.7cm Syntax:

UPGRADE

UPGRADE CP/M from C:/NEXTZXOS/CPMBASE.P3D

USER/USE (built-in)

=0.7cm Syntax:

USER

USER n

The USER command sets the current user number. The disk directory can
be divided into distinct groups according to a User Number. User
numbers range from 0 through 15.

XREF (Not included)

=0.7cm Syntax:

XREF {d:} filename {$P}

XREF provides a cross-reference summary of variable usage in a
program. XREF requires the PRN and SYM files produced by MAC or RMAC
for input to the program. The SYM and PRN files must have the same
filename as the filename in the XREF command tail. XREF outputs a file
of type XRF.

@node NODE139


@{h2}BDOS

From the CP/M 3 Programmers' Guide 1984

This section documents all BDOS system calls to include the parameters
that must be passes to them and the values that are returned to the
calling program.

BDOS function 0: SYSTEM RESET

Entry Parameters:
&nbsp;C: $00

The System Reset function terminates the calling program and returns
control to the CCP via a warm start sequence. Calling this function
has the same effect as a jump to location $0000 of Page Zero.

Note that the disk subsystem is not reset by System Reset under CP/M
3. The calling program can pass a return code to the CCP by calling
Function 108, Get/Set Program Return Code, prior to making a System
Reset call or jumping to location $0000.

BDOS function 1: CONSOLE INPUT

Entry Parameters:
&nbsp;C: $01

Returned Value:
&nbsp;A: ASCII Character

The Console Input function reads the next character from the logical
console, CONIN:, to register A. Graphic characters, along with
carriage return, line-feed, and backspace, CTRL-H, are echoed to the
console. Tab characters, CTR-L-1, are expanded in columns of 8
characters. CTRL-S, CTRL-Q, and CTRL-P are normally intercepted as
described below. All other non-graphic characters are returned in
register A but are not echoed to the console.

When the Console Mode is in the default state Function 1 intercepts
the stop scroll, CTRL-S, start scroll, CTRL-Q, and start/stop printer
echo, CTRL-P, characters. Any characters that are typed following a
CTRL-S and preceding a CTRL-Q are also intercepted. However, if
start/stop scroll has been disabled by the Console Mode, the CTRL-S,
CTRL-Q, and CTRL-P characters are not intercepted. Instead, they are
returned in register A, but are not echoed to the console.

If printer echo has been invoked, all characters that are echoed to
the console are also sent to the list device, LST:.  Function 1 does
not return control to the calling program until a non-intercepted
character is typed, thus suspending execution if a character is not
ready.

BDOS function 2: CONSOLE OUTPUT

Entry Parameters:
&nbsp;C: $02
&nbsp;E: ASCII Character

The Console Output function sends the ASCII character from register E
to the logical console device, CONOUT:. When the Console Mode is in
the default state (see Section 2.2.1), Function 2 expands tab
characters, CTRL-1, in columns of 8 characters, checks for stop
scroll, CTRL-S, start scroll, CTRL-Q, and echoes characters to the
logical list device, LST:, if printer echo, CTRL-P, has been invoked.

BDOS function 3: AUXILIARY INPUT

Entry Parameters:
&nbsp;C: $03

Returned Value:
&nbsp;A: ASCII Character

The Auxiliary Input function reads the next character from the logical
auxiliary input device, AUXIN:, into register A. Control does not
return to the calling program 'I the character is read.  unti

BDOS function 4: AUXILIARY OUTPUT

Entry Parameters:
&nbsp;C: $04
&nbsp;E: ASCII Character

The Auxiliary Output function sends the ASCII character from register
E to the logical auxiliary output device, AUXOUT:.

BDOS function 5: LIST OUTPUT

Entry Parameters:
&nbsp;C: $05
&nbsp;E: ASCII Character

The List Output function sends the ASCII character in register E to
the logical list device, LST:.

BDOS function 6: DIRECT CONSOLE I/O

Entry Parameters:
&nbsp;C: $06
&nbsp;E: function/data (see description)

Returned Value:
&nbsp;A: char/status/no value (see description)

CP/M 3 supports direct I/O to the logical console, CONIN:, for those
specialized applications where unadorned console input and output is
required. Use Direct Console I/O carefully because it bypasses all the
normal control character functions.  Programs that perform direct I/O
through the BIOS under previous releases of CP/M should be changed to
use direct I/O so that they can be fully supported under future
releases of MP/M and CP/M.

A program calls Function 6 by passing one of four different values in
register E.

* $FF Console input/status command returns an input character; if
no character is ready, a value of zero is returned.

* $FE Console status command (On return, register A contains 00
if no character is ready; otherwise it contains $FF.)

* $FD Console input command, returns an input character; this
function will suspend the calling process until a character is
ready.

* ASCII Function 6 assumes that register E contains a valid ASCII
chararacter and sends it to the console.

BDOS function 7: AUXILIARY INPUT STATUS

Entry Parameters:
&nbsp;C: $07

Returned Value:
&nbsp;A: Auxiliary Input Status

The Auxiliary Input Status function returns the value $FF in register
A if a character is ready for input from the logical auxiliary input
device, AUXIN:. If no character is ready for input, the value $00 is
returned.

BDOS function 8: AUXILIARY OUTPUT STATUS

Entry Parameters:
&nbsp;C: $08

Returned Value:
&nbsp;A: Auxiliary Output Status

The Auxiliary Output Status function returns the value $FF in
register A if the logical auxiliary output device, AUXOUT:, is ready
to accept a character for output.  If the device is not ready for
output, the value $00 is returned.

BDOS function 9: PRINT STRING

Entry Parameters:
&nbsp;C: $09
&nbsp;DE: String Address

The Print String function sends the character string addressed by
register pair DE to the logical console, CONOUT:, until it encounters
a delimiter in the string. Usually the delimiter is a dollar sign, $,
but it can be changed to any other value by Function 110, Get/Set
Output Delimiter. If the Console Mode is in the default state,
Function 9 expands tab characters, CTRL-I, in columns of 8
characters. It also checks for stop scroll, CTRL-S, start scroll,
CTRL-Q, and echoes to the logical list device, LST:, if printer echo,
CTRL-P, has been invoked.

BDOS function 10: READ CONSOLE BUFFER

Entry Parameters:
&nbsp;C: $0A
&nbsp;DE: Buffer Address

Returned Value:
&nbsp;Console Characters in Buffer

The Read Console Buffer function reads a line of edited console input
from the logical console, CONIN:, to a buffer that register pair DE
addresses. It terminates input and returns to the calling program when
it encounters a return, CTRL-M, or a line feed, CTRL-J,
character. Function 10 also discards all input characters after the
input buffer is filled. In addition, it outputs a bell character,
CTRL-G, to the console when it discards a character to signal the user
that the buffer is full. The input buffer addressed by DE has the
following format:

where mx is the maximum number of characters which the buffer holds,
and nc is the number of characters placed in the buffer. The
characters entered by the operator follow the nc value. The value mx
must be set prior to making a Function 10 call and may range in value
from 1 to 255. Setting mx to zero is equivalent to setting mx to
one. The value nc is returned to the calling program and may range
from zero to mx. If nc &lt; mx, then uninitialized positions follow the
last character, denoted by ??  in the figure. Note that a terminating
return or line feed character is not placed in the buffer and not
included in the count nc.

If register pair DE is set to zero, Function 10 assumes that an
initialized input buffer is located at the current DMA address (see
Function 26, Set DMA Address).  This allows a program to put a string
on the screen for the user to edit. To initialize the input buffer,
set characters c1 through cn to the initial value followed by a binary
zero terminator.

When a program calls Function 10 with an initialized buffer, Function
10 operates as if the user had typed in the string. When Function 10
encounters the binary zero terminator, it accepts input from the
console. At this point, the user can edit the initialized string or
accept it as it is by pressing the RETURN key. However, if the
initialized string contains a return, CTRL-M, or a linefeed, CTRL-J,
character, Function 10 returns to the calling program without giving
the user the opportunity to edit the string.

The level of console editing supported by Function 10 differs for the
banked and nonbanked versions of CP/M 3. Refer to the CPIM Plus (CPIM
Version 3) Operating System User's Guide for a detailed description of
console editing. In the nonbanked version, Function 10 recognizes the
following edit control characters.

Nonbanked CP/M 3

* rub/del Removes and echoes the last character; GENCPM can change
this function to CTRL-H

* CTRL-C Reboots when at the beginning of line; the Console Mode
can disable this function

* CTRL-E Causes physical end of line

* CTRL-H Backspaces one character position; GENCPM can change this
function to rub/del

* CTRL-J (Line-feed) terminates input line

* CTRL-M (Return) terminates input line

* CTRL-P Echoes console output to the list device

* CTRL-R Retypes the current line after new line

* CTRL-U Removes current line after new line

* CTRL-X Backspaces to beginning of current line

The banked version of CP/M 3 expands upon the editing provided in the
non-banked version. The functionality of the two versions is similar
when the cursor is positioned at the end of the line. However, in the
banked version, the user can move the cursor anywhere in the current
line, insert characters, delete characters, and perform other editing
functions. In addition, the banked version saves the previous command
line; it can be recalled when the current line is empty. In the banked
version, Function 10 recognizes the following edit control characters.

Banked CP/M 3

* rub/del Removes and echoes the last character if at the end of
the line; otherwise deletes the character to the left of the current
cursor position; GENCPM can change this function to CTRL-H.

* CTRL-A Moves cursor one character to the left.

* CTRL-B Moves cursor to the beginning of the line when not at the
beginning; otherwise moves cursor to the end of the line.

* CTRL-C Reboots when at the beginning of line; the Console Mode
can disable this function.

* CTRL-E Causes physical end-of-line; if the cursor is positioned
in the middle of a line, the characters at and to the right of the
cursor are displayed on the next line.

* CTRL-F Moves cursor one character to the right.

* CTRL-G Deletes the character at the current cursor position when
in the middle of the line; has no effect when the cursor is at the
end of the line.

* CTRL-H Backspaces one character position when positioned at the
end of the line,; otherwise deletes the character to the left of the
cursor; GENCPM can change this function to rub/del.

* CTRL-J (Line-feed) terminates input; the cursor can be
positioned anywhere in the line; the entire input line is
accepted; sets the previous line buffer to the input line.

* CTRL-K Deletes all characters to the right of the cursor along
with the character at the cursor.

* CTRL-M (Return) terminates input; the cursor can be positioned
anywhere in the line; the entire input line is accepted; sets the
previous line buffer to the input line.

* CTRL-P Echoes console output to the list device.

* CTRL-R Retypes the characters to the left of the cursor on the
new line.

* CTRL-U Updates the previous line buffer to contain the
characters to the left of the cursor; deletes current line, and
advances to new line.

* CTRL-W Recalls previous line if current line is empty; otherwise
moves cursor to end-of-line.

* CTRL-X Deletes all characters to the left of the cursor.

For banked systems, Function 10 uses the console width field defined
in the System Control Block. If the console width is exceeded when the
cursor is positioned at the end of the line, Function 10 automatically
advances to the next line. The beginning of the line can be edited by
entering a CTRL-R.

When a character is typed while the cursor is positioned in the middle
of the line, the typed character is inserted into the line. Characters
at and to the right of the cursor are shifted to the right. If the
console width is exceeded, the characters disappear off the right of
the screen. However, these characters are not lost. They reappear if
characters are deleted out of the line, or if a CTRL-E is typed.

BDOS function 11: GET CONSOLE STATUS

Entry Parameters:
&nbsp;C: $0B

Returned Value:
&nbsp;A: Console Status

The Get Console Status function checks to see if a character has been
typed at the logical console, CONIN:. If the Console Mode is in the
default state, Function 11 returns the value $01 in register A when a
character is ready. If a character is not ready, it returns a value of
$00.

If the Console Mode is in CTRL-C Only Status mode, Function 11 returns
the value $01 in register A only if a CTRL-C has been typed at the
console.

BDOS function 12: RETURN VERSION NUMBER

Entry Parameters:
&nbsp;C: $0C

Returned Value:
&nbsp;HL: Version Number

The Return Version Number function provides information that allows
version independent programming. It returns a two-byte value in
register pair HL: H contains $00 for CP/M and L contains $31, the
BDOS file system version number.  Function 12 is useful for writing
applications programs that must run on multiple versions of CP/M and
MP/M.

BDOS function 13: RESET DISK SYSTEM

Entry Parameters:
&nbsp;C: $0D

The Reset Disk System function restores the file system to a reset
state where all the disk drives are set to read-write (see Functions
28 and 29), the default disk is set to drive A, and the default DMA
address is reset to $0080. This function can be used, for example, by
an application program that requires disk changes during
operation. Function 37, Reset Drive, can also be used for this
purpose.

BDOS function 14: SELECT DISK

Entry Parameters:
&nbsp;C: $0E
&nbsp;E: Selected Disk

Returned Value:
&nbsp;A: Error Flag
&nbsp;H: Physical Error

The Select Disk function designates the disk drive named in register E
as the default disk for subsequent BDOS file operations. Register E is
set to 0 for drive A, 1 for drive B, and so on through 15 for drive P
in a full 16-drive system. In addition, Function 14 logs in the
designated drive if it is currently in the reset state. Logging-in a
drive activates the drive's directory until the next disk system reset
or drive reset operation.

FCBs that specify drive code zero (dr = $00) automatically reference
the currently selected default drive. FCBs with drive code values
between 1 and 16, however, gnore the selected default drive and
directly reference drives A through P.

Upon return, register A contains a zero if the select operation was
successful. If a physical error was encountered, the select function
performs different actions depending on the BDOS error mode (see
Function 45). If the BDOS error mode is in the default mode, a message
identifying the error is displayed at the console, and the calling
program is terminated. Otherwise, the select function returns to the
calling program with register A set to $FF and register H set to one
of the following

physical error codes:

* 01 Disk I/O Error

* 04 Invalid drive

BDOS function 15: OPEN FILE

Entry Parameters:
&nbsp;C: $0F
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Directory Code
&nbsp;H: Physical or Extended Error

The Open File function activates the FCB for a file that exists in the
disk directory under the currently active user number or user
zero. The calling program passes the address of the FCB in register
pair DE, with byte 0 of the FCB specifying the drive, bytes 1 through
11 specifying the filename and filetype, and byte 12 specifying the
extent. Usually, byte 12 of the FCB is initialized to zero.

If the file is password protected in Read mode, the correct password
must be placed in the first eight bytes of the current DMA, or have
been previously established as the default password (see Function
106). If the current record field of the FCB, cr, is set to $FF,
Function 15 returns the byte count of the last record of the file in
the cr field. You can set the last record byte count for a file with
Function 30, Set File Attributes. Note that the current record field
of the FCB, cr, must be zeroed by the calling program before beginning
read or write operations if the file is to be accessed sequentially
from the first record.

If the current user is non-zero, and the file to be opened does not
exist under the current user number, the open function searches user
zero for the file. If the file exists under user zero, and has the
system attribute, t2', set, the file is opened under user zero. Write
operations are not supported for a file that is opened under user zero
in this manner.

If the open operation is successful, the user's FCB is activated for
read and write operations. The relevant directory information is
copied from the matching directory FCB into bytes d0 through dn of the
FCB. If the file is opened under user zero when the current user
number is not zero, interface attribute f8' is set to one in the user's
FCB. In addition, if the referenced file is password protected in
Write mode, and the correct password was not passed in the DMA, or did
not match the default password, interface attribute f7' is set to
one. Write operations are not supported for an activated FCB if
interface attribute f7' or f8' is true.

When the open operation is successful, the open function also makes an
Access date and time stamp for the opened file when the following
conditions are satisfied: the referenced drive has a directory label
that requests Access date and time stamping, and the FCB extent number
field is zero.

Upon return, the Open File function returns a directory code in
register A with the value $00 if the open was successful, or $FF,
255 decimal, if the file was not found.  Register H is set to zero in
both of these cases. If a physical or extended error was encountered,
the Open File function performs different actions depending on the
BDOS error mode (see Function 45). If the BDOS error mode is in the
default mode, a message identifying the error is displayed at the
console and the program is terminated. Otherwise, the Open File
function returns to the calling program with register A set to $FF,
and register H set to one of the following physical or extended error
codes:

* 01 : Disk I/O Error

* 04 : Invalid drive error

* 07 : File password error

* 09 : ? in the FCB filename or filetype field

BDOS function 16: CLOSE FILE

Entry Parameters:
&nbsp;C: $10
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Directory Code
&nbsp;H: Physical or Extended Error

The Close File function performs the inverse of the Open File
function. The calling program passes the address of an FCB in register
pair DE. The referenced FCB must have been previously activated by a
successful Open or Make function call (see Functions 15 and
22). Interface attribute f5' specifies how the file is to be closed as
shown below:

* f5' = 0 - Permanent close (default mode)

* f5' = 1 - Partial close

A permanent close operation indicates that the program has completed
file operations on the file. A partial close operation updates the
directory, but indicates that the file is to be maintained in the open
state.

If the referenced FCB contains new information because of write
operations to the FCB, the close function permanently records the new
information in the referenced disk directory. Note that the FCB does
not contain new information, and the directory update step is
bypassed if only read or update operations have been made to the
referenced FCB.

Upon return, the close function returns a directory code in register A
with the value $00 if the close was successful„ or $FF, 255
Decimal, if the file was not found.  Register H is set to zero in both
of these cases. If a physical or extended error is encountered, the
close function performs different actions depending on the BDOS error
mode (see Function 45). If the BDOS error mode is in the default mode,
a message identifying the error is displayed at the console, and the
calling program is terminated. Otherwise, the close function returns
to the calling program with register A set to $FF and register H set
to one of the following physical error codes:

* 01 Disk I/O error

* 02 Read/only disk

* 04 Invalid drive error

BDOS function 17: SEARCH FOR FIRST

Entry Parameters:
&nbsp;C: $11
&nbsp;DE: FCB Address

Returned Value:
&nbsp;
&nbsp;A: Directory Code
&nbsp;H: Physical Error

The Search For First function scans the directory for a match with the
FCB addressed by register pair DE. Two types of searches can be
performed. For standard searches, the calling program initializes
bytes 0 through 12 of the referenced FCB, with byte 0 specifying the
drive directory to be searched, bytes 1 through 11 specifying the file
or files to be searched for„ and byte 12 specifying the
extent. Usually byte 12 is set to zero. An ASCII question mark, 63
decimal, 3F hex, in any of the bytes 1 through 12 matches all entries
on the directory in the corresponding position. This facility, called
ambiguous reference, can be used to search for multiple files on the
directory. When called in the standard mode, the Search function scans
for the first file entry in the specified directory that matches the
FCB, and belongs to the current user number.

The Search For First function also initializes the Search For Next
function. After the Search function has located the first directory
entry matching the referenced FCB, the Search For Next function can be
called repeatedly to locate all remaining matching entries. In terms
of execution sequence, however, the Search For Next call must either
follow a Search For First or Search For Next call with no other
intervening BDOS disk-related function calls.

If byte 0 of the referenced FCB is set to a question mark, the Search
function ignores the remainder of the referenced FCB, and locates the
first directory entry residing on the current default drive. All
remaining directory entries can be located by making multiple Search
For Next calls. This type of search operation is not usually made by
application programs, but it does provide complete flexibility to scan
all current directory values. Note that this type of search operation
must be performed to access a drive's directory label.

Upon return, the Search function returns a Directory Code in register
A with the value 0 to 3 if the search is successful, or $FF, 255
Decimal, if a matching directory entry is not found. Register H is set
to zero in both of these cases. For successful searches, the current
DMA is also filled with the directory record containing the matching
entry, and the relative starting position is A * 32 (that is, rotate
the A register left 5 bits, or ADD A five times). Although it is not
usually required for application programs, the directory information
can be extracted from the buffer at this position.

If the directory has been initialized for date and time stamping by
INITDIR, then an SFCB resides in every fourth directory entry, and
successful Directory Codes are restricted to the values 0 to 2. For
successful searches, if the matching directory record is an extent
zero entry, and if an SFCB resides at offset 96 within the current
DMA, contents of (DMA Address + 96) = $21, the SFCB contains the date
and time stamp information, and password mode for the file. This
information is located at the relative starting position of 97 + (A *
10) within the current DMA in the following format:

* 0 - 3 Create or Access Date and Time Stamp Field

* 4 - 7 Update Date and Time Stamp Field

* 8 : Password Mode Field

If a physical error is encountered, the Search function performs
different actions depending on the BDOS error mode (see Function
45). If the BDOS error mode is in the default mode, a message
identifying the error is displayed at the console, and the calling
program is terminated. Otherwise, the Search function returns to the
calling program with register A set to $FF, and register H set to
one of the following physical error codes:

* 01 Disk I/O error

* 04 Invalid drive error

BDOS function 18: SEARCH FOR NEXT

Entry Parameters:
&nbsp;C: $12

Returned Value:
&nbsp;A: Directory Code
&nbsp;H: Physical Error

The Search For Next function is identical to the Search For First
function, except that the directory scan continues from the last entry
that was matched. Function 18 returns a Directory code in register A,
analogous to Function 17.

Note: in execution sequence, a Function 18 call must follow either a
Function 17 or another Function 18 call with no other intervening BDOS
disk-related function calls.

BDOS function 19: DELETE FILE

Entry Parameters:
&nbsp;C: $13
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Directory Code
&nbsp;H: Extended or Physical Error

The Delete File function removes files or XFCBs that match the FCB
addressed in register pair DE. The filename and filetype can contain
ambiguous references, that is, question marks in bytes f1' through t3',
but the dr byte cannot be ambiguous, as it can in the Search and
Search Next functions. Interface attribute f5' specifies the type of
delete operation that is performed.

* f5' = 0 - Standard Delete (default mode)

* f5' = 1 - Delete only XFCBs

If any of the files that the referenced FCB specify are password
protected, the correct password must be placed in the first eight
bytes of the current DMA buffer, or have been previously established
as the default password (see Function 106).

For standard delete operations, the Delete function removes all
directory entries belonging to files that match the referenced
FCB. All disk directory and data space owned by the deleted files is
returned to free space, and becomes available for allocation to other
files. Directory XFCBs that were owned by the deleted files are also
removed from the directory. If interface attribute f5' of the FCB is
set to 1, Function 19 deletes only the directory XFCBs that match the
referenced FCB.

Note: if any of the files that match the input FCB specification fall
the password check, or are Read-Only, then the Delete function does
not delete any files or XFCBS.  This applies to both types of delete
operations.

In nonbanked systems, file passwords and XFCBs are not
supported. Thus, if the Delete function is called with interface
attribute f5' set to true, the Delete function performs no action but
returns with register A set to zero.

Upon return, the Delete function returns a Directory Code in register
A with the value 0 if the delete is successful, or $FF, 255 Decimal,
if no file that matches the referenced FCB is found. Register H is set
to zero in both of these cases. If a physical, or extended error is
encountered, the Delete function performs different actions depending
on the BDOS error mode (see Function 45). If the BDOS error mode is
the default mode, a message identifying the error is displayed at the
console and the calling program is terminated. Otherwise, the Delete
function returns to the calling program with register A set to $FF
and register H set to one of the following physical or extended error
codes:

* 01 : Disk I/O error

* 02 : Read-Only disk

* 03 : Read-Only file

* 04 : Invalid drive error

* 07 : File password error

BDOS function 20: READ SEQUENTIAL

Entry Parameters:
&nbsp;C: $14
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Error Code
&nbsp;H: Physical Error

The Read Sequential function reads the next 1 to 128 128-byte records
from a file into memory beginning at the current DMA address. The BDOS
Multi-Sector Count (see Function 44) determines the number of records
to be read. The default is one record. The FCB addressed by register
pair DE must have been previously activated by an Open or Make
function call.

Function 20 reads each record from byte cr of the extent, then
automatically increments the cr field to the next record position. If
the cr field overflows, then the function automatically opens the next
logical extent and resets the cr field to 0 in preparation for the
next read operation. The calling program must set the cr field to 0
following the Open call if the intent is to read sequentially from the
beginning of the file.  Upon return, the Read Sequential function sets
register A to zero if the read operation is successful. Otherwise,
register A contains an error code identifying the error as shown
below:

* 01 Reading unwritten data (end-of-file)

* 09 Invalid FCB

* 10 Media change occurred

* 255 Physical Error; refer to register H

Error Code 01 is returned if no data exists at the next record
position of the file.  Usually, the no data situation is encountered
at the end of a file. However, it can also occur if an attempt is made
to read a data block that has not been previously written, or an
extent which has not been created. These situations are usually
restricted to files created or appended with the BDOS random write
functions (see Functions 34 and 40).

Error Code 09 is returned if the FCB is invalidated by a previous BDOS
close call that returns an error.

Error Code 10 is returned if a media change occurs on the drive after
the referenced FCB is activated by a BDOS Open, or Make Call.

Error Code 255 is returned if a physical error is encountered and the
BDOS error mode is Return Error mode, or Return and Display Error mode
(see Function 45). If the error mode is the default mode, a message
identifying the physical error is displayed at the console, and the
calling program is terminated. When a physical error is returned to
the calling program, register H contains one of the following error
codes:

* 01 Disk I/O error

* 04 Invalid drive error

On all error returns except for physical error returns, A = 255,
Function 20 sets register H to the number of records successfully read
before the error is encountered.  This value can range from 0 to 127
depending on the current BDOS Multi-Sector Count. It is always set to
zero when the Multi-Sector Count is equal to one.

BDOS function 21: WRITE SEQUENTIAL

Entry Parameters:
&nbsp;C: $15
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Error Code
&nbsp;H: Physical Error

The Write Sequential function writes 1 to 128 128-byte data records,
beginning at the current DMA address into the file named by the FCB
addressed in register pair DE. The BDOS Multi-Sector Count (see
Function 44) determines the number of 128 byte records that are
written. The default is one record. The referenced FCB must have been
previously activated by a BDOS Open or Make function call.

Function 21 places the record into the file at the position indicated
by the cr byte of the FCB, and then automatically increments the cr
byte to the next record position. If the cr field overflows, the
function automatically opens, or creates the next logical extent, and
resets the cr field to 0 in preparation for the next write operation.
If Function 21 is used to write to an existing file, then the newly
written records overlay those already existing in the file. The
calling program must set the cr field to 0 following an Open or Make
call if the intent is to write sequentially from the beginning of the
file.

Function 21 makes an Update date and time for the file if the
following conditions are satisfied: the referenced drive has a
directory label that requests date and time stamping, and the file has
not already been stamped for update by a previous Make or Write
function call.

Upon return, the Write Sequential function sets register A to zero if
the write operation is successful. Otherwise, register A contains an
error code identifying the error as shown below:

* 01 No available directory space

* 02 No available data block

* 09 Invalid FCB

* 10 Media change occurred

* 255 Physical Error : refer to register H

Error Code 01 is returned when the write function attempts to create a
new extent that requires a new directory entry, and no available
directory entries exist on the selected disk drive.

Error Code 02 is returned when the write command attempts to allocate
a new data block to the file, and no unallocated data blocks exist on
the selected disk drive.

Error Code 09 is returned if the FCB is invalidated by a previous BDOS
close call that returns an error.

Error Code 10 is returned if a media change occurs on the drive after
the referenced FCB is activated by a BDOS Open or Make call.

Error Code 255 is returned if a physical error is encountered and the
BDOS error mode is Return Error mode, or Return and Display Error mode
(see Function 45). If the error mode is the default mode, a message
identifying the physical error is displayed at the console, and the
calling program is terminated. When a physical error is returned to
the calling program, register H contains one of the following error
codes:

* 01 Disk I/O error

* 02 Read-Only disk

* 03 Read-Only file or File open from user 0 when the current user
number is non-zero or File password protected in Write mode

* 04 Invalid drive error

On all error returns, except for physical error returns, A = 255,
Function 21 sets register H to the number of records successfully
written before the error was encountered. This value can range from 0
to 127 depending on the current BDOS Multi-Sector Count. It is always
set to zero when the Multi-Sector Count is set to one.

BDOS function 22: MAKE FILE

Entry Parameters:
&nbsp;C: $16
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Directory Code
&nbsp;H: Physical or Extended Error

The Make File function creates a new directory entry for a file under
the current user number. It also creates an XFCB for the file if the
referenced drive has a directory label that enables password
protection on the drive, and the calling program assigns a password to
the file.

The calling program passes the address of the FCB in register pair DE,
with byte 0 of the FCB specifying the drive, bytes 1 through 11
specifying the filename and filctype, and byte 12 set to the extent
number. Usually, byte 12 is set to zero. Byte 32 of the FCB, the cr
field, must be initialized to zero, before or after the Make call, if
the intent is to write sequentially from the beginning of the file.

Interface attribute f6' specifies whether a password is to be assigned
to the created file.

* f6' = 0 - Do not assign password (default)

* f6' = 1 - Assign password to created file

When attribute f6' is set to 1, the calling program must place the
password in the first 8 bytes of the current DMA buffer, and set byte
9 of the DMA buffer to the password mode (see Function 102). Note that
the Make function only interrogates interface attribute f6' if
passwords are activated on the referenced drive. In nonbanked systems,
file passwords are not supported, and attribute f6' is never
interrogated.

The Make function returns with an error if the referenced FCB names a
file that currently exists in the directory under the current user
number.

If the Make function is successful, it activates the referenced FCB
for file operations by opening the FCB, and initializes both the
directory entry and the referenced FCB to an empty file. It also
initializes all file attributes to zero. In addition, Function 22
makes a Creation date and time stamp for the file if the following
conditions are satisfied: the referenced drive has a directory label
that requests Creation date and time stamping and the FCB extent
number field is equal to zero. Function 22 also makes an Update stamp
if the directory label requests update stamping and the FCB extent
field is equal to zero.

If the referenced drive contains a directory label that enables
password protection, and if interface attribute f6' has been set to 1,
the Make function creates an XFCB for the file. In addition, Function
22 also assigns the password, and password mode placed in the first
nine bytes of the DMA, to the XFCB.

Upon return, the Make function returns a directory code in register A
with the value 0 if the make operation is successful, or $FF, 255
decimal, if no directory space is available. Register H is set to zero
in both of these cases. If a physical or extended error is
encountered, the Make function performs different actions depending on
the BDOS error mode (see Function 45). If the BDOS error mode is the
default mode, a message identifying the error is displayed at the
console, and the calling program is terminated. Otherwise, the Make
function returns to the calling program with register A set to $FF,
and register H set to one of the following physical or extended error
codes:

* 01 : Disk I/O error

* 02 : Read-Only disk

* 04 : Invalid drive error

* 08 : File already exists

* 09 : ? in filename or filetype field

BDOS function 23: RENAME FILE

Entry Parameters:
&nbsp;C: $17
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Directory Code
&nbsp;H: Physical or Extended Error

The Rename function uses the FCB, addressed by register pair DE, to
change all directory entries of the file specified by the filename in
the first 16 bytes of the FCB to the filename in the second 16
bytes. If the file specified by the first filename is password
protected, the correct password must be placed in the first eight
bytes of the current DMA buffer, or have been previously established
as the default password (see Function 106). The calling program must
also ensure that the filenames specified in the FCB are valid and
unambiguous, and that the new filename does not already exist on the
drive. Function 23 uses the dr code at byte 0 of the FCB to select the
drive. The drive code at byte 16 of the FCB is ignored.

Upon return, the Rename function returns a Directory Code in register
A with the value 0 if the rename is successful, or $0FF, 255 Decimal,
if the file named by the first filename in the FCB is not
found. Register H is set to zero in both of these cases.  If a
physical or extended error is encountered, the Rename function
performs different actions depending on the BDOS error mode (see
Function 45). If the BDOS error mode is the default mode, a message
identifying the error is displayed at the console and the program is
terminated. Otherwise, the Rename function returns to the calling
program with register A set to $0FF and register H set to one of the
following physical or extended error codes:

* 01 Disk I/O error

* 02 Read-Only disk

* 03 Read-Only file

* 04 Invalid drive error

* 07 File password error

* 08 File already exists

* 09 ? in filename or filetype field

BDOS function 24: RETURN LOGIN VECTOR

Entry Parameters:
&nbsp;C: $18

Returned Value:
&nbsp;HL: Login Vector

Function 24 returns the login vector in register pair HL. The login
vector is a 16-bit value with the least significant bit of L
corresponding to drive A, and the highorder bit of H corresponding to
the 16th drive, labelled P. A 0 bit indicates that the drive is not
on-line, while a 1 bit indicates the drive is active. A drive is made
active by either an explicit BDOS Select Disk call, number 14, or an
implicit selection when a BDOS file operation specifies a non-zero dr
byte in the FCB. Function 24 maintains compatibilty with earlier
releases since registers A and L contain the same values upon return.

BDOS function 25: RETURN CURRENT DISK

Entry Parameters:
&nbsp;C: $19

Returned Value:
&nbsp;A: Current Disk

Function 25 returns the currently selected default disk number in
register A. The disk numbers range from 0 through 15 corresponding to
drives A through P.

BDOS function 26: SET DMA ADDRESS

Entry Parameters:
&nbsp;C: $1A
&nbsp;DE: DMA Address

DMA is an acronym for Direct Memory Address, which is often used in
connection with disk controllers that directly access the memory of
the computer to transfer data to and from the disk subsystem. Under
CP/M 3, the current DMA is usually defined as the buffer in memory
where a record resides before a disk write, and after a disk read
operation. If the BDOS Multi-Sector Count is equal to one (see
Function 44), the size of the buffer is 128 bytes. However, if the
BDOS Multi-Sector Count is greater than one, the size of the buffer
must equal N * 128, where N equals the Multi-Sector Count.

Some BDOS functions also use the current DMA to pass parameters, and
to return values. For example, BDOS functions that check and assign
file passwords require that the password be placed in the current
DMA. As another example, Function 46, Get Disk Free Space, returns its
results in the first 3 bytes of the current DMA. When the current DMA
is used in this context, the size of the buffer in memory is
determined by the specific requirements of the called function.

When a transient program is initiated by the CCP, its DMA address is
set to $0080. The BDOS Reset Disk System function, Function 13, also
sets the DMA address to $0080. The Set DMA function can change this
default value to another memory address. The DMA address is set to the
value passed in the register pair DE.  The DMA address remains at this
value until it is changed by another Set DMA Address, or Reset Disk
System call.

BDOS function 27: GET ADDR(ALLOC)

Entry Parameters:
&nbsp;C: $1B

Returned Value:
&nbsp;HL: ALLOC Address

CP/M 3 maintains an allocation vector in main memory for each active
disk drive.  Some programs use the information provided by the
allocation vector to determine the amount of free data space on a
drive. Note, however, that the allocation information might be
inaccurate if the drive has been marked Read-Only.

Function 27 returns in register pair HL, the base address of the
allocation vector for the currently selected drive. If a physical
error is encountered when the BDOS error mode is one of the return
modes (see Function 45), Function 27 returns the value $FFFF in the
register pair HL.

In banked CP/M 3 systems, the allocation vector can be placed in bank
zero. In this case, a transient program cannot access the allocation
vector. However, the BDOS function, Get Disk Free Space (Function 46),
can be used to directly return the number of free 128-byte records on
a drive. The CP/M 3 utilities that display a drive's free space, DIR
and SHOW, use Function 46 for that purpose.

BDOS function 28: WRITE PROTECT DISK

Entry Parameters:
&nbsp;C: $1C

The Write Protect Disk function provides temporary write protection
for the currently selected disk by marking the drive as Read-Only, No
program can write to a disk that is in the Read-Only state. A drive
reset operation must be performed for a Read-Only drive to restore it
to the Read-Write state (see Functions 13 and 37).

BDOS function 29: GET READ-ONLY VECTOR

Entry Parameters:
&nbsp;C: l$D

Returned Value:
&nbsp;HL: R/O Vector Value

Function 29 returns a bit vector in register pair HL that indicates
which drives have the temporary Read-Only bit set. The Read-Only bit
can be set only by a BDOS Write Protect Disk call.

The format of the bit vector is analogous to that of the login vector
returned by Function 24. The least significant bit corresponds to
drive A, while the most significant bit corresponds to drive P.

BDOS function 30: SET FILE ATTRIBUTES

Entry Parameters:
&nbsp;C: $1E
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Directory Code
&nbsp;H: Physical or Extended error

By calling the Set File Attributes function, a program can modify a
file's attributes and set its last record byte count. Other BDOS
functions can be called to interrogate these file parameters, but only
Function 30 can change them. The file attributes that can be set or
reset by Function 30 are fl' through f4', Read-Only, t1', System, t2',
and Archive, t3'. The register pair DE addresses an FCB containing a
filename with the appropriate attributes set or reset. The calling
program must ensure that it does not specify an ambiguous filename. In
addition, if the specified file is password totected, the correct
password must be placed in the first eight bytes of the current DMA
buffer or have been previously established as the default password
(see Function 106).

Interface attribute f6' specifies whether the last record byte count
of the specified file is to be set:

* f6' = 0 - Do not set byte count (default mode)

* f6' = 1 - Set byte count

If interface attribute f6' is set, the calling program must set the cr
field of the referenced FCB to the byte count value. A program can
access a file's byte count value with the BDOS Open, Search, or Search
Next functions.

Function 30 searches the referenced directory for entries belonging to
the current user number that matches the FCB specified name and type
fields. The function then updates the directory to contain the
selected indicators, and if interface attribute f6' is set, the
specified byte count value. Note that the last record byte count is
maintained in byte 13 of a file's directory FCBS.

File attributes t1', t2', and t3' are defined by CP/M 3. (They are
described in Section 2.3.4.) Attributes fl' through f4' are not
presently used, but can be useful for application programs, because
they are not involved in the matching program used by the BDOS during
Open File and Close File operations. Indicators f5' through f8' are
reserved for use as interface attributes.

Upon return, Function 30 returns a Directory Code in register A with
the value 0 if the function is successful, or $FF, 255 Decimal, if
the file specified by the referenced FCB is not found. Register H is
set to zero in both of these cases. If a physical or extended error is
encountered', the Set File Attributes function performs different
actions depending on the BDOS error mode (see Function 45). If the
BDOS error mode is the default mode, a message identifying the error
is displayed at the console, and the program is terminated. Otherwise,
Function 30 returns to the calling program with reg'ls-Ler A set to
$FF, and register H set to one of the following physical or extended
error codes:

* 01 Disk I/O error

* 02 Read-Only disk

* 04 Select error

* 07 File password error

* 09 ? in filename or filetype field

BDOS function 31: GET ADDR(DPB PARMS)

Entry Parameters:
&nbsp;C: $1F

Returned Value:
&nbsp;HL: DPB Address

Function 31 returns in register pair HL the address of the
BIOS-resident Disk Parameter Block, DPB, for the currently selected
drive. (Refer to the CP/M Plus (CP/M Version 3) Operating System
System Guide for the format of the DPB). The calling program can use
this address to extract the disk parameter values.

If a physical error is encountered when the BDOS error mode is one of
the return modes (see Function 45), Function 31 returns the value
$FFFF in the register pair HL.

BDOS function 32: SET/GET USER CODE

Entry Parameters:
&nbsp;C: $20

Returned Value:
&nbsp;E: $FF (get) or User Code (set)
&nbsp;A: Current Code or (no value)

A program can change, or interrogate the currently active user number
by calling Function 32. If register E = $FF, then the value of the
current user number is returned in register A, where the value is in
the range of 0 to 15. If register E is not $FF, then the current user
number is changed to the value of E, modulo 16.

BDOS function 33: READ RANDOM

Entry Parameters:
&nbsp;C: $21
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Error Code
&nbsp;H: Physical Error

The Read Random function is similar to the Read Sequential function
except that the read operation takes place at a particular random
record number, selected by the 24-bit value constructed from the three
byte, r0, r1, r2, field beginning at position 33 of the FCB. Note that
the sequence of 24 bits is stored with the least significant byte
first, rO, the middle byte next, rl, and the high byte last, r2. The
random record number can range from 0 to 262,143. This corresponds to
a maximum value of 3 in byte r2.

To read a file with Function 33, the calling program must first open
the base extent, extent 0. This ensures that the FCB is properly
initialized for subsequent random access operations. The base extent
may or may not contain any allocated data. Function 33 reads the
record specified by the random record field into the current DMA
address. The function automatically sets the logical extent and
current record values, but unlike the Read Sequential function, it
does not advance the current record number. Thus, a subsequent Read
Random call rereads the same record. After a random read operation, a
file can be accessed sequentially, starting from the current randomly
accessed position. However, the last randomly accessed record is
reread or rewritten when switching from random to sequential mode.

If the BDOS Multi-Sector Count is greater than one (see Function 44),
the Read Random function reads multiple consecutive records into
memory beginning at the current DMA. The rO, rl, and r2 field of the
FCB is automatically incremented to read each record. However, the
FCBs random record number is restored to the first record's value upon
return to the calling program.

Upon return, the Read Random function sets register A to zero if the
read operation was successful. Otherwise, register A contains one of
the following error codes:

* 01 Reading unwritten data (end-of-file)

* 03 Cannot close current extent

* 04 Seek to unwritten extent

* 06 Random record number out of range

* 10 Media change occurred

* 255 Physical Error : refer to register H

Error Code 01 is returned if no data exists at the next record
position of the file.  Usually, the no data situation is encountered
at the end of a file. However, it can also occur if an attempt is made
to read a data block that has not been previously written.

Error Code 03 is returned when the Read Random function cannot close
the current extent prior to moving to a new extent.

Error Code 04 is returned when a read random operation accesses an
extent that has not been created.

Error Code 06 is returned when byte 35, r2, of the referenced FCB is
greater than 3.

Error Code 10 is returned if a media change occurs on the drive after
the referenced FCB is activated by a BDOS Open or Make Call.

Error Code 255 is returned if a physical error is encountered, and the
BDOS error mode is one of the return modes (see Function 45). If the
error mode is the default mode, a message identifying the physical
error is displayed at the console, and the calling program is
terminated. When a physical error is returned to the calling program,
register H contains one of the following error codes:

* 01 Disk I/O error

* 04 Invalid drive error

On all error returns except for physical errors, A = 255, the Read
Random function sets register H to the number of records successfully
read before the error is encountered. This value can range from 0 to
127 depending on the current BDOS Multi-Sector Count. It is always set
to zero when the Multi-Sector Count is equal to one.

BDOS function 34: WRITE RANDOM

Entry Parameters:
&nbsp;C: $22
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Error Code
&nbsp;H: Physical Error

The Write Random function is analogous to the Read Random function,
except that data is written to the disk from the current DMA
address. If the disk extent or data block where the data is to be
written is not already allocated, the BDOS automatically performs the
allocation before the write operation continues.

To write to a file using the Write Random function, the calling
program must first open the base extent, extent 0. This ensures that
the FCB is properly initialized for subsequent random access
operations. If the file is empty, the calling program must create the
base extent with the Make File function before calling Function
34. The base extent might or might not contain any allocated data, but
it does record the file in the directory, so that the file can be
displayed by the DIR utility.

The Write Random function sets the logical extent and current record
positions to correspond with the random record being written, but does
not change the random record number. Thus, sequential read or write
operations can follow a random write, with the current record being
reread or rewritten as the calling program switches from random to
sequential mode.

Function 34 makes an Update date and time stamp for the file if the
following conditions are satisfied: the referenced drive has a
directory label that requests Update date and time stamping if the
file has not already been stamped for update by a previous BDOS Make
or Write call.

If the BDOS Multi-Sector Count is greater than one (see Function 44),
the Write Random function reads multiple consecutive records into
memory beginning at the current DMA. The rO, rl, and r2 field of the
FCB is automatically incremented to write each record. However, the
FCB's random record number is restored to the first record's value
when it returns to the calling program. Upon return, the Write Random
function sets register A to zero if the write operation is
successful. Otherwise, register A contains one of the following error
codes:

* 02 No available data block

* 03 Cannot Close current extent

* 05 No available directory space

* 06 Random record number out of range

* 10 Media change occurred

* 255 Physical Error : refer to register H

Error Code 02 is returned when the write command attempts to allocate
a new data block to the file and no unallocated data blocks exist on
the selected disk drive.

Error Code 03 is returned when the Write Random function cannot close
the current extent prior to moving to a new extent.

Error Code 05 is returned when the write function attempts to create a
new extent that requires a new directory entry and no available
directory entries exist on the selected disk drive.

Error Code 06 is returned when byte 35, r2, of the referenced FCB is
greater than 3.

Error Code 10 is returned if a media change occurs on the drive after
the referenced FCB is activated by a BDOS Open or Make Call.

Error Code 255 is returned if a physical error is encountered and the
BDOS error mode is one of the return modes (see Function 45). If the
error mode is the default mode, a message identifying the physical
error is displayed at the console, and the calling program is
terminated. When a physical error is returned to the calling program,
it is identified by register H as shown below:

* 01 Disk I/O error

* 02 Read-Only disk

* 03 Read-Only file or File open from user 0 when the current user
number is nonzero or File password protected in Write mode

* 04 Invalid drive error

On all error returns, except for physical errors, A = 255, the Write
Random function sets register H to the number of records successfully
written before the error is encountered. This value can range from 0
to 127 depending on the current BDOS Multi-Sector Count. It is always
set to zero when the Multi-Sector Count is equal to one.

BDOS function 35: COMPUTE FILE SIZE

Entry Parameters:
&nbsp;C: $23
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Error Flag
&nbsp;H: Physical or Extended error
&nbsp;Random Record Field Set

The Compute File Size function determines the virtual file size, which
is, in effect, the address of the record immediately following the end
of the file. The virtual size of a file corresponds to the physical
size if the file is written sequentially. If the file is written in
random mode, gaps might exist in the allocation, and the file might
contain fewer records than the indicated size. For example, if a
single record with record number 262,143, the CP/M 3 maximum is
written to a file using the Write Random function, then the virtual
size of the file is 262,144 records even though only 1 data block 'is
actually allocated.

To compute file size, the calling program passes in register pair DE
the address of an FCB in random mode format, bytes rO, rl and r2
present. Note that the FCB must contain an unambiguous filename and
filetype. Function 35 sets the random record field of the FCB to the
random record number + 1 of the last record in the file. If the r2
byte is set to 04, then the file contains the maximum record count
262,144.

A program can append data to the end of an existing file by calling
Function 35 to set the random record position to the end of file, and
then performing a sequence of random writes starting at the preset
record address.

Note: the BDOS does not require that the file be open to use Function
35. However, if the file has been written to, it must be closed before
calling Function 35. Otherwise, an incorrect file size might be
returned.

Upon return, Function 35 returns a zero in register A if the file
specified by the referenced FCB is found, or an $FF in register A if
the file is not found. Register H is set to zero in both of these
cases. If a physical error is encountered, Function 35 performs
different actions depending on the BDOS error mode (see Function 45).
If the BDOS error mode is the default mode, a message identifying the
error is displayed at the console and the program is
terminated. Otherwise, Function 35 returns to the calling program with
register A set to $FF, and register H set to one of the following
physical errors:

* 01 Disk I/O error

* 04 Invalid drive error

BDOS function 36: SET RANDOM RECORD

Entry Parameters:
&nbsp;C: $24
&nbsp;DE: FCB Address

Returned Value:
&nbsp;Random Record Field Set

The Set Random Record function returns the random record number of the
next record to be accessed from a file that has been read or written
sequentially to a particular point. This value is returned in the
random record field, bytes rO, rl, and r2, of the FCB addressed by the
register pair DE. Function 36 can be useful in two ways,

First, it is often necessary to initially read and scan a sequential
file to extract the positions of various key fields. As each key is
encountered, Function 36 is called to compute the random record
position for the data corresponding to this key. If the data unit size
is 128 bytes, the resulting record number minus one is placed into a
table with the key for later retrieval. After scanning the entire file
and tabularizing the keys and their record numbers, you can move
directly to a particular record by performing a random read using the
corresponding random record number that you saved earlier. The scheme
is easily generalized when variable record lengths are involved,
because the program need only store the buffer-relative byte position
along with the key and record number to find the exact starting
position of the keyed data at a later time.

A second use of Function 36 occurs when switching from a sequential
read or write over to random read or write. A file is sequentially
accessed to a particular point in the file, then Function 36 is called
to set the record number, and subsequent random read and write
operations continue from the next record in the file.

BDOS function 37: RESET DRIVE

Entry Parameters:
&nbsp;C: $25
&nbsp;DE: Drive Vector

Returned Value:
&nbsp;A: $00

The Reset Drive function programmatically restores specified drives to
the reset state. A reset drive is not logged-in and is in Read-Write
status. The passed parameter in register pair DE is a 16-bit vector of
drives to be reset, where the least significant bit corresponds to the
first drive A, and the high-order bit corresponds to the sixteenth
drive, labelled P. Bit values of 1 indicate that the specified drive
is to be reset.

BDOS function 38: ACCESS DRIVE

Entry Parameters:
&nbsp;C: $26

This is an MP/M function that is not supported under CP/M 3. If
called, the file system returns a zero In register A indicating that
the access request is successful.

BDOS function 39: FREE DRIVE

Entry Parameters:
&nbsp;C: $27

This is an MP/M function that is not supported under CP/M 3. If
called, the file system returns a zero In register A indicating that
the free request is successful.

BDOS function 40: WRITE RANDOM WITH ZERO FILL

Entry Parameters:
&nbsp;C: $28
&nbsp;DE: FCB address

Returned Value:
&nbsp;A: Error Code
&nbsp;H: Physical Error

The Write Random With Zero Fill function is identical to the Write
Random function (Function 34) with the exception that a previously
unallocated data block is filled with zeros before the record is
written. If this function has been used to create a file, records
accessed by a read random operation that contain all zeros identify
unwritten random record numbers. Unwritten random records in allocated
data blocks of files created using the Write Random function (Function
34) contain uninitialized data.

BDOS function 41: TEST AND WRITE RECORD

Entry Parameters:
&nbsp;C: $29
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Error Code
&nbsp;H: Physical Error

The Test and Write Record function is an MP/M function that is not
supported under CP/M 3. If called, Function 41 returns with register A
set to $FF and register H set to zero.

BDOS function 42: LOCK RECORD

Entry Parameters:
&nbsp;C: $2A
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: $00

The Lock Record function is an MP/M II function that is supported
under CP/M 3 only to provide compatibility between CP/M 3 and MP/M. It
is intended for use in situations where more than one running program
has Read-Write access to a common file. Because CP/M 3 is a
single-user operating system in which only one program can run at a
time, this situation cannot occur. Thus, under CP/M 3, Function 42
performs no action except to return the value $00 in register A
indicating that the record lock operation is successful.

BDOS function 43: UNLOCK RECORD

Entry Parameters:
&nbsp;C: $2B
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: $00

The Unlock Record function is an MP/M II function that is supported
under CP/M 3 only to provide compatibility between CP/M 3 and MP/M. It
is intended for use in situations where more than one running program
has Read-Write access to a common file. Because CP/M 3 is a
single-user operating system in which only one program can run at a
time, this situation cannot occur. Thus, under CP/M 3, Function 43
performs no action except to return the value $00 in register A
indicating that the record unlock operation is successful.

BDOS function 44: SET MULTI-SECTOR COUNT

Entry Parameters:
&nbsp;C: $2C
&nbsp;E: Number of Sectors

Returned Value:
&nbsp;A: Return Code

The Set Multi-Sector Count function provides logical record blocking
under CP/M 3. It enables a program to read and write from 1 to 128
records of 128 bytes at a time during subsequent BDOS Read and Write
functions.

Function 44 sets the Multi-Sector Count value for the calling program
to the value passed in register E. Once set, the specified
Multi-Sector Count remains in effect until the calling program makes
another Set Multi-Sector Count function call and changes the
value. Note that the CCP sets the Multi-Sector Count to one when it
initiates a transient program.

The Multi-Sector Count affects BDOS error reporting for the BDOS Read
and Write functions. If an error interrupts these functions when the
Multi-Sector is greater than one, they return the number of records
successfully read or written in register H for all errors except for
physical errors (A = 255).

Upon return, register A is set to zero if the specified value is in
the range of 1 to 128. Otherwise, register A is set to $FF.

BDOS function 45: SET BDOS ERROR MODE

Entry Parameters:
&nbsp;C: $2D
&nbsp;E: BDOS Error Mode

Returned Value:
&nbsp;None

Function 45 sets the BDOS error mode for the calling program to the
mode specified in register E. If register E is set to $FF, 255
decimal, the error mode is set to Return Error mode. If register E is
set to $FE, 254 decimal, the error mode is set to Return and Display
mode. If register E is set to any other value, the error mode is set
to the default mode.

The SET BDOS Error Mode function determines how physical and extended
errors (see Section 2.2.13) are handled for a program. The Error Mode
can exist in three modes: the default mode, Return Error mode, and
Return and Display Error mode.  In the default mode, the BDOS displays
a system message at the console that identifies the error and
terminates the calling program. In the return modes, the BDOS sets
register A to $FF, 255 decimal, places an error code that identifies
the physical or extended error in register H and returns to the
calling program. In Return and Display mode, the BDOS displays the
system message before returning to the calling program. No system
messages are displayed, however, when the BDOS is in Return Error
mode.

BDOS function 46: GET DISK FREE SPACE

Entry Parameters:
&nbsp;C: $2E
&nbsp;E: Drive

Returned Value:
&nbsp;First 3 bytes of current DMA buffer
&nbsp;A: Error Flag
&nbsp;H: Physical Error

The Get Disk Free Space function determines the number of free
sectors, 128 byte records, on the specified drive. The calling program
passes the drive number in register E, with 0 for drive A, 1 for B,
and so on, through 15 for drive P in a full 16drive system. Function
46 returns a binary number in the first 3 bytes of the current DMA
buffer. This number is returned in the following format:

fso fsl fs2

Disk Free Space Field Format

fso = low byte

fsl = middle byte

fs2 = high byte

Note that the returned free space value might be inaccurate if the
drive has been marked Read-Only.

Upon return, register A is set to zero if the function is
successful. However, if the BDOS Error Mode is one of the return modes
(see Function 45), and a physical error is encountered, register A is
set to $FF, 255 decimal, and register H is set to one of the
following values:

* 01 - Disk I/O error

* 04 - Invalid drive error

BDOS function 47: CHAIN TO PROGRAM

Entry Parameters:
&nbsp;C: $2F
&nbsp;E: Chain Flag

The Chain To Program function provides a means of chaining from one
program to the next without operator intervention. The calling program
must place a command line terminated by a null byte, OOH, in the
default DMA buffer. If register E is set to $FF, the CCP initializes
the default drive and user number to the current program values when
it passes control to the specified transient program. Otherwise, these
parameters are set to the default CCP values. Note that Function 108,
Get/Set Program Return Code, can be used to pass a two byte value to
the chained program.

Function 47 does not return any values to the calling program and any
encountered errors are handled by the CCP.

BDOS function 48: FLUSH BUFFERS

Entry Parameters:
&nbsp;C: $30

Returned Value:
&nbsp;A: Error Flag
&nbsp;H: Physical Error

E: Purge Flag

The Flush Buffers function forces the write of any write-pending
records contained in internal blocking/deblocking buffers. If register
E is set to $FF, this function also purges all active data
buffers. Programs that provide write with read verify support need to
purge internal buffers to ensure that verifying reads actually access
the disk instead of returning data that is resident in internal data
buffers. The CP/M 3 PIP utility is an example of such a program.

Upon return, register A is set to zero if the flush operation is
successful. If a physical error is encountered, the Flush Buffers
function performs different actions depending on the BDOS error mode
(see Function 45). If the BDOS error mode is in the default mode„ a
message identifying the error is displayed at the console and the
calling program is terminated. Otherwise, the Flush Buffers function
returns to the calling program with register A set to $FF and
register H set to the following physical error code:

* 0 1 Disk I/O error

* 02 Read/only disk

* 04 Invalid drive error

BDOS function 49: GET/SET SYSTEM CONTROL BLOCK

Entry Parameters:
&nbsp;C: $31
&nbsp;DE: SCB PB Address

Returned Value:
&nbsp;A: Returned Byte
&nbsp;HL: Returned Word

Function 49 allows access to parameters located in the CP/M 3 System
Control Block (SCB). The SCB is a 100-byte data structure residing
within the BDOS that contains flags and data used by the BDOS, CCP and
other system components. Note that Function 49 is a CP/M 3 specific
function. Programs intended for both MP/M 11 and CP/M 3 should either
avoid the use of this function or isolate calls to this function in
CP/M 3 version-dependent sections.

To use Function 49, the calling program passes the address of a data
structure called the SCB parameter block in register pair DE. This
data structure identifies the byte or word of the SCB to be updated or
returned. The SCB parameter block is defined as:

SCBPB: DB OFFSET ; Offset within SCB
DB SET ; 0FFH if setting a byte
; 0FEH if setting a word
; 001H - 0FDH are reserved
; 000H if a get operation
DW VALUE ; Byte or word value to be set

The OFFSET parameter identifies the offset of the field within the SCB
to be updated or accessed. The SET parameter determines whether
Function 49 is to set a byte or word value in the SCB or if it is to
return a byte from the SCB. The VALUE parameter is used only in set
calls. In addition, only the first byte of VALUE is referenced in set
byte calls.

Use caution when you set SCB fields. Some of these parameters reflect
the current state of the operating system. If they are set to invalid
values, software errors can result. In general, do not use Function 49
to set a system parameter if another BDOS function can achieve the
same result. For example, Function 49 can be called to update the
Current DMA Address field within the SCB. This is not equivalent to
making a Function 26, Set DMA Address call, and updating the SCB
Current DMA field in this way would result in system errors. However,
you can use Function 49 to return the Current DMA address. The System
Control Block is summarized in 10.1.

If Function 49 is called with the OFFSET parameter of the SCB
parameter block greater than $63, the function performs no action but
returns with registers A and HL set to zero.

BDOS function 50: DIRECT BIOS CALLS

Entry Parameters:
&nbsp;C: $32
&nbsp;DE: BIOS PB Address

Returned Value:
&nbsp;BIOS RETURN

Function 50 provides a direct BIOS call through the BDOS to the
BIOS. The calling program passes the address of a data structure
called the BIOS Parameter Block (BIOSPB) in register pair DE. The
BIOSPB contains the BIOS function number and register contents as
shown below:

BIOSPB: db FUNC ; BIOS function no.
db AREG ; A register contents
dw BCREG ; BC register contents
dw DEREG ; DE register contents
dw HLREG ; HL register contents

System Reset (Function 0) is equivalent to Function 50 with a BIOS
function number of 1.

Note that the register pair BIOSPB fields (BCREG, DEREG, HLREG) arc
defined in low byte, high byte order. For example, in the BCREG field,
the first byte contains the C register value, the second byte contains
the B register value.  Under CP/M 3, direct BIOS calls via the BIOS
jump vector are only supported for the BIOS Console I/O and List
functions. You must use Function 50 to call any other

BIOS functions. In addition, Function 50 intercepts BIOS Function 27
(Select Memory) calls and returns with register A set to zero. Refer
to the CPIM Plus (CP/M Version 3) Operating System System Guide for
the definition of the BIOS functions and their register passing and
return conventions.

BDOS function 59: LOAD OVERLAY

Entry Parameters:
&nbsp;C: $3B
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Error Code
&nbsp;H: Physical Error

Only transient programs with an RSX header can use the Load Overlay
function because BDOS Function 59 is supported by the LOADER
module. The calling program must have a header to force the LOADER to
remain resident after the program is loaded (see Section 1.3).

Function 59 loads either an absolute or relocatable
module. Relocatable modules are identified by a filetype of
PRL. Function 59 does not call the loaded module.

The referenced FCB must be successfully opened before Function 59 is
called. The load address is specified in the first two random record
bytes of the FCB, rO and rl.  The LOADER returns an error if the load
address is less than $100, or if performing the requested load
operation would overlay the LOADER, or any other Resident System
Extensions that have been previously loaded.

When loading relocatable files, the LOADER requires enough room at the
load address for the complete PRL file including the header and bit
map (see Appendix B).  Otherwise an error is returned. Function 59
also returns an error on PRL file load requests if the specified load
address is not on a page boundary.

Upon return, Function 59 sets register A to zero if the load operation
is successful.  If the LOADER RSX is not resident in memory because
the calling program did not have a RSX header, the BDOS returns with
register A set to $FF and register H set to zero. If the LOADER
detects an invalid load address, or if insufficient memory is
available to load the overlay, Function 59 returns with register A set
to $FE. All other error returns are consistent with the error codes
returned by BDOS Function 20, Read Sequential.

BDOS function 60: CALL RESIDENT SYSTEM EXTENSION

Entry Parameters:
&nbsp;C: $3C
&nbsp;DE: RSX PB Address

Returned Value:
&nbsp;A: Error Code
&nbsp;H: Physical Error

Function 60 is a special BDOS function that you use when you call
Resident System Extensions. The RSX subfunction is specified in a
structure called the RSX Parameter Block, defined as follows:

RSXPB: db FUNC ; RSX Function number
db NUMPARMS ; Number of word Parameters
dw PARMETER1 ; Parameter I
dw PARMETER2 ; Parameter 2
. . .
dw PARMETERN ; Parameter n

RSX modules filter all BDOS calls and capture RSX function calls that
they can handle. If there is no RSX module present in memory that can
handle a specific RSX function call, the call is not trapped, and the
BDOS returns $FF in registers A and L. RSX function numbers from 0 to
127 are available for CP/M 3 compatible software use. RSX function
numbers 128 to 255 are reserved for system use.

BDOS function 98: FREE BLOCKS

Entry Parameters:
&nbsp;C: $62

Returned Value:
&nbsp;A: Error Flag
&nbsp;H: Physical Error

The Free Blocks function scans all the currently logged-in drives, and
for each drive returns to free space all temporarily-allocated data
blocks. A temporarily-allocated data block is a block that has been
allocated to a file by a BDOS write operation but has not been
permanently recorded in the directory by a BDOS close operation. The
CCP calls Function 98 when it receives control following a system warm
start. Be sure to close your file, particularly any file you have
written to, prior to calling Function 98.

In the nonbanked version of CP/M 3, Function 98 frees only temporarily
allocated blocks for systems that request double allocation vectors in
GENCPM.

Upon return, register A is set to zero if Function 98 is
successful. If a physical error is encountered, the Free Blocks
function performs different actions depending on the BDOS error mode
(see Function 45). If the BDOS error mode is in the default mode, a
message identifying the error is displayed at the console and the
calling program is terminated. Otherwise, the Free Blocks function
returns to the calling program with register A set to $FF and
register H set to the following physical error code:

* 04 : Invalid drive error

BDOS function 99: TRUNCATE FILE

Entry Parameters:
&nbsp;C: $63
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Directory Code
&nbsp;H: Extended or Physical Error

The Truncate File function sets the last record of a file to the
random record number contained in the referenced FCB. The calling
program passes the address of the FCB in register pair DE, with byte 0
of the FCB specifying the drive, bytes 1 through 11 specifying the
filename and filetype, and bytes 33 through 35, rO, rl, and r2,
specifying the last record number of the file. The last record number
is a 24 bit value, stored with the least significant byte first, rO,
the middle byte next, rl, and the high byte last, r2. This value can
range from 0 to 262,143, which corresponds to a maximum value of 3 in
byte r2.

If the file specified by the referenced FCB is password protected, the
correct password must be placed in the first eight bytes of the
current DMA buffer, or have been previously established as the default
password (see Function 106).

Function 99 requires that the file specified by the FCB not be open,
particularly if the file has been written to. In addition, any
activated FCBs naming the file are not valid after Function 99 is
called. Close your file before calling Function 99, and then reopen it
after the call to continue processing on the file.

Function 99 also requires that the random record number field of the
referenced FCB specify a value less than the current file size. In
addition, if the file is sparse, the random record field must specify
a record in a region of the file where data exists.

Upon return, the Truncate function returns a Directory Code in
register A with the value 0 if the Truncate function is successful, or
$FF, 255 decimal, if the file is not found or the record number is
invalid. Register H is set to zero in both of these cases. If a
physical or extended error is encountered, the Truncate function
performs different actions depending on the BDOS error mode (see
Function 45). If the BDOS error mode is in the default mode, a message
identifying the error is displayed at the console and the program is
terminated. Otherwise, the Truncate function returns to the calling
program with register A set to $FF and register H set to one of the
following physical or extended error codes:

* 01 Disk I/O error

* 02 Read-Only disk

* 03 Read-Only file

* 04 Invalid drive error

* 07 File password error

* 09 ? in filename or filetype field

BDOS function 100: SET DIRECTORY LABEL

Entry Parameters:
&nbsp;C: $64
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Directory Code
&nbsp;H: Physical or Extended Error

The Set Directory Label function creates a directory label, or updates
the existing directory label for the specified drive. The calling
program passes in register pair DE the address of an FCB containing
the name, type, and extent fields to be assigned to the directory
label. The name and type fields of the referenced FCB are not used to
locate the directory label in the directory; they are simply copied
into the updated or created directory label. The extent field of the
FCB, byte 12, contains the user's specificat-on of the directory label
data byte. The definition of the directory label data byte is:

bit&nbsp;7 - Require passwords for password-protected files (Not
supported in nonbanked CP/M 3 systems)
bit&nbsp;6 - Perform access date and time stamping
bit&nbsp;5 - Perform update date and time stamping
bit&nbsp;4 - Perform create date and time stamping
bit&nbsp;0 - Assign a new password to the directory label

If the current directory label is password protected, the correct
password must be placed in the first eight bytes of the current DMA,
or have been previously established as the default password (see
Function 106). If bit 0, the low-order bit, of byte 12 of the FCB is
set to 1, it indicates that a new password for the directory label has
been placed in the second eight bytes of the current DMA.

Note that Function 100 is implemented as an RSX, DIRLBL.RSX, in
nonbanked CP/M 3 systems. If Function 100 is called in nonbanked
systems when the DIRLBL.RSX is not resident an error code of $0FF is
returned.

Function 100 also requires that the referenced directory contain SFCBs
to activate date and time stamping on the drive. If an attempt is made
to activate date and time stamping when no SFCBs exist, Function 100
returns an error code of $FF in register A and performs no
action. The CP/M 3 INITDIR utility initializes a directory for date
and time stamping by placing an SFCB record in every fourth entry of
the directory.

Function 100 returns a Directory Code in register A with the value 0
if the directory label create or update is successful, or $FF, 255
decimal, if no space exists in the referenced directory to create a
directory label, or if date and time stamping was requested and the
referenced directory did not contain SFCBS. Register H is set to zero
in both of these cases. If a physical error or extended error is
encountered, Function 100 performs different actions depending on the
BDOS error mode (see Function 45). If the BDOS error mode is the
default mode, a message identifying the error is displayed at the
console and the calling program is terminated. Otherwise, Function 100
returns to the calling program with register A set to $FF and
register H set to one of the following physical or extended error
codes:

* 01 Disk I/O error

* 02 Read-Only disk

* 04 Invalid drive error

* 07 File password error

BDOS function 101: RETURN DIRECTORY LABEL DATA

Entry Parameters:
&nbsp;C: $65
&nbsp;E: Drive

Returned Value:
&nbsp;A: Directory Label Data Byte
&nbsp;H: Physical Error

The Return Directory Label Data function returns the data byte of the
directory label for the specified drive. The calling program passes
the drive number in register E with 0 for drive A, 1 for drive B, and
so on through 15 for drive P in a full sixteen drive system. The
format of the directory label data byte is shown below:

bit&nbsp;7 - Require passwords for password protected files
bit&nbsp;6 - Perform access date and time stamping
bit&nbsp;5 - Perform update date and time stamping
bit&nbsp;4 - Perform create date and time stamping
bit&nbsp;0 - Directory label exists on drive

Function 101 returns the directory label data byte to the calling
program in register A. Register A equal to zero indicates that no
directory label exists on the specified drive. If a physical error is
encountered by Function 101 when the BDOS Error mode is in one of the
return modes (see Function 45), this function returns with register A
set to $FF, 25S decimal, and register H set to one of the following:

* 01 Disk I/O error

* 04 Invalid drive error

BDOS function 102: READ FILE DATE STAMPS AND PASSWORD MODE

Entry Parameters:
&nbsp;C: $66
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Directory Code
&nbsp;H: Physical Error

Function 102 returns the date and time stamp information and password
mode for the specified file in byte 12 and bytes 24 through 32 of the
specified FCB. The calling program passes in register pair DE, the
address of an FCB in which the drive, filename, and filetype fields
have been defined.

If Function 102 is successful, it sets the following fields in the
referenced FCB:

&nbsp;byte 12 : Password mode field
bit&nbsp;7 - Read mode
bit&nbsp;6 - Write mode
bit&nbsp;4 - Delete mode

Byte 12 equal to zero indicates the file has not been assigned a
password. In nonbanked systems, byte 12 is always set to zero.

&nbsp;byte 24 - 27 Create or Access time stamp field
&nbsp;byte 28 - 31 Update time stamp field

The date stamp fields are set to binary zeros if a stamp has not been
made. The format of the time stamp fields is the same as the format of
the date and time structure described in Function 104.

Upon return, Function 102 returns a Directory Code in register A with
the value zero if the function is successful, or $FF, 255 decimal, if
the specified file is not found. Register H is set to zero in both of
these cases. If a physical or extended error is encountered, Function
102 performs different actions depending on the BDOS error mode (see
Function 45). If the BDOS error mode is in the default mode, a message
identifying the error is displayed at the console and the calling
program is terminated. Otherwise, Function 102 returns to the calling
program with register A set to $FF and register H set to one of the
following physical or extended error codes:

* 01 Disk I/O error

* 04 Invalid drive error

* 09 ? in filename or filetype field

BDOS function 103: WRITE FILE XFCB

Entry Parameters:
&nbsp;C: $67
&nbsp;DE: FCB Address

Returned Value:
&nbsp;A: Directory Code
&nbsp;H: Physical Error

The Write File XFCB function creates a new XFCB or updates the
existing XFCB for the specified file. The calling program passes in
register pair DE the address of an FCB in which the drive, name, type,
and extent fields have been defined. The extent field specifies the
password mode and whether a new password is to be assigned to the
file. The format of the extent byte is shown below:

FCB byte 12 (ex) : XFCB password mode
bit&nbsp;7 - Read mode
bit&nbsp;6 - Write mode
bit&nbsp;5 - Delete mode
bit&nbsp;0 - Assign new password to the file

If the specified file is currently password protected, the correct
password must reside in the first eight bytes of the current DMA, or
have been previously established as the default password (see Function
106). If bit 0 is set to 1, the new password must reside in the second
eight bytes of the current DMA.

Upon return, Function 103 returns a Directory Code in register A with
the value zero if the XFCB create or update is successful, or $FF,
255 decimal, if no directory label exists on the specified drive, or
the file named in the FCB is not found, or no space exists in the
directory to create an XFCB. Function 103 also returns with $FF in
register A if passwords are not enabled by the referenced directory's
label. On nonbanked systems, this function always returns with
register A = $FF because passwords are not supported. Register H is
set to zero in all of these cases. If a physical or extended error is
encountered, Function 103 performs different actions depending on the
BDOS error mode (see Function 45). If the BDOS error mode is the
default mode, a message identifying the error is displayed at the
console and the calling program is terminated. Otherwise, Function 103
returns to the calling program with register A set to $FF and
register H set to one of the following physical or extended error
codes:

* 01 Disk I/O error

* 02 Read-Only disk

* 04 Invalid drive error

* 07 File password error

* 09 ? in filename or filetype field

BDOS function 104: SET DATE AND TIME

Entry Parameters:
&nbsp;C: $68
&nbsp;DE: DAT Address

Returned Value:
&nbsp;none

The Set Date and Time function sets the system internal date and
time. The calling program passes the address of a 4-byte structure
containing the date and time specification in the register pair
DE. The format of the date and time (DAT) data structure is:

byte&nbsp;0 - 1 Date field
byte&nbsp;2 Hour field
byte&nbsp;3 Minute field

The date is represented as a 16-bit integer with day 1 corresponding
to January 1, 1978. The time is represented as two bytes: hours and
minutes are stored as two BCD digits.

This function also sets the seconds field of the system date and time
to zero.

BDOS function 105: GET DATE AND TIME

Entry Parameters:
&nbsp;C: $69
&nbsp;DE: DAT Address

Returned Value:
&nbsp;A: seconds
&nbsp;DAT set

The Get Date and Time function obtains the system internal date and
time. The calling program passes in register pair DE, the address of a
4-byte data structure which receives the date and time values. The
format of the date and time, DAT, data structure is the same as the
format described in Function 104. Function 105 also returns the
seconds field of the system date and time in register A as a two digit
BCD value.

BDOS function 106: SET DEFAULT PASSWORD

Entry Parameters:
&nbsp;C: $6A
&nbsp;DE: Password Address

Returned Value:
&nbsp;none

The Set Default Password function allows a program to specify a
password value before a file protected by the password is
accessed. When the file system accesses a password-protected file, it
checks the current DMA, and the default password for the correct
value. If either value matches the file's password, full access to the
file is allowed. Note that this function performs no action in
nonbanked CP/M 3 systems because file passwords are not supported.

To make a Function 106 call, the calling program sets register pair DE
to the address of an 8-byte field containing the password.

BDOS function 107: RETURN SERIAL NUMBER

Entry Parameters:
&nbsp;C: $6B
&nbsp;DE: Serial Number Field

Returned Value:
&nbsp;Serial number field set

Function 107 returns the CP/M 3 serial number to the 6-byte field
addressed by register pair DE.

BDOS function 108: GET/SET PROGRAM RETURN CODE

Entry Parameters:
&nbsp;C: $6C
&nbsp;DE: $0FFFF (Get) or Program Return Code (Set)

Returned Value:
&nbsp;HL: Program Return Code or (no value)

CP/M 3 allows programs to set a return code before terminating. This
provides a mechanism for programs to pass an error code or value to a
following job step in batch environments. For example, Program Return
Codes are used by the CCP in CP/M 3's conditional command line batch
facility. Conditional command lines are command lines that begin with
a colon, :. The execution of a conditional command depends on the
successful execution of the preceding command. The CCP tests the
return code of a terminating program to determine whether it
successfully completed or terminated in error. Program return codes
can also be used by programs to pass an error code or value to a
chained program (see Function 47, Chain To Program).

A program can set or interrogate the Program Return Code by calling
Function 108. If re 'ster pair DE = $FFFF, then the current Program
Return Code is returned in register pair HL. Otherwise, Function 108
sets the Program Return Code to the 'value contained in register pair
DE. Program Return Codes are defined in 10.2

BDOS function 109: GET/SET CONSOLE MODE

Entry Parameters:
&nbsp;C: $6D
&nbsp;DE: $FFFF (Get) or Console Mode (Set)

Returned Value:
&nbsp;HL: Console Mode or (no value)

A program can set or interrogate the Console Mode by calling Function
109. If register pair DE = $FFFF, then the current Console Mode is
returned in register HL. Otherwise, Function 109 sets the Console Mode
to the value contained in register pair DE.

The Console Mode is a 16-bit system parameter that determines the
action of certain BDOS Console I/O functions. The definition of the
Console Mode is:

bit 0&nbsp;= 1 - CTRL-C only status for Function 1 1.
= 0 - Normal status for Function 1 1.
bit 1&nbsp;= 1- Disable stop scroll, CTRL-S, start scroll, CTRL-Q,
support.
= 0-Enable stop scroll, start scroll support.
bit 2&nbsp;= 1- Raw console output mode. Disables tab expansion for
Functions 2, 9 and 111. Also disables printer echo, CTIRL-P,
support.
= 0 - Normal console output mode.
bit 3&nbsp;= 1 - Disable CTRL-C program termination
= 0 - Enable CTRL-C program termination
bits 8,9&nbsp;-Console status mode for RSXs that perform console
input redirection from a file. These bits determine how the RSX
responds to console status requests.
&nbsp;bit 8 = 0, bit 9 = 0 - conditional status

&nbsp;bit 8 = 0, bit 9 = 1 - false status

&nbsp;bit 8 = 1, bit 9 = 0 - true status

&nbsp;bit 8 = 1, bit 9 = 1 - bypass redirection

Note that the Console Mode bits are numbered from right to left.

The CCP initializes the Console Mode to zero when it loads a program
unless the program has an RSX that overrides the default value. Refer
to Section 2.2.1 for detailed information on Console Mode.

BDOS function 110: GET/SET OUTPUT DELIMITER

Entry Parameters:
&nbsp;C: $6E
&nbsp;DE: $FFFF (Get) or
&nbsp;E: Output Delimiter (Set)

Returned Value:
&nbsp;A: Output Delimiter or (no value)

A program can set or interrogate the current Output Delimiter by
calling Function 110. If register pair DE = $FFFF, then the current
Output Delimiter is returned in register A. Otherwise, Function 110
sets the Output Delimiter to the value contained in register E.

Function 110 sets the string delimiter for Function 9, Print
String. The default delimiter value is a dollar sign, $. The CCP
restores the Output Delimiter to the default value when a transient
program is loaded.

BDOS function 111: PRINT BLOCK

Entry Parameters:
&nbsp;C: $6F
&nbsp;DE: CCB Address

Returned Value:
&nbsp;none

The Print Block function sends the character string located by the
Character Control Block, CCB, addressed in register pair DE, to the
logical console, CONOUT:. If the Console Mode is in the default state
(see Section 2.2.1), Function 111 expands tab characters, CTRL-I, in
columns of eight characters. It also checks for stop scroll, CTRL-S,
start scroll, CTRL-Q, and echoes to the logical list device, LST:, if
printer echo, CTRL-P, has been invoked.

The CCB format is:
byte&nbsp;0 - 1 Address of character string (word value)
byte&nbsp;2 - 3 Length of character string (word value)

BDOS function 112: LIST BLOCK

Entry Parameters:
&nbsp;C: $70
&nbsp;DE: CCB Address

Returned Value:
&nbsp;none

The List Block function sends the character string located by the
Character Control Block, CCB, addressed in register pair DE, to the
logical list device, LST:.

The CCB format is:
byte&nbsp;0 - 1 Address of character string (word value)
byte&nbsp;2 - 3 Length of character string (word value)

BDOS function 152: PARSE FILENAME

Entry Parameters:
&nbsp;C: $98
&nbsp;DE: PFCB Address

Returned Value:
&nbsp;HL: Return code
&nbsp;Parsed file control block

The Parse Filename function parses an ASCII file specification and
prepares a File Control Block, FCB. The calling program passes the
address of a data structure called the Parse Filename Control Block,
PFCB, in register pair DE. The PFCB contains the address of the input
ASCII filename string followed by the address of the target FCB as
shown below:

PFCB: DW INPUT ; Address of input ASCII string
DW FCB ; Address of target FCB

The maximum length of the input ASCII string to be parsed is 128
bytes. The target FCB must be 36 bytes in length.

Function 152 assumes the input string contains file specifications in
the following form:

{d:}filename{.typ}{;password}

where items enclosed in curly brackets are optional. Function 152 also
accepts isolated drive specifications d: in the input string. When it
encounters one, it sets the filename, filetype, and password fields in
the FCB to blank.

The Parse Filename function parses the first file specification it
finds in the input string. The function first eliminates leading
blanks and tabs. The function then assumes that the file specification
ends on the first delimiter it encounters that is out of context with
the specific field it is parsing. For instance, if it finds a colon,
and it is not the second character of the file specification, the
colon delimits the entire file specification.

Function 152 recognizes the following characters as detimiters:

&nbsp;space
&nbsp;tab
&nbsp;return
&nbsp;nut]
&nbsp;; (semicolon) - except before password field
&nbsp;= (equal)
&nbsp;img72.svg"
ALT="\(&lt;\)"> (less than)
&nbsp;img71.svg"
ALT="\(&gt;\)"> (greater than)
&nbsp;. (period) - except after filename and before filetype
&nbsp;: (colon) - except before filename and after drive
&nbsp;, (comma)
&nbsp;img70.svg"
ALT="\(\vert\)"> (vertical bar)
&nbsp;[ (left square bracket)
&nbsp;] (right square bracket)

If Function 152 encounters a non-graphic character in the range 1
through 31 not listed above, it treats the character as an error. The
Parse Filename function initializes the specified FCB shown in
10.3.

If an error occurs, Function 152 returns an $FFFF in register pair
HL.

On a successful parse, the Parse Filename function checks the next
item in the input string. It skips over trailing blanks and tabs and
looks at the next character. If the character is a null or carriage
return, it returns a 0 indicating the end of the input string. If the
character is a delimiter, it returns the address of the delimiter. If
the character is not a delimiter, it returns the address of the first
trailing blank or tab.

If the first non-blank or non-tab character in the input string is a
null, 0, or carriage return, the Parse Filename function returns a
zero indicating the end of string.

If the Parse Filename function is to be used to parse a subsequent
file specification in the input string, the returned address must be
advanced over the delimiter before placing it in the PFCB.

@node NODE140


@{h2}BIOS


------------------------------------------
Subsections

@{ "System Initialization Functions" LINK NODE141 }

@{ "Character I/O Functions" LINK NODE142 }

@{ "Disk I/O Functions" LINK NODE143 }


------------------------------------------
@node NODE141


@{h3}System Initialization Functions

This section defines the BIOS system initialization routines BOOT,
WBOOT, DEVTBL, DEVINI, and DRVTBL.

BIOS Function 0: BOOT

Get Control from Cold Start Loader and Initialize System

Entry Parameters: None

Returned Values: None

The BOOT entry point gets control from the Cold Start Loader in Bank 0
and is responsible for basic system initialization. Any remaining
hardware initialization that is not done by the boot ROMS, the Cold
Boot Loader, or the LDRBIOS should be performed by the BOOT routine.

BIOS Function 1: WBOOT

Get Control When a Warm Start Occurs

Entry Parameters: None

Returned Values: None

The WBOOT entry point is entered when a warm start occurs. A warm
start is performed whenever a user program branches to location 0000H
or attempts to return to the CCP.

BIOS Function 20: DEVTBL

Return Address of Character I/O Table

Entry Parameters: None

Returned Values: HL=address of Chrtbl

The DEVTBL and DEVINI entry points allow you to support device
assignment with a flexible, yet completely optional system. It
replaces the IOBYTE facility of CP/M 2.2.

BIOS Function 21: DEVINI

Initialize Character I/O Device

Entry Parameters: C=device number, 0-15

Returned Values: None

The DEVINI routine initializes the physical character device specified
in register C to the baud rate contained in the appropriate entry of
the CHRTBL.

BIOS Function 22: DRVTBL

Return Address of Disk Drive Table

Entry Parameters: None

Returned Values:
&nbsp;HL=Address of Drive Table of Disk Parameter Headers (DPH);
Hashing can utilized if specified by the DPHs Referenced by this
DRVTBL.
&nbsp;HL=$ffff if no Drive Table; GENCPM does not set up buffers.
Hashing is supported.
&nbsp;HL=$fffe if no Drive Table; GENCPM does not set up buffers.
Hashing is not supported.

The first instruction of this subroutine must be an LXI H,&lt;address&gt;
where &lt;address&gt; is one of the above returned values. The GENCPM
utility accesses the address in this instruction to locate the drive
table and the disk parameter data structures to determine which system
configuration to use.

@node NODE142


@{h3}Character I/O Functions

This section defines the CP/M 3 character I/O routines CONST, CONIN,
CONOUT, LIST, AUXOUT, AUXIN, LISTST, CONOST, AUXIST, and AUXOST.  CP/M
3 assumes all simple character I/O operations are performed in
eight-bit ASCII, upper and lowercase, with no parity. An ASCII CTRL-Z
($1a) denotes an end-of-file condition for an input device.

In CP/M 3, you can direct each of the five logical character devices
to any combination of up to twelve physical devices. Each of the five
logical devices has a 16-bit vector in the System Control Block (SCB)
. Each bit of the vector represents a physical device where bit 15
corresponds to device zero, and bit 4 is device eleven. Bits 0 through
3 are reserved for future system use.

BIOS Function 2: CONST

Sample the Status of the Console Input Device

Entry Parameters: None

Returned value:
&nbsp;A=$ff if a console character is ready to read
&nbsp;A=$00 if no console character is ready to read

Read the status of the currently assigned console device and return
$ff in register A if a character is ready to read, and $ff in
register A if no console characters are ready.

BIOS Function 3: CONIN

Read a Character from the Console

Entry Parameters: None

Returned Values: A=Console Character

Read the next console character into register A with no parity. If no
console character is ready, wait until a character is available before
returning.

BIOS Function 4: CONOUT

Output Character to Console

Entry Parameters: C=Console Character

Returned Values: None

Send the character in register C to the console output device. The
character is in ASCII with no parity.

BIOS Function 5: LIST

Output Character to List Device

Entry Parameters: C=Character

Returned Values: None

Send the character from register C to the listing device. The
character is in ASCII with no parity.

BIOS Function 6: AUXOUT

Output a Character to the Auxiliary Output Device

Entry Parameters: C=Character

Returned Values: None

Send the character from register C to the currently assigned AUXOUT
device. The character is in ASCII with no parity.

BIOS Function 7: AUXIN

Read a Character from the Auxiliary Input Device

Entry Parameters: None

Returned Values: A=Character

Read the next character from the currently assigned AUXIN device into
register A with no parity. A returned ASCII CTRL-Z ($1a) reports an
end-of-file.

BIOS Function 15: LISTST

Return the Ready Status of the List Device

Entry Parameters: None

Returned Values:
&nbsp;A=$00 if list device is not ready to accept a character
&nbsp;A=$ff if list device is ready to accept a character

BIOS Function 17: CONOST

Return Output Status of Console

Entry Parameters: None

Returned Values:
&nbsp;A=$ff if ready
&nbsp;A=$00 if not ready

The CONOST routine checks the status of the console. CONOST returns an
$ff if the console is ready to display another character. This entry
point allows for full polled handshaking communications support.

BIOS Function 18: AUXIST

Return Input Status of Auxiliary Port

Entry Parameters: None

Returned Values:
&nbsp;A=$ff if ready
&nbsp;A=$00 if not ready

The AUXIST routine checks the input status of the auxiliary port. This
entry point allows full polled handshaking for communications support
using an auxiliary port.

BIOS Function 19: AUXOST

Return Output Status of Auxiliary Port

Entry Parameters: None

Returned Values:
&nbsp;A=$ff if ready
&nbsp;A=$00 if not ready

The AUXOST routine checks the output status of the auxiliary
port. This routine allows full polled handshaking for communications
support using an auxiliary port.

@node NODE143


@{h3}Disk I/O Functions

This section defines the CP/M 3 BIOS disk I/O routines HOME, SELDSK,
SETTRK, SETSEC, SETDMA, READ, WRITE, SECTRN, MULTIO, and FLUSH.

BIOS Function 8: HOME

Select Track 00 of the Specified Drive

Entry Parameters: None

Returned Values: None

Return the disk head of the currently selected disk to the track 00
position. Usually, you can translate the HOME call into a call on
SETTRK with a parameter of 0.

BIOS Function 9: SELDSK

Select the Specified Disk Drive

Entry Parameters:
&nbsp;C=Disk Drive (0-15)
&nbsp;E=Initial Select Flag

Returned Values:
&nbsp;HL=Address of Disk Parameter Header (DPH) if drive exists
&nbsp;HL=0000H if drive does not exist

Select the disk drive specified in register C for further operations,
where register C contains 0 for drive A, 1 for drive B, and so on to
15 for drive P. On each disk select, SELDSK must return in HL the base
address of a 25-byte area called the Disk Parameter Header. If there
is an attempt to select a nonexistent drive, SELDSK returns HL=$0000
as an error indicator.  On entry to SELDSK, you can determine if it is
the first time the specified disk is selected. Bit 0, the least
significant bit in register E, is set to 0 if the drive has not been
previously selected. This information is of interest in systems that
read configuration information from the disk to set up a dynamic disk
definition table.

BIOS Function 10: SETTRK

Set Specified Track Number

Entry Parameters: BC=Track Number

Returned Values: None

Register BC contains the track number for a subsequent disk access on
the currently selected drive. Normally, the track number is saved
until the next READ or WRITE occurs.

BIOS Function 11: SETSEC

Set Specified Sector Number

Entry Parameters: BC=Sector Number

Returned Values: None

Register BC contains the sector number for the subsequent disk access
on the currently selected drive. This number is the value returned by
SECTRN. Usually, you delay actual sector selection until a READ or
WRITE operation occurs.

BIOS Function 12: SETDMA

Set Address for Subsequent Disk I/O

Entry Parameters: BC=Direct Memory Access Address

Returned Values: None

Register BC contains the DMA (Direct Memory Access) address for the
subsequent READ or WRITE operation. For example, if B = $00 and C =
$80 when the BDOS calls SETDMA, then the subsequent read operation
reads its data starting at $80, or the subsequent write operation
gets its data from 80H, until the next call to SETDMA occurs.

BIOS Function 13: READ

Read a Sector from the Specified Drive

Entry Parameters: None

Returned Values:
&nbsp;A=$00 if no errors occurred
&nbsp;A=$01 if nonrecoverable error condition occurred
&nbsp;A=$ff if media has changed

Assume the BDOS has selected the drive, set the track, set the sector,
and specified the DMA address. The READ subroutine attempts to read
one sector based upon these parameters, then returns one of the error
codes in register A as described above.

If the value in register A is $00, then CP/M 3 assumes that the disk
operation completed properly. If an error occurs, the BIOS should
attempt several retries to see if the error is recoverable before
returning the error code.

If an error occurs in a system that supports automatic density
selection, the system should verify the density of the drive. If the
density has changed, return a $ff in the accumulator. This causes the
BDOS to terminate the current operation and relog in the disk.

BIOS Function 14: WRITE

Write a Sector to the Specified Disk

Entry Parameters: C=Deblocking Codes

Returned Values:
&nbsp;A=$00 if no error occurred
&nbsp;A=$01 if physical error occurred
&nbsp;A=$02 if disk is Read-Only
&nbsp;A=$ff if media has changed

Write the data from the currently selected DMA address to the
currently selected drive, track, and sector. Upon each call to WRITE,
the BDOS provides the following information in register C:
&nbsp;0 = deferred write
&nbsp;1 = nondeferred write
&nbsp;2 = deferred write to the first sector of a new data block

This information is provided for those BIOS implementations that do
blocking/deblocking in the BIOS instead of the BDOS.

BIOS Function 16: SECTRN

Translate Sector Number Given Translate Table
Entry Parameters:
&nbsp;BC=Logical Sector Number
&nbsp;DE=Translate Table Address

Returned Values: HL=Physical Sector Number

SECTRN performs logical sequential sector address to physical sector
translation to improve the overall response of CP/M 3.

BIOS Function 23: MULTIO

Set Count of Consecutive Sectors for READ or WRITE

Entry Parameters: C=Multisector Count

Returned Values: None

To transfer logically consecutive disk sectors to or from contiguous
memory locations, the BDOS issues a MULTIO call, followed by a series
of READ or WRITE calls. This allows the BIOS to transfer multiple
sectors in a single disk operation. The maximum value of the sector
count is dependent on the physical sector size, ranging from 128 with
128-byte sectors, to 4 with 4096-byte sectors. Thus, the BIOS can
transfer up to 16K directly to or from the TPA with a single
operation.

BIOS Function 24: FLUSH

Force Physical Buffer Flushing for User-supported Deblocking

Entry Parameters: None

Returned Values:
&nbsp;A=$00 if no error occurred
&nbsp;A=$001 if physical error occurred
&nbsp;A=$002 if disk is Read-Only

The flush buffers entry point allows the system to force physical
sector buffer flushing when your BIOS is performing its own record
blocking and deblocking.  The BDOS calls the FLUSH routine to ensure
that no dirty buffers remain in memory.

@node NODE144


@{h2}Memory Select and Move Functions

This section defines the memory management functions MOVE, XMOVE,
SELMEM, and SETBNK.

BIOS Function 25: MOVE

Memory-to-Memory Block Move

Entry Parameters:
&nbsp;HL=Destination address
&nbsp;DE=Source address
&nbsp;BC=Count

Returned Values: HL and DE must point to next bytes following move
operation

The BDOS calls the MOVE routine to perform memory to memory block
moves to allow use of the Z80 LDIR instruction or special DMA
hardware, if available. Note that the arguments in HL and DE are
reversed from the Z8O machine instruction, necessitating the use of
XCHG instructions on either side of the LDIR. The BDOS uses this
routine for all large memory copy operations. On return, the HL and DE
registers are expected to point to the next bytes following the move.

Usually, the BDOS expects MOVE to transfer data within the currently
selected bank or common memory. However, if the BDOS calls the XMOVE
entry point before calling MOVE, the MOVE routine must perform an
interbank transfer.

BIOS Function 27: SELMEM

Select Memory Bank

Entry Parameters: A=Memory Bank

Returned Values; None

The SELMEM entry point is only present in banked systems. The banked
version of the CP/M 3 BDOS calls SELMEM to select the current memory
bank for further instruction execution or buffer references. You must
preserve or restore all registers other than the accumulator, A, upon
exit.

BIOS Function 28: SETBNK

Specify Bank for DMA Operation

Entry Parameters: A=Memory Bank

Returned Values: None

SETBNK only occurs in the banked version of CP/M 3. SETBNK specifies
the bank that the subsequent disk READ or WRITE routine must use for
memory transfers. The BDOS always makes a call to SETBNK to identify
the DMA bank before performing a READ or WRITE call. Note that the
BDOS does not reference banks other than 0 or 1 unless another bank is
specified by the BANK field of a Data Buffer Control Block (BCB).

BIOS Function 29: XMOVE

Set Banks for Following MOVE

Entry Parameters:
&nbsp;B=destination bank
&nbsp;C=source bank

Returned Values: None

XMOVE is provided for banked systems that support memory-to- memory
DMA transfers over the entire extended address range. Systems with
this feature can have their data buffers located in an alternate bank
instead of in common memory, as is usually required. An XMOVE call
affects only the following MOVE call. All subsequent MOVE calls apply
to the memory selected by the latest call to SELMEM. After a call to
the XMOVE function, the following call to the MOVE function is not
more than 128 bytes of data.


------------------------------------------
Subsections

@{ "Clock Support Function" LINK NODE145 }

@node NODE145


@{h3}Clock Support Function

This section defines the clock support function TIME.

BIOS Function 26: TIME

Get and Set Time

Entry Parameters: C=Time Get/Set Flag

Returned values: None

The BDOS calls the TIME function to indicate to the BIOS whether it
has just set the Time and Date fields in the SCB, or whether the BDOS
is about to get the Time and Date from the SCB. On entry to the TIME
function, a zero in register C indicates that the BIOS should update
the Time and Date fields in the SCB. A $ff in register C indicates
that the BDOS has just set the Time and Date in the SCB and the BIOS
should update its clock. Upon exit, you must restore register pairs HL
and DE to their entry values.


------------------------------------------
@node NODE146


@{h1}NextZXOS


------------------------------------------
@node NODE147


@{h1}NextZXOS

A ZX Spectrum I/O system supported by the ZX Spectrum Next. This
Documentation is largely from Garry Lancaster's DOCs at
https://gitlab.com/thesmog358/tbblue/blob/master/docs/nextzxos/NextZXOS_and_esxDOS_APIs.pdf. Before
making any calls disable writes to Layer 2 in the $0000-$3fff area with port $123b.


------------------------------------------
Subsections

@{ "+3DOS compatible API" LINK NODE148 }

@{ "esxDOS compatible API" LINK NODE149 }

@{ "Next Extensions" LINK NODE150 }

@{ "esxDOS compatible API" LINK NODE151 }


------------------------------------------
@node NODE148


@{h2}+3DOS compatible API

Generally to make these calls, you need to set up: place ROM 2 at
$0000-$3fff, RAM bank 7 at $c000-$ffff, stack below $bfe0, and
set up the parameters for the call in the indicated registers. Call
the function at its address. Then, restore your system to its previous
configuration. In general the carry bit of F is cleared on error with
the error code in A. Calls generally affect the contnts of AF, BC, DE,
HL, and IX leaving AF', BC', DE', HL', IY, and SP intact. To simplify,
descriptions will assume this is true and only indicate exceptions to
the rule.

$0056 IDE_STREAM_OPEN

Open stream to a channel

$0059 IDE_STREAM_CLOSE

Close stream and attached channel

$005c IDE_STREAM_IN

Get byte from current stream

$005f IDE_STREAM_OUT

Write byte to current stream

$0062 IDE_STREAM_PTR

Get or set pointer information for current stream

$00A0 IDE_VERSION

Get IDEDOS version number

$00A3 IDE_INTERFACE

Initialise card interfaces

$00A6 IDE_INIT

Initialise IDEDOS

$00A9 IDE_DRIVE

Get unit handle

$00AC IDE_SECTOR_READ

Low-level sector read

$00AF IDE_SECTOR_WRITE

Low-level sector write

$00B2 IDE_FORMAT

Format a partition

$00B5 IDE_PARTITION_FIND

Find named partition

$00B8 IDE_PARTITION_NEW

Create partition

$00BB IDE_PARTITION_INIT

Initialise partition

$00BE IDE_PARTITION_ERASE

Delete a partition

$00C1 IDE_PARTITION_RENAME

Rename a partition

$00C4 IDE_PARTITON_READ

Read a partition entry

$00C7 IDE_PARTITION_WRITE

Write a partition entry

$00CA IDE_PARTITION_WINFO

Write type-specific partition information

$00CD IDE_PARTITION_OPEN

Open a partition

$00D0 IDE_PARTITION_CLOSE

Close a partition

$00D3 IDE_PARTITION_GETINFO

Get byte from type-specific partition information

$00D6 IDE_PARTITION_SETINFO

Set byte in type-specific partition information

$00D9 (217) IDE_SWAP_OPEN

Open a swap partition (file)

$00DC IDE_SWAP_CLOSE

Close a swap partition

$00DF IDE_SWAP_OUT

Write block to swap partition

$00E2 IDE_SWAP_IN

Read block from swap partition

$00E5 (231) IDE_SWAP_EX

Exchange block with swap partition

Deprecated, use IDE_SWAP_IN and IDE_SWAP_OUT

$00E8 IDE_SWAP_POS

Get current block number in swap partition

$00EB IDE_SWAP_MOVE

Set current block number in swap partition

$00EE IDE_SWAP_RESIZE

Change block size of swap partition

$00F1 (241) IDE_DOS_MAP

Map drive to partition or physical device

$00F4 (244) IDE_DOS_UNMAP

Unmap drive

$00F7 (247) IDE_DOS_MAPPING

Get drive mapping

$00FA IDE_DOS_UNPERMANENT

Remove permanent drive mapping

$00FD (253) IDE_SNAPLOAD

Load a snapshot

$0100 DOS_INITIALISE

Initialise +3DOS

$0103 DOS_VERSION

Get +3DOS issue and version numbers

$0106 (262) DOS_OPEN

Create and/or open a file

$0109 DOS_CLOSE

Close a file

$010C DOS_ABANDON

Abandon a file

$010F DOS_REF_HEAD

Point at the header data for this file

$0112 DOS_READ

Read bytes into memory

$0115 DOS_WRITE

Write bytes from memory

$0118 DOS_BYTE_READ

Read a byte

$011B DOS_BYTE_WRITE

Write a byte

$011E (286) DOS_CATALOG

Catalog disk directory

$0121 (289) DOS_FREE_SPACE

Free space on disk

$0124 DOS_DELETE

Delete a file

$0127 DOS_RENAME

Rename a file

$012A DOS_BOOT

Boot an operating system or other program

$012D DOS_SET_DRIVE

Set/get default drive

$0130 DOS_SET_USER

Set/get default user number

$0133 (307) DOS_GET_POSITION

Get file pointer for random access

$0136 DOS_SET_POSITION

Set file pointer for random access

$0139 (313) DOS_GET_EOF

Get end of file position for random access

$013C DOS_GET_1346

Get memory usage in pages 1&nbsp; 3&nbsp; 4&nbsp; 6

$013F DOS_SET_1346

Re-allocate memory usage in pages 1&nbsp; 3&nbsp; 4&nbsp; 6

$0142 DOS_FLUSH

Bring disk up to date

$0145 DOS_SET_ACCESS

Change open file's access mode

$0148 DOS_SET_ATTRIBUTES

Change a file's attributes

$014B DOS_OPEN_DRIVE

Open a drive as a single file

$014E DOS_SET_MESSAGE

Enable/disable error messages

$0151 DOS_REF_XDPB

Point at XDPB for low level disk access

$0154 DOS_MAP_B

Map B: onto unit 0 or 1

$0157 DD_INTERFACE

Is the floppy disk driver interface present?

$015A DD_INIT

Initialise disk driver

$015D DD_SETUP

Specify drive parameters

$0160 DD_SET_RETRY

Set try/retry count

$0163 DD_READ_SECTOR

Read a sector

$0166 DD_WRITE_SECTOR

Write a sector

$0169 DD_CHECK_SECTOR

Check a sector

$016C DD_FORMAT

Format a track

$016F DD_READ_ID

Read a sector identifier

$0172 DD_TEST_UNSUITABLE

Test media suitability

$0175 DD_LOGIN

Log in disk, initialise XDPB

$0178 DD_SEL_FORMAT

Pre-initialise XDPB for DD FORMAT

$017B DD_ASK_1

Is unit 1 (external drive) present?

$017E DD_DRIVE_STATUS

Fetch drive status

$0181 DD_EQUIPMENT

What type of drive?

$0184 DD_ENCODE

Set intercept routine for copy protection

$0187 DD_L_XDPB

Initialise an XDPB from a disk specification

$018A DD_L_DPB

Initialise a DPB from a disk specification

$018D DD_L_SEEK

uPD765A seek driver

$0190 DD_L_READ

uPD765A read driver

$0193 DD_L_WRITE

uPD765A write driver

$0196 DD_L_ON_MOTOR

Motor on, wait for motor-on time

$0199 DD_L_T_OFF_MOTOR

Start the motor-off ticker

$019C DD_L_OFF_MOTOR

Turn the motor off

$01a2 IDE_IDENTIFY

Return IDE drive identity information

$01a5 IDE_PARTITIONS

Get number of open partitions

$01b1 (433) IDE_PATH

Create, delete, change or get directory

$01b4 (436) IDE_CAPACITY

Get card capacity

$01b7 (439) IDE_GET_LFN

Get long filename

Obtain a long file name and other file information.

$01ba (442) IDE_BROWSER

File browser

$01bd (445) IDE_BANK

Allocate or free 8K pages in ZX or DivMMC memory

$01c0 IDE_BASIC

Execute a BASIC command line

$01c3 IDE_WINDOW_LINEIN

Input line from current window stream

$01c6 IDE_WINDOW_STRING

Output string to current window stream

$01c9 IDE_INTEGER_VAR

Get or set NextBASIC integer variable

$01cc IDE_RTC

Query the real-time-clock module

$01cf IDE_DRIVER

Access the driver API

$01d2 IDE_MOUNT

Unmount/remount SD cards

$01d2 IDE_MOUNT

Unmount/remount SD cards

$01d5 IDE_MODE

Query NextBASIC display mode info, or change mode

$01d8 IDE_TOKENISER

Convert BASIC between plain text &amp; tokenised forms

@node NODE149


@{h2}esxDOS compatible API


------------------------------------------
@node NODE150


@{h2}Next Extensions

$0085 DISK_FILEMAP

img76.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_disk_filemap(uint8_t handle,struct esx_filemap *fmap)
\end{lstlisting}">

Obtain a map of card addresses describing the space occupies by the
file. Can be called multiple times if the buffer is filled, continuing
from previous.

DISK_STREAM_BYTES

img77.svg"
ALT="\begin{lstlisting}[language=C]
void *esx_disk_stream_bytes(void *dst,uint16_t len)
\end{lstlisting}">

$0087 DISK_STREAM_END

img78.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_disk_stream_end(void)
\end{lstlisting}">

Stop current streaming operation.

DISK_STREAM_SECTORS

img79.svg"
ALT="\begin{lstlisting}[language=C]
void *esx_disk_stream_sectors(void *dst,uint8_t sectors)
\end{lstlisting}">

$0086 DISK_STREAM_START

img80.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_disk_stream_start(struct esx_filemap_entry *entry)
\end{lstlisting}">

Start reading from the card in streaming mode.

DOS_CATALOG

img81.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_dos_catalog(struct esx_cat *cat)
\end{lstlisting}">

DOS_CATALOG_NEXT

img82.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_dos_catalog_next(struct esx_cat *cat)
\end{lstlisting}">

DOS_GETSET_DRIVE

img83.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_dos_get_drive(void)
unsigned char esx_dos_set_drive(unsigned char drive)
\end{lstlisting}">


------------------------------------------
@node NODE151


@{h2}esxDOS compatible API

The esxDOS-compatible API is a bit simpler to use than the
+3DOS-compatible API.

To make a call, you only need to set up the entry parameters as
indicated and perform a RST $08; DEFB hook_code. On return, registers
AF,BC,DE,HL will all be changed. IX,IY and the alternate registers are
never changed (except for M_P3DOS).

(Note that the standard 48K BASIC ROM must be paged in to the bottom
of memory, but this is the usual situation after starting a machine
code program with a USR function call).

Notice that error codes are different from those returned by +3DOS
calls, and also the carry flag is SET for an error condition when
returning from an esxDOS call (instead of RESET, as is the case for
+3DOS).

If desired, you can use the M_GETERR hook to generate a BASIC error
report for any error returned, or even use it to generate your own
custom BASIC error report.

All of the calls where a filename is specified will accept long
filenames (LFNs) and most will accept wildcards (for an operation such
as F_OPEN where a single file is always used, the first matching
filename will be used).

$00A9 F_CHDIR

img84.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_chdir(unsigned char *pathname)
\end{lstlisting}">

Change directory.

$00AF F_CHMOD

img85.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_chmod(unsigned char *filename, uint8_t attr_mask, uint8_t attr)
\end{lstlisting}">

Modify file attributes.

$009BF_CLOSE

img86.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_close(unsigned char handle)
\end{lstlisting}">

Close a file or directory.

F_CLOSEDIR

img87.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_closedir(unsigned char handle)
\end{lstlisting}">

$00A0 F_FGETPOS

img88.svg"
ALT="\begin{lstlisting}[language=C]
uint32_t esx_f_fgetpos(unsigned char handle)
\end{lstlisting}">

Get current file position.

$00A1 F_FSTAT

img89.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_fstat(unsigned char handle, struct esx_stat *es)
\end{lstlisting}">

Get file information/status.

$00A2 F_FTRUNC

img90.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_ftrunc(unsigned char handle, uint32_t size)
\end{lstlisting}">

Truncate/extend file.

F_GET_CANONICAL_PATH

img91.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_get_canonical_path(char *pathname, char *canonical)
\end{lstlisting}">

$00A8 F_GETCWD

img92.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_getcwd(unsigned char *buf)
\end{lstlisting}">

Get current working directory.

F_GETCWD_DRIVE

img93.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_getcwd_drive(unsigned char drive, char *buf)
\end{lstlisting}">

$00B1 F_GETFREE

img94.svg"
ALT="\begin{lstlisting}[language=C]
uint32_t esx_f_getfree(void)
\end{lstlisting}">

Gets free space on drive.

$00AA F_MKDIR

img95.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_mkdir(unsigned char *pathname)
\end{lstlisting}">

Create directory.

$009A F_OPEN

img96.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_open(unsigned char *filename,unsigned char mode)
\end{lstlisting}">

Open a file.

$00A3 F_OPENDIR

img97.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_opendir(unsigned char *dirnam...
...gned char esx_f_opendir_ex(unsigned char *dirname,uint8_t mode)
\end{lstlisting}">

Open directory.

$009A F_OPEN

img98.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_open_p3(unsigned char *filename,unsigned char mode,struct esx_p3_hdr *h)
\end{lstlisting}">

Open a file.

$009D F_READ

img99.svg"
ALT="\begin{lstlisting}[language=C]
uint16_t esx_f_read(unsigned char handle, void *dst, size_t nbytes)
\end{lstlisting}">

Read bytes from file.

$00A4 F_READDIR

img100.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_readdir(unsigned char handle,struct esx_dirent *dirent)
\end{lstlisting}">

Read next directory entry.

$00B0 F_RENAME

img101.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_rename(unsigned char *old, unsigned char *new)
\end{lstlisting}">

Rename or move a file.

$00A7 F_REWINDDIR

img102.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_rewinddir(unsigned char handle)
\end{lstlisting}">

Rewind directory position to the start of the directory.

$00AB F_RMDIR

img103.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_rmdir(unsigned char *pathname)
\end{lstlisting}">

Remove directory.

$009F F_SEEK

img104.svg"
ALT="\begin{lstlisting}[language=C]
uint32_t esx_f_seek(unsigned char handle, uint32_t distance, unsigned char whence)
\end{lstlisting}">

Seek to position in file.

$00A6 F_SEEKDIR

img105.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_seekdir(unsigned char handle,uint32_t pos)
\end{lstlisting}">

Set current directory position.

$00AC F_STAT

Get unopened file information/status.

$009C F_SYNC

img106.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_sync(unsigned char handle)
\end{lstlisting}">

Sync file changes to disk.

$00A5 F_TELLDIR

img107.svg"
ALT="\begin{lstlisting}[language=C]
uint32_t esx_f_telldir(unsigned char handle)
\end{lstlisting}">

Get current directory position.

$00AE F_TRUNC

img108.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_trunc(unsigned char *filename,uint32_t size)
\end{lstlisting}">

Truncate/extend unopened file.

$00AD F_UNLINK

img109.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_unlink(unsigned char *filename)
\end{lstlisting}">

Delete file.

$009E F_WRITE

img110.svg"
ALT="\begin{lstlisting}[language=C]
uint16_t esx_f_write(unsigned char handle, void *src, size_t nbytes)
\end{lstlisting}">

Write bytes to file.

IDE_BANK_ALLOC

img111.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_bank_alloc(unsigned char banktype)
\end{lstlisting}">

IDE_BANK_AVAIL

img112.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_bank_avail(unsigned char banktype)
\end{lstlisting}">

IDE_BANK_FREE

img113.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_bank_free(unsigned char banktype, unsigned char page)
\end{lstlisting}">

IDE_BANK_RESERVE

img114.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_bank_reserve(unsigned char banktype,unsigned char page)
\end{lstlisting}">

IDE_BANK_TOTAL

img115.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_bank_total(unsigned char banktype)
\end{lstlisting}">

IDE_BROWSER

img116.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_browser(uint8_t browsercaps, void *filetypes, char *help,char *dst_sfn, char *dst_lfn)
\end{lstlisting}">

IDE_GET_LFN

img117.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_get_lfn(struct esx_lfn *dir, struct esx_cat_entry *query)
\end{lstlisting}">

IDE_MODE_GET

img118.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_mode_get(struct esx_mode *mode)
\end{lstlisting}">

IDE_MODE_SET

img119.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_mode_set(struct esx_mode *mode)
\end{lstlisting}">

$0088 M_DOSVER

Get API version/mode information.

$0092 M_DRVAPI

img120.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_m_drvapi(struct esx_drvapi *)
\end{lstlisting}">

Access API for installable drivers.

$0095 M_ERRH

img121.svg"
ALT="\begin{lstlisting}[language=C]
void esx_m_errh(void (*handler)(uint8_t error))
\end{lstlisting}">

Install error handler for dot command.

$008F M_EXECCMD

img122.svg"
ALT="\begin{lstlisting}[language=C]
uint16_t esx_m_execcmd(unsigned char *cmdline)
\end{lstlisting}">

Execute a dot command.

$008E M_GETDATE

img123.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_m_getdate(struct dos_tm *)
\end{lstlisting}">

Get the current date/time.

$0093 M_GETERR

img124.svg"
ALT="\begin{lstlisting}[language=C]
void esx_m_geterr(uint16_t error,unsigned char *msg)
\end{lstlisting}">

$008D M_GETHANDLE

img125.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_m_gethandle(void)
\end{lstlisting}">

Get the file handle of the currently running dot command

$0089 M_GETSETDRV

img126.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_m_getdrv(void)
unsigned char esx_m_setdrv(unsigned char drive)
\end{lstlisting}">

Get or set the default drive.

$0091 M_SETCAPS

img127.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_m_setcaps(unsigned char caps)
\end{lstlisting}">

$008B M_TAPEIN

img128.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_m_tapein_close(void)
unsigned c...
...s(uint16_t block)
unsigned char esx_m_tapein_toggle_pause(void)
\end{lstlisting}">

Tape input redirection control.

$008C M_TAPEOUT

img129.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char esx_m_tapeout_close(void)
unsigned ...
...ame)
unsigned char esx_m_tapeout_trunc(unsigned char *filename)
\end{lstlisting}">

Tape output redirection control.

SLICE_DIRENT

img130.svg"
ALT="\begin{lstlisting}[language=C]
struct esx_dirent_slice *esx_slice_dirent(struct esx_dirent *)
\end{lstlisting}">

EXTENDED_SNA_LOAD

img131.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char extended_sna_load(unsigned char handle)
\end{lstlisting}">

P3DOS_COPY_CSTR_TO_PSTR

img132.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char *p3dos_copy_cstr_to_pstr(char *pdst, const char *csrc)
\end{lstlisting}">

P3DOS_COPY_PSTR_TO_CSTR

img133.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char *p3dos_copy_pstr_to_cstr(char *cdst, const char *psrc)
\end{lstlisting}">

P3DOS_CSTR_TO_PSTR

img134.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char *p3dos_cstr_to_pstr(unsigned char *s)
\end{lstlisting}">

P3DOS_DOSNAME_FROM_CATNAME

img135.svg"
ALT="\begin{lstlisting}[language=C]
char *p3dos_dosname_from_catname(char *dosname, char *catname)
\end{lstlisting}">

P3DOS_EDRV_FROM_PDRV

img136.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char p3dos_edrv_from_pdrv(unsigned char pdrv)
\end{lstlisting}">

P3DOS_PDRV_FROM_EDRV

img137.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char p3dos_pdrv_from_edrv(unsigned char edrv)
\end{lstlisting}">

P3DOS_PSTR_TO_CSTR

img138.svg"
ALT="\begin{lstlisting}[language=C]
unsigned char *p3dos_pstr_to_cstr(unsigned char *s)
\end{lstlisting}">

@node NODE152


@{h1}Ports


------------------------------------------
Subsections

@{ "8-bit" LINK NODE153 }

@{ "16-bit" LINK NODE154 }


------------------------------------------
@node NODE153


@{h1}8-bit

Port $6B (6B) DMA Control (Z80 Mode, 3.01.02)

Port $0F (0F) DAC B
&nbsp;bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $1F (1F) Kempston/Mega Drive Joystick 1/DAC A

Read
&nbsp;bit 7 = &rdquo;start&rdquo; button
&nbsp;bit 6 = A/X button
&nbsp;bit 5 = C/Z button
&nbsp;bit 4 = Fire/C/Y button
&nbsp;bit 3 = Up
&nbsp;bit 2 = Down
&nbsp;bit 1 = Left
&nbsp;bit 0 = Right

Disable with Nextreg $05

Write
&nbsp;bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08
Port $37 (37) Kempston/Mega Drive Joystick 2

Read
&nbsp;bit 7 = &rdquo;start&rdquo; button
&nbsp;bit 6 = A/X button
&nbsp;bit 5 = C/Z button
&nbsp;bit 4 = Fire/C/Y button
&nbsp;bit 3 = Up
&nbsp;bit 2 = Down
&nbsp;bit 1 = Left
&nbsp;bit 0 = Right

Disable with Nextreg $05

Write ($00 on reset, 3.01.04)
&nbsp;bits 7-6 = Select I/O Mode
&nbsp;00 = Bit Bang

&nbsp;01 = Clock

&nbsp;10 = UART

&nbsp;11 = Reserved (don't use)

&nbsp;bit 5 = Reserved, must be 0
&nbsp;bit 4 = Select Joystick Port for Read
&nbsp;0 = Left

&nbsp;1 = Right

&nbsp;bits 3-1 = Reserved, must be $00
&nbsp;bit 0 = Pin 7 state (both ports)

* Bit Bang - bit 0 on pin 7

* Clock - clock on pin 7

0 = Slow clock (Fsys/2048 = 12.672 kHz)

1 = Fast clock (Fsys/8 = 3.5 MHz)

* UART - Pin 7 = TX, Pin 9 = RX
0 = ESP

1 = Pi

** A Runt clock may appear in the first cycle

The I/O mode should be set by writing this port first followed by
enabling io mo de on the joysticks with a write to nextreg 0x05.

Port $3F (3F) DAC A
&nbsp;bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $4F (4F) DAC C
&nbsp;bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $57 (57) Sprite Attributes

Byte 1
&nbsp;bits 7-0 = LSB of X coordinate (bit 8 is in byte 3)

Byte 2
&nbsp;bits 7-0 = LSB of Y coordinate (bit 8 is in byte 5)

Byte 3
&nbsp;bits 7-4 = Palette Offset
&nbsp;bit 3 = Enable X Mirror
&nbsp;bit 2 = Enable Y Mirror
&nbsp;bit 1 = Enable Roration
&nbsp;bit 0 = By Sprite Type
&nbsp;Anchor = MSB of X coordinate

&nbsp;Relative = Enable relative palette offset

Byte 4
&nbsp;bit 7 = Enable visibility
&nbsp;bit 6 = Enable Byte 5
&nbsp;bit 5-0 = Pattern Index (&ldquo;name&rdquo;)

Byte 5 (optional)

Anchor
&nbsp;bit 7-6 = type and pattern
&nbsp;00 = 8-bit color

&nbsp;01 = relative

&nbsp;10 = 4-bit color, lower half of pattern (bytes 0-127)

&nbsp;11 = 4-bit color, upper half of pattern (byets 128-255)

&nbsp;bit 5 = Attached relative sprite type
&nbsp;0 = composite

&nbsp;1 = big sprite

&nbsp;bit 4-3 = X-axis scale factor
&nbsp;00 = img37.svg"
ALT="$1\times$">

&nbsp;01 = img34.svg"
ALT="$2\times$"> 

&nbsp;10 = img35.svg"
ALT="$4\times$"> 

&nbsp;11 = img36.svg"
ALT="$8\times$">

&nbsp;bit 2-1 = Y-axis scale factor
&nbsp;bit 0 = MSB of Y coordinate

Composite Relative
&nbsp;bits 7-6 = 01
&nbsp;bit 5 = N6

8-bit
&nbsp;Reserved, must be 0

4-bit
&nbsp;0 = lower half of pattern (bytes 0-127)

&nbsp;1 = upper half of pattern (bytes 128-255)

&nbsp;bit 4-3 = X-axis scale factor
&nbsp;bit 2-1 = Y-axis scale factor
&nbsp;bit 0 = Enable relative pattern offset

Big-sprite Relative
&nbsp;bits 7-6 = 01
&nbsp;bit 5 = N6

8-bit
&nbsp;Reserved, must be 0

4-bit
&nbsp;0 = lower half of pattern (bytes 0-127)

&nbsp;1 = upper half of pattern (bytes 128-255)

&nbsp;bit 4-1 = Reserved, must be 0
&nbsp;bit 0 = Enable relative pattern offset

Port $5B (5B) Sprite Pattern

Load data into sprite pattern memory auto-incrementing. Port $303B
can be used to set the starting sprite pattern number.

Port $5F (5F) DAC D
&nbsp;bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $6B (6B) DMA Control (Next Mode, 3.01.02)

Port $DF (DF) DAC A,D
&nbsp;bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $E3 (E3) divMMC Control

Disable with bit 2 of Nextreg $09
&nbsp;bit 7 = conmem, enable divMMC memory
&nbsp;bit 6 = mapram, enable divMMC allRAM mode
&nbsp;bits 3-0 = bank, selected divMMC ram bank for $2000-$3FFF region
conmem can be used to manually control divMMC mapping. When enabled
$0000-$1FFF contains esxDOS ROM or esxDOS page 3
$2000-$3FFF contains esxDOS RAM page selected by bits 3-0
divMMC automatically maps itself in when instruction fetches hit
specific addresses in the ROM. When this happens, the esxDOS ROM (or divMMC
bank 3 if mapram is set) appears in $0000-$1FFF and the selected divMMC
bank appears as RAM in $2000-$3FFF
bit 6 can only be set, once set only a power cycle can reset it.
nextreg $09 bit 3 can be set to reset this bit.

divMMC automapping is normally disabled by NextZXOS see nextreg $06 bit 4.

Port $E7 (E7) SPI <!-- MATH
$\overline{\hbox{CS}}$
-->
img56.svg"
ALT="$\overline{\hbox{CS}}$"> (SD card, flash, rpi)

Disable with bit 2 of Nextreg $09

Port $EB (EB) SPI <!-- MATH
$\overline{\hbox{DATA}}$
-->
img57.svg"
ALT="$\overline{\hbox{DATA}}$"> (SD card, flash, rpi)

Disable with bit 2 of Nextreg $09

Port $F1 (F1) DAC A (precedence over $xxFD)
&nbsp;bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $F3 (F3) DAC B
&nbsp;bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $F9 (F9) DAC C (precedence over $xxFD)
&nbsp;bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $FB (FB) DAC A,D
&nbsp;bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $FE (FE) ULA
&nbsp;bits 7-5 = Unused
&nbsp;bit 4 = enable ear output 
&nbsp;bit 3 = enable mic output
&nbsp;bit 2-0 = border colour 

Port $FF (FF) Timex Sinclair/Floating Bus
&nbsp;bit 7 = memory paging (not on ZX Next)
&nbsp;bit 6 = Disable generation of interrupts
&nbsp;bit 5-3 = Hi-res mode color combination
&nbsp;000 = Black on white (indexes 0, 135)

&nbsp;001 = Blue on Yellow (indexes 1, 134)

&nbsp;010 = Green on Magenta (indexes 2, 133)

&nbsp;011 = Cyan on Red (indexes 3, 132)

&nbsp;100 = Red on Cyan (indexes 4, 131)

&nbsp;101 = Magenta on Green (indexes 5, 130)

&nbsp;110 = Yellow on Blue (indexes 6, 129)

&nbsp;111 = White on Black (indexes 7, 128)

&nbsp;bit 2-0 = ULA Mode
&nbsp;000 = Normal ULA address

&nbsp;001 = Alternate ULA address

&nbsp;010 = Hi-color mode 

&nbsp;110 = Hi-res mode

Disable with bit 2 of Nextreg $08

@node NODE154


@{h1}16-bit

Port $103B (103B)  I2C SCL (rtc, rpi)

Port $113B (113B)  I2C SDA (rtc, rpi)

Port $123B (123B) Layer 2

Bit 4 = 0
&nbsp;bits 7-6 = Video RAM bank select
&nbsp;00 = first 16k

&nbsp;01 = second 16k

&nbsp;10 = third 16k

&nbsp;11 = first 48k

&nbsp;bit 5 = Reserved, must be 0
&nbsp;bit 4 = 0
&nbsp;bit 3 = Shadow layer 2 select
&nbsp;bit 2 = Enable layer 2 read paging
&nbsp;bit 1 = Layer 2 visible (mirrored in register $69)
&nbsp;bit 0 = Enable layer 2 write paging

Bit 4 = 1
&nbsp;bits 7-5 = Reserved, must be 0
&nbsp;bit 4 = 1
&nbsp;bit 3 = Reserved, must be 0
&nbsp;bit 2-0 = 16k bank relative offset

Port $133B (133B) UART tx

Read: UART Status
&nbsp;bits 7-4 = Reserved (0)
&nbsp;bit 3 = UART at least half full (3.01.09)
&nbsp;bit 2 = UART full
&nbsp;bit 1 = UART transmit busy
&nbsp;bit 0 = UART receive has data

Write: UART Transmit

Port $143B (143B) UART rx

Read: UART Receive

Write: UART Prescalar
&nbsp;bit 7 = select prescalar part
&nbsp;0 = Bits 6-0 of prescalar

&nbsp;1 = Bits 13-7 of prescalar

&nbsp;bits 6-0 = Prescalar bits

Port $153B (153B) UART select
&nbsp;bit 7 = Reserved (0)
&nbsp;bit 6 = UART select (0 on soft reset) **
&nbsp;0 = ESP

&nbsp;1 = Pi *

&nbsp;bit 5 = Reserved (0)
&nbsp;bit 4 = Prescalar valid in this write
&nbsp;bit 3 = Reserved (0)
&nbsp;bits 2-0 = Bits 16-14 of prescalar (0 on hard reset)

* Pi GPIO must be configured for UART, see nextreg $A0
** Either UART can be redirected to the joystick ports, see port $037

Port $153B (153B) UART frame (upcoming)
($18 on hard reset)
&nbsp;bit 7 = Immediately reset Rx and Tx to idle and empty FIFOs
&nbsp;bit 6 = Assert break (Tx=0) when Tx reaches idle
&nbsp;bit 5 = Enable hardware flow control *
&nbsp;bits 4-3 = Number of bits in a frame
&nbsp;00 = 5 bits

&nbsp;01 = 6 bits

&nbsp;10 = 7 bits

&nbsp;11 = 8 bits

&nbsp;bit 2 = Enable parity
&nbsp;bit 1 = Parity
&nbsp;0 = Even parity

&nbsp;1 = Odd parity

&nbsp;bit 0 = Number of stop bits
&nbsp;0 = 1 stop bit

&nbsp;1 = 2 stop bits

Port $183B (183B) CTC Channel 0
Port $193B (193B) CTC Channel 1
Port $1A3B (1A3B) CTC Channel 2
Port $1B3B (1B3B) CTC Channel 3
Port $1C3B (1C3B) CTC Channel 4
Port $1D3B (1D3B) CTC Channel 5
Port $1E3B (1E3B) CTC Channel 6
Port $183B (183B) CTC Channel 7
Port $1FFD (1FFD) Plus 3 Memory Paging Control
&nbsp;bits 7-3 = Unused, nust be 0
&nbsp;bit 2 = High bit of ROM selection (low bit is in Port $7FFD)
&nbsp;00 = ROM0 = 128k editor and menu system

&nbsp;01 = ROM1 = 128k syntax checker

&nbsp;10 = ROM2 = +3DOS

&nbsp;11 = ROM3 = 48k BASIC

&nbsp;bit 1 = Special mode: Low bit of memory configuration number
&nbsp;bit 0 = Paging mode
&nbsp;0 = Normal

&nbsp;1 = Special

You should echo writes to $5B67

Port $243B (243B) Next Register Select

Port $253B (253B) Next Register Data

Port $303B (303B) Sprite Slot/Flags

Write: Sprite Slot Select

select sprite slot for Sprite Attribute and Sprite Pattern ports which
independently auto-increment

Read: Sprite status
&nbsp;bits 7-2 = reserved
&nbsp;bit 1 = Max sprites per line
&nbsp;bit 0 = Collision flag

Port $7FFD (7FFD) Memory Paging Control
&nbsp;bits 6-7 = reserved
&nbsp;bit 5 = Lock memory paging
&nbsp;bit 4 = low bit of ROM Select (high bit is in Port $1FFD) 
&nbsp;00 = ROM0 = 128k editor and menu system

&nbsp;01 = ROM1 = 128k syntax checker

&nbsp;10 = ROM2 = +3DOS

&nbsp;11 = ROM3 = 48k BASIC

&nbsp;bit 3 = Shadow screen toggle
&nbsp;bits 2-0 = LSB of Bank number for slot 4 (MSB is in Port $DFFD)

Disable with bit 5 port $7FFD

Port $7FFE (7FFE) Keyboard 8 (read only)
&nbsp;bit 0: 'B'
&nbsp;bit 1: 'N'
&nbsp;bit 2: 'M'
&nbsp;bit 3: Symbol Shift
&nbsp;bit 4: Space

Port $BF3B (BF3B) ULAplus register
&nbsp;bits 7-6 = Select register group

* 00 = palette group

* 01 = mode group

&nbsp;bits 5-0 = data
&nbsp;If palette group, selects index 0-63 in ULAplus palette
&nbsp;If mode group, ignored

Port $BFF5 (BFF5) AY Info (3.01.09
(R)
&nbsp;bits 7-6 = Active AY chip

* 01 = AY 0 active

* 10 = AY 1 active

* 11 = AY 2 active

&nbsp;bit 5 = Reserved
&nbsp;bits 4-0 = currently selected AY register

Port $BFFD (BFFD) AY Data

Port $BFFE (BFFE) Keyboard 7 (read only)
&nbsp;bit 0 = 'H'
&nbsp;bit 1 = 'J'
&nbsp;bit 2 = 'K'
&nbsp;bit 3 = 'L'
&nbsp;bit 4 = Enter

Port $DFFD (DFFD) Next Memory Bank Select
&nbsp;bits 7-4 = Reserved, must be 0
&nbsp;bits 3-0 = MSB of bank number for slot 4 (LSB is in Port $7FFD)

Port $DFFE (DFFE) Keyboard 6 (read only)
&nbsp;bit 0 = 'Y'
&nbsp;bit 1 = 'U'
&nbsp;bit 2 = 'I'
&nbsp;bit 3 = 'O'
&nbsp;bit 4 = 'P'

Port $EFF7 (EFF7) Pentagon 1024 paging
&nbsp;bit 3 = 1 to overlay the bottom 16k with ram from 16k bank 0
&nbsp;bit 2 = 0 to enable Pentagon 1024 mapping and disable bit 5 port
0x7ffd locking, 1 to select standard zx128 mapping **
&nbsp;** Applies only when pentagon 1024 mapping mode is enabled via
nextreg 0x8f.

Port $EFFE (EFFE) Keyboard 5 (read only)
&nbsp;bit 0 = ‘6’
&nbsp;bit 1 = ‘7’
&nbsp;bit 2 = ‘8’
&nbsp;bit 3 = ‘9’
&nbsp;bit 4 = ‘0’

Port $F7FE (F7FE) Keyboard 4 (read only)
&nbsp;bit 0 = ‘5’
&nbsp;bit 1 = ‘4’
&nbsp;bit 2 = ‘3’
&nbsp;bit 3 = ‘2’
&nbsp;bit 4 = ‘1’

Port $FADF (FADF) Kempston Mouse Buttons
&nbsp;bits 7-4 = Wheel delta since last read
&nbsp;bit 3 = fourth button
&nbsp;bit 2 = middle button
&nbsp;bit 1 = left button
&nbsp;bit 0 = right button

Port $FBDF (FBDF) Kempston Mouse X
&nbsp;bits 7-0 = X coordinate of mouse

Port $FBFE (FBFE) Keyboard 3 (read only)
&nbsp;bit 0 = ‘T’
&nbsp;bit 1 = ‘R’
&nbsp;bit 2 = ‘E’
&nbsp;bit 3 = ‘W’
&nbsp;bit 4 = ‘Q’

Port $FDFE (FDFE) Keyboard 2 (read only)
&nbsp;bit 0 = ‘G’
&nbsp;bit 1 = ‘F’
&nbsp;bit 2 = ‘D’
&nbsp;bit 3 = ‘S’
&nbsp;bit 4 = ‘A’

Port $FEFE (FEFE) Keyboard 1 (read only)
&nbsp;bit 0 = ‘V’
&nbsp;bit 1 = ‘C’
&nbsp;bit 2 = ‘X’
&nbsp;bit 3 = ‘Z’
&nbsp;bit 4 = Caps Shift

Port $FF3B (FF3B) ULAplus data
&nbsp;If palette group, 8-bit (RRRGGGBB) value for current index
&nbsp;If mode group, bit 1 = enable ULAplus

Port $FFDF (FFDF) Kempston Mouse Y
&nbsp;bits 7-0 = Y coordinate of mouse (0-192)

Port $FFFD (FFFD) AY Control and AY register Select (3.01.09)

Read
&nbsp;bits 7-0 = data in selected register of active AY chip

Select Chip
&nbsp;bit 7 = 1
&nbsp;bit 6 = Enable left
&nbsp;bit 5 = Enable Right
&nbsp;bits 4-2 = Reserved, must be 1
&nbsp;bits 1-0 = AY chip select
&nbsp;00 = Unused

&nbsp;01 = AY 2

&nbsp;10 = AY 1

&nbsp;11 = AY 0

Select Register
&nbsp;bit 7 = 0
&nbsp;bits 6-5 = Reserved, must be 0
&nbsp;bits 4-0 = Register Number

@node NODE155


@{h1}Registers


------------------------------------------
Subsections

@{ "ZX Spectrum Next Registers" LINK NODE156 }

@{ "AY-3-8912" LINK NODE157 }

@{ "zxDMA" LINK NODE158 }


------------------------------------------
@node NODE156


@{h1}ZX Spectrum Next Registers

The ZX Next stores configuration state in a field of registers. These
registers are accessible via two I/O ports or via the special nextreg
instructions.

Port $243B (9275) is used to set the register number, listed below.

Port $253B (9531) is used to access the register value.

Some registers are accessible only during the initialization process.

Register (R) $00 (00) => Machine ID

* 00000001 = DE1A

* 00000010 = DE2A

* 00000101 = FBLABS

* 00000110 = VTRUCCO

* 00000111 = WXEDA

* 00001000 = EMULATORS

* 00001010 = ZX Spectrum Next

* 00001011 = Multicore

* 10101010 = ZX Spectrum Next Core on unAmiga

* 10111010 = ZX Spectrum Next Core on SiDi

* 11001010 = ZX Spectrum Next Core on MIST

* 11011010 = ZX Spectrum Next Core on MiSTer

* 11011010 = ZX Spectrum Next Core on unAmiga Reloaded

* 11101010 = ZX Spectrum Next Core on ZX-DOS

* 11111010 = ZX Spectrum Next Anti-brick

Register (R) $01 (01) => Core Version

bits 7-4 = Major version number
bits 3-0 = Minor version number&nbsp;See register $0E for sub minor version number

Register (R/W) $02 (02) => Reset

Read

* bit 7 = Expansion bus <!-- MATH
$\overline{\hbox{RESET}}$
-->
img4.svg"
ALT="$\overline {\hbox {RESET}}$"> Asserted

* bits 6-4 = Reserved

* bit 3 = Indicates multiface NMI was generated by this nextreg (3.01.09)

* bit 2 = Indicates divmmc NMI was generated by this nextreg (3.01.09)

* bit 1 = Last reset was Hard reset

* bit 0 = Last reset was Soft reset

Write

* bit 7 = Generate/Release Expansion bus <!-- MATH
$\overline{\hbox{RESET}}$
-->
img4.svg"
ALT="$\overline {\hbox {RESET}}$">

* bits 6-4 = Reserved, must be 0

* bit 3 = Generate multiface NMI (write zero to clear)(3.01.09)

* bit 2 = Generate divmmc NMI (write zero to clear)(3.01.09)

* bit 1 = generate Hard reset (reboot)

* bit 0 = generate Soft reset

Register (R/W) $03 (03) => Machine Type

A write to this register disables the boot rom in config mode

bits 2-0 select machine type when in config mode

bit 7 = (W) Display Timing change enable (allow changes to
bits 6-4) (0 on hard reset)
bits 6-4 = Display Timing
bit 3 = Display Timing user lock control
&nbsp;Read

* 0 = No user lock on display timing

* 1 = User lock on display timing

&nbsp;Write

* 1 = Apply user lock on display timing (0 on hard reset)

bits 2-0 = Machine Type (config mode only)

determines roms loaded
&nbsp;Machine Types/Display Timings

* 000 or 001 = ZX 48K

* 010 = ZX 128K/+2 (Grey)

* 011 = ZX +2A-B/+3e/Next Native

* 100 = Pentagon 128K

Register (W) $04 (04) => Configuration Mapping

bits 7 = Reserved, must be 0
bits 6-0 = 16k SRAM bank mapping* ($00 on hard reset)&nbsp;* Maps a 16k SRAM bank over the bottom 16k. Applies only in
config mode when the bootrom is disabled
&nbsp;** Odd multiples of 256k are unreliable if storing data in sram
for the mext core started.
&nbsp;*** number of useful bits changed from 5 to 7 in coure 3.01.06

Register (R/W) $05 (05) => Peripheral 1 Settings

* bits 7-6 = joystick 1 mode (MSB)

* bits 5-4 = joystick 2 mode (MSB)

* bit 3 = joystick 1 mode (LSB)

* bit 2 = 50/60 Hz mode (0 = 50Hz, 1 = 60Hz)

* bit 1 = joystick 2 mode (LSB)

* bit 0 = Enable Scandoubler

Joystick modes

* 000 = Sinclair 2 (67890)

* 001 = Kempston 2 (port $37)

* 010 = Kempston 1 (port $1F)

* 011 = Megadrive 1 (port $1F)

* 100 = Cursor

* 101 = Megadrive 2 (port $37)

* 110 = Sinclair 1 (12345)

* 111 = I/O Mode (3.01.04)
Both joysticks are places in I/O Mode if either is set to I/O
Mode. The underlying joystick type is not changed and reads of this
register will continue to return the last joystick type. Ehether the
joystick is in io mode or not is invisible but this state can be
cleared either through reset or by re-writing the gegister with
joystick type not equal to 111. Recovery time for a normal joystick
read after leaving I/O Mode is at most 64 scan lines.

Register (R/W) $06 (06) => Peripheral 2 Settings

* bit 7 = F8 CPU Speed Hotkey Enable (1 on reset)

* bit 6 = Enable classic audio mode (beep and tape to internal speaker,
other audio to ear and HDMI, 3.01.02)

* bit 5 = F3 50Hz/60Hz Hotkey Enable (1 on reset)

* bit 4 = divMMC Automap/NMI Enable (0 on hard reset)

* bit 3 = NMI Button Enable (0 on hard reset)

* bit 2 = PS/2 Mode (0 = keyboard, 1 = mouse)

* bits 1-0 = PSG Mode (00 = YM, 01 = AY, 11 = hold all PSGs in Reset)

Register (R/W) $07 (07) => Turbo mode

Read

* bits 7-6 = Reserved

* bits 5-4 = Current Actual CPU Speed

* bits 3-2 = Reserved

* bits 1-0 = Current Selected CPU Speed (00 on reset)

Write

* bits 7-2 = Reserved, must be 0

* bits 1-0 = Select CPU Speed

CPU Speeds

* 00 = 3.5MHz

* 01 = 7MHz

* 10 = 14MHz

* 11 = 28MHz

Register (R/W) $08 (08) => Peripheral 3 Settings

* bit 7 = 128K Banking Unlock (inverse of port $7FFD, bit 5) (0
on reset)

* bit 6 = Disable RAM and Port Contention (0 on reset)

* bit 5 = PSG Stereo Mode Control (0 = ABC, 1 = ACB) (0 on hard
reset)

* bit 4 = Enable internal speaker (1 on hard reset)

* bit 3 = Enable DACs (0 on hard reset)

* bit 2 = Enable read of port $FF (Timex) (0 on hard reset)

* bit 1 = Enable Multiple PSGs (0 on hard reset)

* bit 0 = Enable Issue 2 Keyboard

Register (R/W) $09 (09) => Peripheral 4 setting:

bit 7 = PSG 2 Mono Enable (0 on hard reset)
bit 6 = PSG 1 Mono Enable (0 on hard reset)
bit 5 = PSG 0 Mono Enable (0 on hard reset)
bit 4 = Sprite ID lockstep enable (1 = Nextreg $34 and IO Port
$303B are in lockstep, 0 on reset)
bit 3 = divMMC mapRAM bit Control (reset bit 7 of port $E3)
bit 2 = HDMI audio mute (0 on hard reset)
bits 1-0 = scanlines

* 00 = scanlines off

* 01 = scanlines 12.5%

* 10 = scanlines 25%

* 11 = scanlines 50%

&nbsp;In Sprite lockstep, NextREG $34 and Port $303B are in
lockstep

Register (R/W) $0A (0A) => Peripheral 5 setting:

* bits 7-6 = Multiface type (00 on hard reset)

** 00 = Multiface +3 (enable port 0x3F, disable port 0xBF)

** 01 = Multiface 128 v87.2 (enable port 0xBF, disable port 0x3F)

** 10 = Multiface 128 v87.12 (enable port 0x9F, disable port 0x1F)

** 11 = Multiface 1 (enable port 0x9F, disable port 0x1F)

* bits 5-4 = Reserved, must be zero

* bit 3 = 1 to reverse left and right mouse buttons (3.01.07)

* bit 2 = Reserved, must be 0

* bits 1-0 = mouse dpi (00 on hard reset) (3.01.05)

** 00 = low dpi

** 01 = default

** 10 = medium dpi

** 11 = high dpi

Register (R) $0E (0E) => Core Version (sub minor number)

bits 7-0 = Core sub minor version number&nbsp;(see register $01 for the major and minor version number)

Register (R/W) $10 (10) => Core Boot

Read

* bits 7-2 = Reserved

* bit 1 = Drive button pressed

* bit 0 = NMI button pressed

Write

bit 7 = Reboot FPGA using selected core (0 on reset)
bits 6-5 = Reserved, must be 0
bits 4-0 = Core ID&nbsp;Core ID with bits 4-0 can only be set in configuration mode

Register (R/W) $11 (11) => Video Timing (writable in config mode only)

bits 7-3 = Reserved, must be 0
bits 2-0 = Mode (VGA = 0..6, HDMI = 7)

* 000 = Base VGA timing, clk28 = 28000000

* 001 = VGA setting 1, clk28 = 28571429

* 010 = VGA setting 2, clk28 = 29464286

* 011 = VGA setting 3, clk28 = 30000000

* 100 = VGA setting 4, clk28 = 31000000

* 101 = VGA setting 5, clk28 = 32000000

* 110 = VGA setting 6, clk28 = 33000000

* 111 = HDMI, clk28 = 27000000

&nbsp;50/60Hz selection depends on bit 2 of register $05
&nbsp;Only writable in config mode

Register (R/W) $12 (12) => Layer 2 Active RAM bank

* bits 7-6 = Reserved, must be 0

* bits 5-0 = RAM bank (point to bank 8 after a Reset, NextZXOS
modifies to 9)

Register (R/W) $13 (13) => Layer 2 Shadow RAM bank

* bits 7-6 = Reserved, must be 0

* bits 5-0 = RAM bank (point to bank 11 after a Reset, NextZXOS
modifies to 12)

Register (R/W) $14 (14) => Global transparency color

* bits 7-0 = Transparency color value ($E3 after a reset)

(Note: this value is 8-bit, so the transparency is compared against
only by the MSB bits of the final 9-bit colour)
(Note2: this only affects Layer 2, ULA and LoRes. Sprites use register
$4B for transparency and tilemap uses nextreg $4C)

Register (R/W) $15 (15) => Sprite and Layer System Setup

* bit 7 = LoRes mode (0 on reset)

* bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on
top) (0 on reset)

* bit 5 = Enable sprite clipping in over border mode (0 on reset)

* bits 4-2 = set layers priorities (000 on reset)

** 000 - S L U

** 001 - L S U

** 010 - S U L

** 011 - L U S

** 100 - U S L

** 101 - U L S

** 110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7

** 111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]

* bit 1 = Enable Sprites Over border (0 on reset)

* bit 0 = Enable Sprites (0 on reset)

Register (R/W) $16 (16) => Layer 2 Horizontal Scroll Control

* bits 7-0 = X Offset (0-255)(0 on reset)

Register (R/W) $17 (17) => Layer 2 Vertical Scroll Control

* bits 7-0 = Y Offset (0-191)(0 on reset)

Register (R/W) $18 (18) => Layer 2 Clip Window Definition

* bits 7-0 = Coords of the clip window
&nbsp;1st write - X1 position

&nbsp;2nd write - X2 position

&nbsp;3rd write - Y1 position

&nbsp;4rd write - Y2 position

Reads do not advance the clip position

The values are 0,255,0,191 after a Reset

Register (R/W) $19 (19) => Sprite Clip Window Definition

* bits 7-0 = Cood. of the clip window
&nbsp;1st write - X1 position

&nbsp;2nd write - X2 position

&nbsp;3rd write - Y1 position

&nbsp;4rd write - Y2 position

The values are 0,255,0,191 after a Reset

Reads do not advance the clip position

When the clip window is enabled for sprites in "over border" mode, the
X coords are internally doubled and the clip window origin is moved to
the sprite origin inside the border.

Register (R/W) $1A (1A) => Layer 0 (ULA/LoRes) Clip Window Definition

* bits 7-0 = Coord. of the clip window
&nbsp;1st write = X1 position

&nbsp;2nd write = X2 position

&nbsp;3rd write = Y1 position

&nbsp;4rd write = Y2 position

The values are 0,255,0,191 after a Reset

Reads do not advance the clip position

Register (R/W) $1B (1B) => Layer 3 (Tilemap) Clip Window Definition

* bits 7-0 = Coord. of the clip window
&nbsp;1st write = X1 position

&nbsp;2nd write = X2 position

&nbsp;3rd write = Y1 position

&nbsp;4rd write = Y2 position

The values are 0,159,0,255 after a Reset

Reads do not advance the clip position

The X coords are internally doubled.

Register (R/W) $1C (1C) => Clip Window Control

Read

* bits 7-6 = Layer 3 Clip Index

* bits 5-4 = Layer 0/1 Clip Index

* bits 3-2 = Sprite clip index

* bits 1-0 = Layer 2 Clip Index

Write

* bits 7-4 = Reserved, must be 0

* bit 3 - reset Layer 3 clip index

* bit 2 - reset Layer 0/1 clip index

* bit 1 - reset sprite clip index.

* bit 0 - reset Layer 2 clip index.

Register (R) $1E (1E) => Active video line (MSB)

* bits 7-1 = Reserved

* bit 0 = Active line MSB

Register (R) $1F (1F) => Active video line (LSB)

* bits 7-0 = Active line LSB (0-255)

Register (R/W) $22 (22) => Line Interrupt control

* bit 7 = (R) ULA asserting interrupt

* bit 7 = (W) Reserved, must be 0

* bits 6-3 = Reserved, must be 0

* bit 2 = Disable ULA Interrupt (0 on reset)

* bit 1 = Enable Line Interrupt (0 on reset)

* bit 0 = MSB of Line Interrupt line value (0 on reset)

Register (R/W) $23 (23) => Line Interrupt value LSB

* bits 7-0 = Line Interrupt line value LSB (0-255)(0 on reset)

Register (R/W) $26 (26) => ULA Horizontal Scroll Control

* bits 7-0 = ULA X Offset (0-255) (0 on reset)

Register (R/W) $27 (27) => ULA Vertical Scroll Control

* bits 7-0 = ULA Y Offset (0-191) (0 on reset)

Register (R/W) $28 (28) => Stored Palette Value and PS/2 Keymap Address MSB

Read

* bits 7-0 = Stored palette value (see NextREG $44)

Write  

* bits 7-1 = Reserved, must be 0

* bit 0 = PS/2 Keymap Address MSB

Register (W) $29 (29) => PS/2 Keymap Address LSB

* bits 7-0 = PS/2 Keymap Address LSB

Register (W) $2A (2A) => PS/2 Keymap Data MSB

* bits 7-1 = Reserved, must be 0

* bit 0 = PS/2 Keymap Data MSB

Register (W) $2B (2B) => PS/2 Keymap Data LSB

* bits 7-0 = PS/2 Keymap Data LSB

(writing this register auto-increments the address)

Register (R/W) $2C (2C) => DAC B Mirror (Left)/ I2S Left Sample MSB

Read

* bits 7-0 =  I2S Left Sample MSB

Write

* bits 7-0 = 8-bit sample left DAC ($80 on reset)

Register (R/W) $2D (2D) => DAC A+D Mirror (mono/ I2S Sample LSB

Read

* bits 7-0 =  I2S Last Sample LSB

Write

* bits 7-0 = 8-bit sample DACs A + D ($80 on reset)

Register (R/W) $2E (2E) => DAC C Mirror (Right/ I2S Risht Sample MSB

Read

* bits 7-0 =  I2S Right Sameple MSB

Write

* bits 7-0 = 8-bit sample Right DACs C ($80 on reset)

Register (R/W) $2F (2F) => Layer 3 (Tilemap) Horizontal Scroll Control MSB

* bits 7-2 = Reserved, must be 0

* bits 1-0 = X Offset MSB ($00 on reset)

Meaningful Range is 0-319 in 40 char mode, 0-639 in 80 char mode

Register (R/W) $30 (30) => Layer 3 (Tilemap) Horizontal Scroll Control LSB

* bits 7-0 = X Offset LSB ($00 on reset)

Meaningful range is 0-319 in 40 char mode, 0-639 in 80 char mode

Register (R/W) $31 (31) => Layer 3 (Tilemap) Vertical Scroll Control

* bits 7-0 = Y Offset (0-255) )$00 on reset)

Register (R/W) $32 (32) => Layer 1,0 (LoRes) Horizontal Scroll Control)

* bits 7-0 = X Offset (0-255) ($00 on reset)

Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and
smoothness as Layer 2.

Register (R/W) $33 (33) => Layer 1,0 (LoRes) Vertical Scroll Control)

* bits 7-0 = Y Offset (0-191) ($00 on reset)

Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and
smoothness as Layer 2.

Register (R/W) $34 (34) => Sprite Number

Lockstep (NextReg $09 bit 4 set)

bit 7 = Pattern address offset (Add 128 to pattern address)
bits 6-0 = Sprite number 0-127, Pattern number 0-63&nbsp;effectively performs an out to port $303B

No Lockstep (NextReg $09 bit 4 clear)

* bit 7 = Reserved, must be 0

* bits 6-0 = Sprite number 0-127

This register selects which sprite has its attributes connected to the
sprite attribute registers

Register (W) $35 (35) => Sprite Attribute 0

* bits 7-0 = Sprite X coordinate LSB (MSB in NextReg $37)

Register (W) $36 (36) => Sprite Attribute 1

* bits 7-0 = Sprite Y coordinate LSB (MSB in NextReg $39)

Register (W) $37 (37) => Sprite Attribute 2

* bits 7-4 = 4-bit Palette offset

* bit 3 = Enable horizontal mirror (reverse)

* bit 2 = Enable vertical mirror (reverse)

* bit 1 = Enable 90img39.svg"
ALT="$^O$"> Clockwise Rotation

Normal Sprites

* bit 0 = X coordinate MSB

Relative Sprites

* bit 0 = Palette offset is relative to anchor sprite

Rotation is applied before mirroring

Register (W) $38 (38) => Sprite Attribute 3

* bit 7 = Enable Visiblity

* bit 6 = Enable Attribute 4 (0 = Attribute 4 effectively $00)

* bits 5-0 = Sprite Pattern Number

Register (W) $39 (39) => Sprite Attribute 4

Normal Sprites

* bit 7 = 4-bit pattern switch (0 = 8-bit sprite, 1 = 4-bit sprite)

* bit 6 = Pattern number bit-7 for 4-bit, 0 for 8-bit

* bit 5 = Type of attached relative sprites (0 = Composite, 1 =
Unified)

* bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)

* bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)

* bit 0 = MSB of Y coordinate

Relative, Composite Sprites

* bit 7-6 = 01

* bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit

* bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)

* bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)

* bit 0 = Pattern number is relative to anchor

Relative, Unified Sprites

* bit 7-6 = 01

* bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit

* bits 4-1 = 0000

* bit 0 = Pattern number is relative to anchor

Register (R/W) $40 (40) => Palette Index Select

* bits 7-0 = Palette Index Number

Selects the palette index to change the associated colour

For ULA only, INKs are mapped to indices 0 through 7, BRIGHT INKs to
indices 8 through 15, PAPERs to indices 16 through 23 and BRIGHT
PAPERs to indices 24 through 31.  In EnhancedULA mode, INKs come from
a subset of indices from 0 through 127 and PAPERs from a subset of
indices from 128 through 255.

The number of active indices depends on the number of attribute bits
assigned to INK and PAPER out of the attribute byte.

In ULAplus mode, the last 64 entries (indices 192 to 255) hold the
ULAplus palette.  The ULA always takes border colour from PAPER for
standard ULA and Enhanced ULA

Register (R/W) $41 (41) => 8-bit Palette Data

* bits 7-0 = Colour Entry in RRRGGGBB format

The lower blue bit of the 9-bit internal colour will be the logical or
of bits 0 and 1 of the 8-bit entry. After each write, the palette
index auto-increments if aut-increment has been enabled (NextReg $43
bit 7), Reads do not auto-increment.

Register (R/W) $42 (42) => ULANext Attribute Byte Format

* bits 7-0 = Attribute byte's INK representation mask (7 on reset)

The mask can only indicate a solid sequence of bits on the right side
of the attribute byte (1, 3, 7, 15, 31, 63, 127 or 255).

INKs are mapped to base index 0 in the palette and PAPERs and border
are mapped to base index 128 in the palette.

The 255 value enables the full ink colour mode making all the palette
entries INK. PAPER and border both take on the fallback colour
(nextreg $4A) in this mode.

Register (R/W) $43 (43) => Palette Control

* bit 7 = Disable palette write auto-increment.

* bits 6-4 = Select palette for reading or writing:

** 000 = ULA first palette

** 100 = ULA second palette

** 001 = Layer 2 first palette

** 101 = Layer 2 second palette

** 010 = Sprite first palette

** 110 = Sprite second palette

** 011 = Layer 3 first palette

** 111 = Layer 3 second palette

* bit 3 = Select Sprite palette (0 = first palette, 1 = second
palette)

* bit 2 = Select Layer 2 palette (0 = first palette, 1 = second
palette)

* bit 1 = Select ULA palette (0 = first palette, 1 = second
palette)

* bit 0 = Enable EnhancedULA mode if 1. (0 after a reset)

Register (R/W) $44 (44) => 9-bit Palette Data

Non Level 2
&nbsp;1st write
bits 7-0 = MSB (RRRGGGBB)
&nbsp;2nd write
bits 7-1 = Reserved, must be 0
bit 0 = LSB (B)

Level 2
&nbsp;1st write
bits 7-0 = MSB (RRRGGGBB)
&nbsp;2nd write
bit 7 = Priority
bits 6-1 = Reserved, must be 0
bit 0 = LSB (B)

9-bit Palette Data is entered in two consecutive writes; the second
write autoincrements the palette index if auto-increment is enabled in
NextREG $43 bit 7

If writing an L2 palette, the second write's D7 holds the L2 priority
bit which if set (1) brings the colour defined at that index on top of
all other layers. If you also need the same colour in regular priority
(for example: for enviromental masking) you will have to set it up
again, this time with no priority.

Reads return the second byte and do not autoincrement. Writes to
nextreg $40, $41, $41, or $43 reset to the first write.

Register (R/W) $4A (4A) => Fallback Colour Value

* bits 7-0 = 8-bit colour if all layers are transparent ($E3 on
reset)

(black on reset = 0)

Register (R/W) $4B (4B) => Sprite Transparency Index

* bits 7-0 = Index value ($E3 if reset)

For 4-bit sprites only the bottom 4-bits are relevant.

Register (R/W) $4C (4C) => Level 3 Transparency Index

* bits 7-4 = Reserved, must be 0

* bits 3-0 = Index value ($0F on reset)

Register (R/W) $50 (50) => MMU Slot 0 Control

* bits 7-0 = 8k RAM page at position $0000 to $1FFF ($ff on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

A 255 value causes the ROM to become visible.

Register (R/W) $51 (51) => MMU Slot 1 Control

* bits 7-0 = 8k RAM page at position $2000 to $3FFF ($ff on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

A 255 value causes the ROM to become visible.

Register (R/W) $52 (52) => MMU Slot 2 Control

* bits 7-0 = 8k RAM page at position $4000 to $5FFF ($0A on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

Register (R/W) $53 (53) => MMU Slot 3 Control

* bits 7-0 = 8k RAM page at position $6000 to $7FFF ($0B on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

Register (R/W) $54 (54) => MMU Slot 4 Control

* bits 7-0 = 8k RAM page at position $8000 to $9FFF ($04 on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

Register (R/W) $55 (55) => MMU Slot 5 Control

* bits 7-0 = 8k RAM page at position $A000 to $BFFF ($05 on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

Register (R/W) $56 (56) => MMU Slot 6 Control

* bits 7-0 = 8k RAM page at position $C000 to $DFFF ($00 on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

Register (R/W) $57 (57) => MMU Slot 7 Control

* bits 7-0 = 8k RAM page at position $E000 to $FFFF ($01 on
reset)

Pages can be from 0 to 223 on a fully expanded Next.

Writing to ports $1FFD, $7FFD and $DFFD writes $FF to MMU0 and
MMU1 and writes appropriate values to MMU6 and MMU7 to map in the
selected 16k bank.

+3 special modes override the MMUs if used.

Register (W) $60 (60) => Copper Data 8-bit Write

* bits 7-0 = Byte to write to copper instruction memory

Note that each copper instruction is two bytes long, after a write,
the coppen address is auto-incremented to the next memory position.

After a write, the index is auto-incremented to the next memory position.

Register (W) $61 (61) => Copper Address LSB

* bits 7-0 = Copper instruction memory address LSB (0 on reset)

Register (W) $62 (62) => Copper Control

* bits 7-6 = Start Control
&nbsp;00 = Copper fully stopped

&nbsp;01 = Copper start, execute the list from index 0, and loop
to the start

&nbsp;10 = Copper start, execute the list from last point, and
loop to the start

&nbsp;11 = Copper start, execute the list from index 0, and
restart the list when the raster reaches position (0,0)

* bits 2-0 = Copper instruction memory address (MSB) (0 on reset)

Register (W) $63 (63) => Copper Data 16-bit Write

* bits 7-0 = Byte to write to copper instruction memory

The 16-bit value is written in pairs. The first 8-bits are the MSB and
are destined for an even copper instruction address. The sesond 8-bits
are the LSB and are destined for an odd copper instruction address.

After each write, the copper address is auto-incremented to the next
memory position.

After a write to an odd address, the all 16-bits are written to copper
memory at once.

Register (R/W) $64 (64) => Vertical Line Count Offset (3.01.05)

bits 7-0 = Offset added to the vertical line counter&nbsp;affects copper, line interrupt and active line
count.

Normally the ula's pixel row 0 aligns with vertical line count 0.
With a non-zero offset, the ula's pixel row 0 will align with the
vertical line offset.

Eg, if the offset is 32 then vertical line 32 will correspond to
the first pixel row in the ula and vertical line 0 will align with
the first pixel row of the tilemap and sprites.

* Since a change in offset takes effect when the ula reaches row 0,
the change can take up to one frame to occur.
Register (R/W) $68 (68) => ULA Control

bit 7 = Disable ULA output (0 on reset)
bit 6-5 = Color blending control for layering modes 6 &amp; 7 (3.01.01)

* 00 = ULA as blend colour

* 01 = No blending

* 10 = ULA/Tilemap mix result as blend colour

* 11 = Tilemap as blend colour

bit 4 = Cancel entries in 8x5 matrix for extended keys (3.01.04)
bit 3 = Enable ULAplus (0 on reset)
bit 2 = Enable ULA half pixel scroll (0 on reset)&nbsp;may change
bit 1 = Reserved (must be 0)
bit 0 = Enable stencil mode (0 on reset)
&nbsp;When ULA and Layer 3 are enabled, if either are transparent,
the result is transparent, otherwise the result is the logical AND
of both colours.

Register (R/W) $69 (69) => Display Control 1

* bit 7 = Layer 2 Enable (Port $123B bit 1 alias)

* bit 6 = ULA Shadow display enable (Port $7FFD bit 3 alias)

* bits 5-0 = Timex alias (Port $FF alias)

Register (R/W) $6A (6A) => Layer 1,0 (LoRes) Control

* bits 7-6 = reserved, must be 0

* bit 5 = Enable Radistan (16-colour) (0 on reset)

* bit 4 = Radistan DFILE switch (xor with bit 0 of port $ff) (0
on reset)

* bits 3-0 = Radistsan palette offset (0 on reset)

* bits 1-0 = ULAplus palette offset (0 on reset)

Register (R/W) $6B (6B) => Layer 3 (Tilemap) Control

* bit 7 = Layer 3 Enable (0 on reset)

* bit 6 = Layer 3 Size control (0 on reset)

** 0 = 40x32

** 1 = 80x32

* bit 5 = Disable Arrtibute Entry (0 on reset)

* bit 4 = palette select (0 on reset)

* bit 3 = Enable Text mode (1-bit tilemap) (0 on reset)

* bit 2 = Reserved, must be 0

* bit 1 = Activate 512 tile mode (0 on reset)

* bit 0 = Enable Layer 3 on top of ULA (0 on reset)

Register (R/W) $6C (6C) => Default Layer 3 Attribute*

* bits 7-4 = Palette Offset ($00 on reset)

* bit 3 = X mirror (0 on reset)

* bit 2 = Y mirror (0 on reset)

* bit 1 = Rotate (0 on reset)

* bit 0 = Bit 8 of the tile number (512 tile mode) (0 on reset)

* bit 0 = ULA over tilemap (256 tile mode) (0 on reset)

*Active tile attribute if bit 5 of nextreg $6B is set.

Register (R/W) $6E (6E) => Layer 3 Tilemap Base Address

* bit 7 = Bank Select (3.01.08)
&nbsp;0 = Bank 5
&nbsp;1 = Bank 7

* bit 6 = Reserved, must be 0

* bits 5-0 = MSB of address of the tilemap in Bank 5 (16k) or 7 (8k)
($2C on reset)

Soft Reset default $2C - This is because the address is $6C00 so the
MSB is $6C. But the stored value is only the lower 6 bits so it's an
offset into the 16k Bank 5. To calculate therefore subtract $40
leaving you with $2C.

The value written is an offset into the 16k Bank 5 or the 8k lower
half of Bank 7 allowinf the tilemap to be placed at any multiple of
256 bytes.
Register (R/W) $6F (6F) => Layer 3 Tile Definitions Base Address

* bit 7 = Select bank (3.01.08)
&nbsp;0 = Bank 5
&nbsp;1 = Bank 7

* bit 6 = Reserved, must be 0

* bits 5-0 = MSB of address of the tile definitions in Bank 5 (16k) or 7
(8k) ($0C on reset)

Soft Reset default $0C - This is because the address is $4C00 so the
MSB is $4C. But the stored value is only the lower 6 bits so it's an
offset into the 16k Bank 5. To calculate therefore subtract $40
leaving you with $0C.

The value written is an offset into the 16k Bank 5 or the 8k lower
half of Bank 7 allowing the tilemap to be placed at any multiple of
256 bytes.
Register (R/W) $70 (70) => Layer 2 Control

* bits 7-6 = Reserved, must be 0

* bits 5-4 = Resolution (00 on soft reset)

** 00 = <!-- MATH
$256\times192\times256$
-->
img7.svg"
ALT="$256\times192\times256$">

** 01 = <!-- MATH
$320\times256\times256$
-->
img8.svg"
ALT="$320\times256\times256$">

** 10 = <!-- MATH
$640\times256\times16$
-->
img9.svg"
ALT="$640\times256\times16$">

** 11 = Do not use

* bits 3-0 = Palette offset ($0 on soft reset)

Register (R/W) $71 (71) => Layer 2 X Scroll MSB

* bits 7-1 = Reserved, must be 0

* bits 0 = MSB of X Offset

Register (W) $75 (75) => Sprite Attribute 0 (Auto-incrementing)

See nextreg $35

Register (W) $76 (76) => Sprite Attribute 1 (Auto-incrementing)

See nextreg $36

Register (W) $77 (77) => Sprite Attribute 2 (Auto-incrementing)

See nextreg $37

Register (W) $78 (78) => Sprite Attribute 3 (Auto-incrementing)

See nextreg $38

Register (W) $79 (79) => Sprite Attribute 4 (Auto-incrementing)

See nextreg $39

Register (R/W) $7F (7F) => User Register 0

* bits 7-0 = User Register ($FF on hard reset)

Caution NextReg numbers above $7F are inaccessible to the Copper

Register (R/W) $80 (80) => Expansion Bus Enable

Immediate

* bit 7 = Expansion Bus Enable (0 on hard reset)(3.01.07)

* bit 6 = Enable ROMCS ROM replacement from divmmc banks 14/15
(experimental, 3.01.03)

* bit 5 = I/O cycle Disable/Ignore <!-- MATH
$\overline{\hbox{IORQULA}}$
-->
img140.svg"
ALT="$\overline{\hbox{IORQULA}}$"> (0 on
hard reset)

* bit 4 = Memory cycle Disable/Ignore <!-- MATH
$\overline{\hbox{ROMCS}}$
-->
img141.svg"
ALT="$\overline{\hbox{ROMCS}}$"> (0 on
hard reset)

After Soft Reset (Copied into bits 7-4)

* bit 3 = Expansion Bus Enable (0 on hard reset)

* bit 2 = Enable ROMCS ROM replacement from divmmc banks 14/15
(experimental, 3.01.03)

* bit 1 = I/O cycle Disable/Ignore <!-- MATH
$\overline{\hbox{IORQULA}}$
-->
img140.svg"
ALT="$\overline{\hbox{IORQULA}}$"> (0 on
hard reset)

* bit 0 = Memory cycle Disable/Ignore <!-- MATH
$\overline{\hbox{ROMCS}}$
-->
img141.svg"
ALT="$\overline{\hbox{ROMCS}}$"> (0 on
hard reset)

Register (R/W) $81 (81) => Expansion Bus Control

* bit 7 = (R) Expansion bus <!-- MATH
$\overline{\hbox{ROMCS}}$
-->
img141.svg"
ALT="$\overline{\hbox{ROMCS}}$"> asserted

* bit 6 = Allow peripherials to override the ULA on some even
port reads ($00-$0E)(Rotoronics Wafadrive)(3.01.07)

* bit 5 = Disable expansion bus NMI debounce (Opus Discovery)(3.01.07)

* bit 4 = (W) Propagate max CPU clock at all times (0 on hard
reset)

* bits 3-2 = Reserved, must be 0

* bits 1-0 = Max CPU Speed when Expansion Bus is enabled ($00 on
hard reset, currently fixed at $00)

** 00 = 3.5 MHz

** 01 = 7 MHz

** 10 = 14 MHz

** 11 = 28 MHz

Register (R/W) $82 (82) => Internal Port decoding control 1/4

* bit 7 = Enable Kempston Port 2 (Port $37) (1 on reset)

* bit 6 = Enable Kempston Port 1 (Port $1F) (1 on reset)

* bit 5 = Enable DMA (Port $6B) (1 on reset)

* bit 4 = Enable +3 Floating Bus (1 on reset)

* bit 3 = Enable +3 Paging (Port $1FFD) (1 on reset)

* bit 2 = Enable Next Memory Paging (Port $DFFD) (1 on reset)

* bit 1 = Enable Paging (Port $7FFD) (1 on reset)

* bit 0 = Enable Timex (Port $FF) (1 on reset)

Register (R/W) $83 (83) => Internal Port decoding control 2/4

* bit 7 = Enable Layer 2 (Port $123B) (1 on reset)

* bit 6 = Enable Sprites (Ports $57, $5B, $303B) (1 on reset)

* bit 5 = Enable Kempston Mouse (Ports $FADF, $FBDF, $FFDF) (1
on reset)

* bit 4 = Enable UART (Ports $133B, $143B, $153B) (1 on reset)

* bit 3 = Enable SPI (Ports $E7, $EB) (1 on reset)

* bit 2 = Enable  I2C (Ports $103B, $113B) (1 on reset)

* bit 1 = Enable Multiface (two variable ports) (1 on reset)

* bit 0 = Enable divMMC (Port $E3) (1 on reset)

Register (R/W) $84 (84) => Internal Port decoding control 3/4

* bit 7 = Enable SPECdrum Mono DAC (Port $DF) (1 on reset)

* bit 6 = Enable Covox/GS Mono DAC (Port $B3) (1 on reset)

* bit 5 = Enable Pentagon/ATM DAC (Port $FB) (1 on reset)

* bit 4 = Enable Covox Stereo DAC (Ports $0F, $4F) (1 on reset)

* bit 3 = Enable Profi/Covox Stereo DAC (Ports $3F, $5F) (1 on
reset)

* bit 2 = Enable Soundrive DAC Mode 2 (Ports $F1, $F3, $F9,
$FB) (1 on reset)

* bit 1 = Enable Soundrive DAC Mode 1 (Ports $0F, $1F, $4F,
$5F) (1 on reset)

* bit 0 = Enable AY (Ports $FFFD, $BFFD) (1 on reset)

Register (R/W) $85 (85) => Internal Port decoding control 4/4

* bit 7 = Enable configuration of port decoding on soft reset (3.01.01)

* bits 6-4 = Reserved

* bit 3 = Enable Z80 CTC ports $183B, $193B, $1A3B, $1B3B, $1C3B,
$1D3B, $1E3B, and $1F3B

* bit 2 = Enable Pentagon 1024 memory port $EFF7

* bit 1 = Enable DMA port $0B (3.01.02)

* bit 0 = Enable ULAplus (Ports $BF3B, $FF3B) (1 on reset)

Register (R/W) $86 (86) => Expansion Port decoding control 1/4

* bit 7 = Enable Kempston Port 2 (Port $37) (1 on reset)

* bit 6 = Enable Kempston Port 1 (Port $1F) (1 on reset)

* bit 5 = Enable DMA (Port $6B) (1 on reset)

* bit 4 = Enable +3 Floating Bus (1 on reset)

* bit 3 = Enable +3 Paging (Port $1FFD) (1 on reset)

* bit 2 = Enable Next Memory Paging (Port $DFFD) (1 on reset)

* bit 1 = Enable Paging (Port $7FFD) (1 on reset)

* bit 0 = Enable Timex (Port $FF) (1 on reset)

Register (R/W) $87 (87) => Expansion Port decoding control 2/4

* bit 7 = Enable Layer 2 (Port $123B) (1 on reset)

* bit 6 = Enable Sprites (Ports $57, $5B, $303B) (1 on reset)

* bit 5 = Enable Kempston Mouse (Ports $FADF, $FBDF, $FFDF) (1
on reset)

* bit 4 = Enable UART (Ports $133B, $143B, $153B) (1 on reset)

* bit 3 = Enable SPI (Ports $E7, $EB) (1 on reset)

* bit 2 = Enable  I2C (Ports $103B, $113B) (1 on reset)

* bit 1 = Enable Multiface (two variable ports) (1 on reset)

* bit 0 = Enable divMMC (Port $E3) (1 on reset)

Register (R/W) $88 (88) => Expansion Port decoding control 3/4

* bit 7 = Enable SPECdrum Mono DAC (Port $DF) (1 on reset)

* bit 6 = Enable Covox/GS Mono DAC (Port $B3) (1 on reset)

* bit 5 = Enable Pentagon/ATM DAC (Port $FB) (1 on reset)

* bit 4 = Enable Covox Stereo DAC (Ports $0F, $4F) (1 on reset)

* bit 3 = Enable Profi/Covox Stereo DAC (Ports $3F, $5F) (1 on
reset)

* bit 2 = Enable Soundrive DAC Mode 2 (Ports $F1, $F3, $F9,
$FB) (1 on reset)

* bit 1 = Enable Soundrive DAC Mode 1 (Ports $0F, $1F, $4F,
$5F) (1 on reset)

* bit 0 = Enable AY (Ports $FFFD, $BFFD) (1 on reset)

Register (R/W) $89 (89) => Expansion Port decoding control 4/4

* bit 7 = Enable configuration of port decoding on soft reset (3.01.01)

* bits 6-4 = Reserved

* bit 3 = Enable Z80 CTC ports $183B, $193B, $1A3B, $1B3B, $1C3B,
$1D3B, $1E3B, and $1F3B

* bit 2 = Enable Pentagon 1024 memory port $EFF7

* bit 1 = Enable DMA port $0B (3.01.02)

* bit 0 = Enable ULAplus (Ports $BF3B, $FF3B) (1 on reset)

The Internal Port Decoding Enables always apply.

When the Expansion Bus is enabled, the Expansion Bus Port Decoding
Enables are logically ANDed with the Internal Enables. A result of 0
for the corresponding bit indicates the internal device is
disabled. If the Expansion Bus is enabled, this allows
I/O cycles for disabled ports to propagate to the Expansion Bus,
otherwise corresponding I/O cycles to the Expansion Bus are filtered.

Register (R/W) $8A (8A) => Expansion Bus I/O Propagate Control

* bits 7-3 = Reserved, must be 0

* bit 4 = Propagate port $FF I/O Cycles (0 on hard reset, 3.01.02)

* bit 3 = Propagate port $1FFD I/O Cycles (0 on hard reset)

* bit 2 = Propagate port $DFFD I/O Cycles (0 on hard reset)

* bit 1 = Propagate port $7FFD I/O Cycles (0 on hard reset)

* bit 0 = Propagate port $FE I/O Cycles (1 on hard reset, 3.01.03:
0 on hard reset)

Register (R/W) $8C (8C) => Alternate ROM

Immediate

* bit 7 = Alt ROM Enable (0 on hard reset)

* bit 6 = Alt ROM visible ONLY during writes (0 on hard reset)

* bit 5 = Reserved, must be 0

* bit 4 = 48k ROM Lock (0 on hard reset)

After Soft Reset (copied into bits 7-4)

* bit 3 = Alt ROM Enable (0 on hard reset)

* bit 2 = Alt ROM visible ONLY during writes (0 on hard reset)

* bit 1 = Reserved, must be 0

* bit 0 = 48k ROM Lock (0 on hard reset)

Register (R/W) $8E (8E) => Spectrum 128k Memory Mapping (3.01.01)

bit 7 = Bank number bit 3 (port $dffd bit 0)
bit 6-4 = Bank number bits 2-0 (port $7ffd bits 2-0)
bit 3 = Enable change ram page (read as 1)
bit 2 = Paging mode (port $1ffd bit 0)

* 0 = Normal paging mode

* 1 = Special paging mode (lot bit of memory configuration)

&nbsp;Normal Paging Mode
bits 1-0 = ROM selection (port $1ffd bit 1 and $7ffd bit 4)
&nbsp;Special (all RAM) Paging Mode
bits 1-0 = RAM configuration selection (port $1ffd bits 2-1)

Writes can affect all ports $7ffd, $dffd, and $1ffd

Writes can always change the ROM/allRAM mapping

Writes immediately change the current MMU mapping as if by port write.

Register (R/W) $8F (8F) => Memory Mapping Mode (3.01.06)

* bits 7-2 = Reserved, must be zero

* bits 1-0 = Mapping mode applied

** 00 = Standard ZX 128k +3

** 01 = Profi (removed in 3.01.09)

** 10 = Pentagon 512k

** 11 = Pentagon 1024k (limited to 768k on 1MB machines)

* Standard ZX 128k +3 = principally ports $7FFD, $DFFD, and $1FFD
* Pentagon 512k = principally port $7FFD
* Pentagon 1024k = principally ports $7FFD and $EFF7
** The mapping modes affect how ports $7FFD, $DFFD, $1FFD, and $EFF7
carry out memory paging, see ports

Register (R/W) $90 (90) => Pi GPIO output enable 1/4

* bit 7 = Enable Pin 7 (0 on reset)

* bit 6 = Enable Pin 6 (0 on reset)

* bit 5 = Enable Pin 5 (0 on reset)

* bit 4 = Enable Pin 4 (0 on reset)

* bit 3 = Enable Pin 3 (0 on reset)

* bit 2 = Enable Pin 2 (0 on reset)

* bit 1 = Enable Pin 1 (cannot be enabled) (0 on reset)

* bit 0 = Enable Pin 0 (cannot be enabled) (0 on reset)

Register (R/W) $91 (91) => Pi GPIO output enable 2/4

* bit 7 = Enable Pin 15 (0 on reset)

* bit 6 = Enable Pin 14 (0 on reset)

* bit 5 = Enable Pin 13 (0 on reset)

* bit 4 = Enable Pin 12 (0 on reset)

* bit 3 = Enable Pin 11 (0 on reset)

* bit 2 = Enable Pin 10 (0 on reset)

* bit 1 = Enable Pin 9 (0 on reset)

* bit 0 = Enable Pin 8 (0 on reset)

Register (R/W) $92 (92) => Pi GPIO output enable 3/4

* bit 7 = Enable Pin 23 (0 on reset)

* bit 6 = Enable Pin 22 (0 on reset)

* bit 5 = Enable Pin 21 (0 on reset)

* bit 4 = Enable Pin 20 (0 on reset)

* bit 3 = Enable Pin 19 (0 on reset)

* bit 2 = Enable Pin 18 (0 on reset)

* bit 1 = Enable Pin 17 (0 on reset)

* bit 0 = Enable Pin 16 (0 on reset)

Register (R/W) $93 (93) => Pi GPIO output enable 4/4

* bits 7-4 = Reserved

* bit 3 = Enable Pin 27 (0 on reset)

* bit 2 = Enable Pin 26 (0 on reset)

* bit 1 = Enable Pin 25 (0 on reset)

* bit 0 = Enable Pin 24 (0 on reset)

Register (R/W) $98 (98) => Pi GPIO Pin State 1/4

* bit 7 = Pin 7 Data (1 on reset)

* bit 6 = Pin 6 Data (1 on reset)

* bit 5 = Pin 5 Data (1 on reset)

* bit 4 = Pin 4 Data (1 on reset)

* bit 3 = Pin 3 Data (1 on reset)

* bit 2 = Pin 2 Data (1 on reset)

* bit 1 = Pin 1 Data (1 on reset)

* bit 0 = Pin 0 Data (1 on reset)

Register (R/W) $99 (99) => Pi GPIO Pin State 2/4

* bit 7 = Pin 15 Data (1 on reset)

* bit 6 = Pin 14 Data (1 on reset)

* bit 5 = Pin 13 Data (1 on reset)

* bit 4 = Pin 12 Data (1 on reset)

* bit 3 = Pin 11 Data (1 on reset)

* bit 2 = Pin 10 Data (1 on reset)

* bit 1 = Pin 9 Data (1 on reset)

* bit 0 = Pin 8 Data (1 on reset)

Register (R/W) $9A (9A) => Pi GPIO Pin State 3/4

* bit 7 = Pin 23 Data (1 on reset)

* bit 6 = Pin 22 Data (1 on reset)

* bit 5 = Pin 21 Data (1 on reset)

* bit 4 = Pin 20 Data (1 on reset)

* bit 3 = Pin 19 Data (1 on reset)

* bit 2 = Pin 18 Data (1 on reset)

* bit 1 = Pin 17 Data (1 on reset)

* bit 0 = Pin 16 Data (1 on reset)

Register (R/W) $9B (9B) => Pi GPIO Pin State 4/4

* bits 7-4 = Reserved

* bit 3 = Pin 27 Data (1 on reset)

* bit 2 = Pin 26 Data (1 on reset)

* bit 1 = Pin 25 Data (1 on reset)

* bit 0 = Pin 24 Data (1 on reset)

Register (R/W) $A0 (A0) => Pi Peripheral Enable

* bits 7-6 = Reserved, must be 0

* bit 5 = Enable UART on GPIO 14, 15 (0 on reset)*

* bit 4 = Communication Type (0 on reset)

** 0 = Rx to GPIO 15, Tx to GPIO 14 (Pi)

** 1 = Rx to GPIO 14, Tx to GPIO 15 (Pi Hats)

* bit 3 = Enable  I2C on GPIO 2, 3 (0 on reset)*

* bits 2-1 = Reserved, must be 0

* bit 0 = Enable SPI on GPIO 7, 8, 9, 10, 11 (0 on reset)*

*Overrides GPIO Enables

Register (R/W) $A2 (A2) => Pi  I2S Audio Control

* bits 7-6 =  I2S State ($00 on reset)

** 00 =  I2S Disabled

** 01 =  I2S is mono, source R

** 10 =  I2S is mono, source L

** 11 =  I2S is stereo

* bit 5 = Reserved, must be 0

* bit 4 = Audio Flow Direction (0 on reset)

** 0 = PCM_DOUT to Pi, PCM_DIN from Pi (Hats)

** 1 = PCM_DOUT from Pi, PCM_DIN to Pi (Pi)

* bit 3 = Mute left (0 on reset)

* bit 2 = Mute right (0 on reset)

* bit 1 = Slave mode, Reserved must be 1 (remove in 3.01.05)

* bit 0 = Direct  I2S audio to EAR on port $FE (0 on reset)

Register (R/W) $A3 (A3) => Pi  I2S Clock Divide (Master Mode) (removed in 3.01.05)

* bits 7-0 = Clock divide value ($0B on reset)

[<!-- MATH]

$\hbox{Divider}=\frac{538461}{\hbox{Rate}}-1$
-->
img58.svg"
ALT="$\hbox{Divider}=\frac{538461}{\hbox{Rate}}-1$"> or
[<!-- MATH]

$\hbox{Rate}=\frac{538461}{\hbox{Divider}+1}$
-->
img59.svg"
ALT="$\hbox{Rate}=\frac{538461}{\hbox{Divider}+1}$">

Register (R/W) $A8 (A8) => ESP WiFi GPIO Output Enable

* bits 7-3 = Reserved, must be sero

* bit 2 = GPIO2 output enable (fixed at 0, GPIO2 is read-only)

* bit 1 = Reserved, must be zero

* bit 0 = GPIO0 output enable (fixed at 0, GPIO2 is read-only)

Register (R/W) $A9 (A9) => ESP WiFi GPIO

* bits 7-3 = Reserved, must be sero

* bit 2 = Read/Write GPIO2 (reset = 1)

* bit 1 = Reserved, must be zero

* bit 0 = Read/Write GPIO0 (reset = 1)

Register (R) $B0 (B0) => Extended Keys 0 (3.01.04)

* bit 7 = 1 if ; pressed

* bit 6 = 1 if p&#x308;ressed

* bit 5 = 1 if , pressed

* bit 4 = 1 if . pressed

* bit 3 = 1 if UP pressed

* bit 2 = 1 if DOWN pressed

* bit 1 = 1 if LEFT pressed

* bit 0 = 1 if RIGHT pressed

Register (R) $B1 (B1) => Extended Keys 1 (3.01.04)

* bit 7 = 1 if DELETE pressed

* bit 6 = 1 if EDIT pressed

* bit 5 = 1 if BREAK pressed

* bit 4 = 1 if INV VIDEO pressed

* bit 3 = 1 if TRUE VIDEO pressed

* bit 2 = 1 if GRAPH pressed

* bit 1 = 1 if CAPS LOCK pressed

* bit 0 = 1 if EXTEND pressed

Register (R/W) $C0 (C0) => Interrupt Control (3.01.09)
($00 on reset)

* bits 7-5 = Programmable portion of IM2 vector *

* bit 4 = Reserved, must be 0

* bit 3 = Enable stackless <!-- MATH
$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$"> response

* bits 2-1 = Reserved, must be 0

* bit 0 = Maskable interrupt mode
&nbsp;0 - pulse
&nbsp;1 - IM2

* In IM2 mode vector generated is:

* bits 7-5 = nextreg $C0 bits 7-5

* bits 4-1 = Interrupt source
&nbsp;0 - line interrupt (highest priority)
&nbsp;1 - UART 0 Rx
&nbsp;2 - UART 1 Rx
&nbsp;3&ndash;10 - CTC channels 0-7
&nbsp;11 - ULA
&nbsp;12 - UART 0 Tx
&nbsp;13 - UART 1 Tx (lowest priority)

* bit 0 = 0

Register (R/W) $C2 (C2) => <!-- MATH
$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$"> Return Address LSB (3.01.09)
($00 on reset)

Register (R/W) $C3 (C3) => <!-- MATH
$\overline{\hbox{NMI}}$
-->
img5.svg"
ALT="$\overline {\hbox {NMI}}$"> Return Address MSB (3.01.09)
($00 on reset)

Register (R/W) $C4 (C4) => Interrupt Enable 0 (3.01.08)
($83 on reset)

* bit 7 = Expansion bus <!-- MATH
$\overline{\hbox{INT}}$
-->
img6.svg"
ALT="$\overline {\hbox {INT}}$">

* bits 6-2 = Reserved must be zero

* bit 1 = Line

* bit 0 = ULA

Register (R/W) $C5 (C5) => Interrupt Enable 1 (3.01.08)
($00 on reset)

* bit 7 = ctc channel 7 zc/to

* bit 6 = ctc channel 6 zc/to

* bit 5 = ctc channel 5 zc/to

* bit 4 = ctc channel 4 zc/to

* bit 3 = ctc channel 3 zc/to

* bit 2 = ctc channel 2 zc/to

* bit 1 = ctc channel 1 zc/to

* bit 0 = ctc channel 0 zc/to

Register (W) $C6 (C6) => Interrupt Enable 2 (3.01.08)
($00 on reset)

* bit 7 = Reserved, must be 0

* bit 6 = UART1 Tx empty

* bit 5 = UART1 Rx half full *

* bit 4 = UART1 Rx available *

* bit 3 = Reserved, must be 0

* bit 2 = UART0 Tx empty

* bit 1 = UART0 Rx half full *

* bit 0 = UART0 Rx available *

* For each UART, Rx half full and Rx available are shared interrupts

Register (W) $C7 (C7) => Reserved (3.01.09)

Register (R/W) $C8 (C8) => Interrupt Status 0 (3.01.09)
($00 on reset)

* bits 7-2 = Reserved, must be zero

* bit 1 = Line

* bit 0 = ULA

* Set bits indicate the device generated an interrupt in the past
* Writes clear bits where bits are set except in IM2 mode

Register (R/W) $C9 (C9) => Interrupt Status 1 (3.01.09)

* bit 7 = ctc channel 7 zc/to

* bit 6 = ctc channel 6 zc/to

* bit 5 = ctc channel 5 zc/to

* bit 4 = ctc channel 4 zc/to

* bit 3 = ctc channel 3 zc/to

* bit 2 = ctc channel 2 zc/to

* bit 1 = ctc channel 1 zc/to

* bit 0 = ctc channel 0 zc/to

* Set bits indicate the device generated an interrupt in the past
* Writes clear bits where bits are set except in IM2 mode

Register (R/W) $CA (CA) => Interrupt Status 2 (3.01.09)
($00 on reset)

* bit 7 = Reserved, must be zero

* bit 6 = UART1 Tx empty

* bit 5 = UART1 Rx almost full *

* bit 4 = UART1 Rx available *

* bit 3 = Reserved must be zero

* bit 2 = UART0 Tx empty

* bit 1 = UART0 Rx almost full *

* bit 0 = UART0 Rx available *

* For each UART Rx half full and Rx available are shared interrupts
** Set bits indicate the device generated an interrupt in the past
** Writes clear bits where bits are set except in IM2 mode

Register (W) $CB (CB) => Reserved (3.01.09)

Register (R/W) $CC (CC) => DMA Interrupt Enable 0 (3.01.09)
($00 on reset)

* bits 7-2 = Reserved, must be 0

* bit 1 = Line

* bit 0 = ULA

* Set bits indicate the specified interrupt will interrupt a DMA
operation when in IM2 mode

Register (R/W) $CD (CD) => DMA Interrupt Enable 1 (3.01.09)
($00 on reset)

* bit 7 = CTC channel 7 zc/to

* bit 6 = CTC channel 6 zc/to

* bit 5 = CTC channel 5 zc/to

* bit 4 = CTC channel 4 zc/to

* bit 3 = CTC channel 3 zc/to

* bit 2 = CTC channel 2 zc/to

* bit 1 = CTC channel 1 zc/to

* bit 0 = CTC channel 0 zc/to

* Set bits indicate the corresponding interrupt will interrupt a DMA
operation when in IM2 mode

Register (R/W) $CE (CE) => DMA Interrupt Enable 2 (3.01.09)
($00 on reset)

* bit 7 = Reserved, must be 0

* bit 6 = UART1 Tx empty

* bit 5 = UART1 Rx half full

* bit 4 = UART1 Rx available

* bit 3 = Reserved, must be 0

* bit 2 = UART0 Tx empty

* bit 1 = UART0 Tx half full

* bit 0 = UART0 Tx available

* Set bits indicate the corresponding interrupt will interrupt a DMA
operation when in IM2 mode.

Register (W) $CF (CF) => Reserved (3.01.09)

Register (W) $FF (FF) => Debug LEDs (DE-1, DE-2 am Multicore only)

@node NODE157


@{h1}AY-3-8912

(R/W) $00 (0) => Channel A fine tune

* bits 7-0 = Channel A frequency bits 7-0

(R/W) $01 (1) => Channel A coarse tune

* bits 7-4 = Reserved

* bits 4-0 = Channel A frequency bits 11-8

(R/W) $02 (0) => Channel B fine tune

* bits 7-0 = Channel A frequency bits 7-0

(R/W) $03 (1) => Channel B coarse tune

* bits 7-4 = Reserved

* bits 4-0 = Channel A frequency bits 11-8

(R/W) $04 (0) => Channel C fine tune

* bits 7-0 = Channel A frequency bits 7-0

(R/W) $05 (1) => Channel C coarse tune

* bits 7-4 = Reserved

* bits 4-0 = Channel A frequency bits 11-8

(R/W) $06 (6) => Noise period

* bits 7-5 = Reserved

* bits 4-0 = Noise period to noise generator

(R/W) $07 (7) => Mixer control I/O Enable
&nbsp;Active low (0=enable, 1= disable)
bit 7-6: Reserved
bit 5: Channel C noise enable
bit 4: Channel B noise enable
bit 3: Channel A noise enable
bit 2: Channel C tone enable
bit 1: Channel B tone enable
bit 0: Channel A tone enable

(R/W) $0A (10) => Channel A amplitude

* bits 7-5 = Reserved

* bit 4 = Amplitude mode

** 0=fixed amplitude

** 1=use envelope generator (bits 0-3 ignored)

* bits 0-3 = value of fixed amplitude

(R/W) $0B (11) => Channel B amplitude
&nbsp;like channel A amplitude

(R/W) $0C (12) => Channel C amplitude
&nbsp;like channel A amplitude

(R/W) $0D (13) => Envelope period fine

* bits 7-0 = Envelop period LSB

(R/W) $0E (14) => Envelope period coarse

* bits 7-0 = Envelop period MSB

(R/W) $0F (15) => Envelope shape

* bits 7-4 = Reserved

* bit 3 = Continue

** 0=drop to amplitude 0 after 1 cycle

** 1=use ‘Hold’ value

* bit 2 = Attack

** 0=generator counts down

** 1=generator counts up

* bit 1-0 = Alternate &amp; Hold

** 00=generator resets after each cycle

** 01=hold final value

** 10=generator reverses direction each cycle

** 11=hold initial value

@node NODE158


@{h1}zxDMA


------------------------------------------
@node NODE159


@{h1}Extended Opcodes to Mnemonics


------------------------------------------
Subsections

@{ "Single Byte Opcodes" LINK NODE160 }

@{ "$CBxx Bit Operations" LINK NODE161 }

@{ "$DDxx IX" LINK NODE162 }

@{ "$EDxx Block/Port" LINK NODE163 }

@{ "$FDxx IY" LINK NODE164 }

@{ "$DDCBxx IX Bit Operations" LINK NODE165 }

@{ "$FDCBxx IY Bit Operations" LINK NODE166 }


------------------------------------------
@node NODE160


@{h1}Single Byte Opcodes

wIntelN1=,2=,3=,4=,5=,
6=,7=,8=,9=,10=
wIntelTtabular=|l|l|l|r|r||l|l|l|r|r|,
table head=Op&amp;Z80&amp;8080&amp;Sz&amp;T&amp;Op&amp;Z80&amp;8080&amp;Sz&amp;T
,
table foot=,wIntelN

zilogN1=,2=,3=,4=,
5=,6=,7=,8=
zilogTtabular=|l|l|r|r||l|l|r|r|,
table head=Op&amp;Mnemonic&amp;Sz&amp;T&amp;Op&amp;Mnemonic&amp;Sz&amp;T
,
table foot=,zilogN


------------------------------------------
@node NODE161


@{h1}$CBxx Bit Operations


------------------------------------------
@node NODE162


@{h1}$DDxx IX


------------------------------------------
@node NODE163


@{h1}$EDxx Block/Port


------------------------------------------
@node NODE164


@{h1}$FDxx IY


------------------------------------------
@node NODE165


@{h1}$DDCBxx IX Bit Operations


------------------------------------------
@node NODE166


@{h1}$FDCBxx IY Bit Operations


------------------------------------------
@node NODE167


@{h1}Mnemonics to Extended Opcodes

@node NODE168


@{h1}File Formats


------------------------------------------
Subsections

@{ "BAS" LINK NODE169 }

@{ "BMP" LINK NODE170 }

@{ "DSK" LINK NODE171 }

@{ "NDR" LINK NODE172 }

@{ "NEX" LINK NODE173 }

@{ "O" LINK NODE174 }

@{ "P3D" LINK NODE175 }

@{ "PT3" LINK NODE176 }

@{ "P" LINK NODE177 }

@{ "SCR" LINK NODE178 }

@{ "SHC" LINK NODE179 }

@{ "SHR" LINK NODE180 }

@{ "SL2" LINK NODE181 }

@{ "SLR" LINK NODE182 }

@{ "SNA" LINK NODE183 }

@{ "SNX" LINK NODE184 }

@{ "SPR" LINK NODE185 }

@{ "TAP" LINK NODE186 }

@{ "TXT,DOC,ASM,INI,CFG,MD" LINK NODE187 }

@{ "TZX" LINK NODE188 }

@{ "Z3 to Z8" LINK NODE189 }

@{ "Z80" LINK NODE190 }


------------------------------------------
@node NODE169


@{h1}BAS


------------------------------------------
@node NODE170


@{h1}BMP


------------------------------------------
@node NODE171


@{h1}DSK


------------------------------------------
@node NODE172


@{h1}NDR


------------------------------------------
@node NODE173


@{h1}NEX


------------------------------------------
@node NODE174


@{h1}O


------------------------------------------
@node NODE175


@{h1}P3D


------------------------------------------
@node NODE176


@{h1}PT3


------------------------------------------
@node NODE177


@{h1}P


------------------------------------------
@node NODE178


@{h1}SCR


------------------------------------------
@node NODE179


@{h1}SHC


------------------------------------------
@node NODE180


@{h1}SHR


------------------------------------------
@node NODE181


@{h1}SL2


------------------------------------------
@node NODE182


@{h1}SLR


------------------------------------------
@node NODE183


@{h1}SNA


------------------------------------------
@node NODE184


@{h1}SNX


------------------------------------------
@node NODE185


@{h1}SPR


------------------------------------------
@node NODE186


@{h1}TAP


------------------------------------------
@node NODE187


@{h1}TXT,DOC,ASM,INI,CFG,MD


------------------------------------------
@node NODE188


@{h1}TZX


------------------------------------------
@node NODE189


@{h1}Z3 to Z8


------------------------------------------
@node NODE190


@{h1}Z80


------------------------------------------
@node NODE191


@{h1}Call Tables


------------------------------------------
Subsections

@{ "BDOS Call Table" LINK NODE192 }

@{ "BIOS Call Table" LINK NODE193 }

@{ "NextZXOS Calls" LINK NODE194 }

* @{ "+3DOS Compatible Calls" LINK NODE195 }

* @{ "+3DOS compatible error codes" LINK NODE196 }

* @{ "esxDOS Compatible Calls" LINK NODE197 }


------------------------------------------
@node NODE192


@{h1}BDOS Call Table


------------------------------------------
@node NODE193


@{h1}BIOS Call Table


------------------------------------------
@node NODE194


@{h1}NextZXOS Calls


------------------------------------------
Subsections

@{ "+3DOS Compatible Calls" LINK NODE195 }

@{ "+3DOS compatible error codes" LINK NODE196 }

@{ "esxDOS Compatible Calls" LINK NODE197 }


------------------------------------------
@node NODE195


@{h2}+3DOS Compatible Calls

Filesystem Calls

DOS_VERSION
$0103 (0103)
Get +3DOS issue and version numbers
&nbsp;
&nbsp;
&nbsp;
&nbsp;

*DOS_OPEN
$0106 (0106)
Create and/or open a file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_CLOSE
$0109 (0109)
Close a file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_ABANDON
$010C (010C)
Abandon a file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_REF_HEAD
$010F (010F)
Point at the header data for this file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_READ
$0112 (0112)
Read bytes into memory
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_WRITE
$0115 (0115)
Write bytes from memory
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_BYTE_READ
$0118 (0118)
Read a byte
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_BYTE_WRITE
$011B (011B)
Write a byte
&nbsp;
&nbsp;
&nbsp;
&nbsp;

*DOS_CATALOG
$011E (011E)
Catalog disk directory
&nbsp;
&nbsp;
&nbsp;
&nbsp;

*DOS_FREE_SPACE
$0121 (0121)
Free space on disk
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_DELETE
$0124 (0124)
Delete a file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_RENAME
$0127 (0127)
Rename a file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_BOOT
$012A (012A)
Boot an operating system or other program
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_SET_DRIVE
$012D (012D)
Set/get default drive
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_SET_USER
$0130 (0130)
Set/get default user number
&nbsp;
&nbsp;
&nbsp;
&nbsp;

*DOS_GET_POSITION
$0133 (0133)
Get file pointer for random access
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_SET_POSITION
$0136 (0136)
Set file pointer for random access
&nbsp;
&nbsp;
&nbsp;
&nbsp;

*DOS_GET_EOF
$0139 (0139)
Get end of file position for random access
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_GET_1346
$013C (013C)
Get memory usage in pages 1, 3, 4, 6
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_SET_1346
$013F (013F)
Re-allocate memory usage in pages 1, 3, 4, 6
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_FLUSH
$0142 (0142)
Bring disk up to date
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_SET_ACCESS
$0145 (0145)
Change open file's access mode
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_SET_ATTRIBUTES
$0148 (0148)
Change a file's attributes
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_SET_MESSAGE
$014E (014E)
Enable/disable error messages
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_L_XDPB
$0187 (0187)
Initialise an XDPB from a disk specification
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_L_DPB
$018A (018A)
Initialise a DPB from a disk specification
&nbsp;
&nbsp;
&nbsp;
&nbsp;

System Calls

DOS_INITIALISE
$0100 (0100)
Initialise +3DOS
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_INTERFACE
$00A3 (00A3)
Initialise card interfaces
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_INIT
$00A6 (00A6)
Initialise IDEDOS
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_DRIVE
$00A9 (00A9)
Get unit handle
&nbsp;
&nbsp;
&nbsp;
&nbsp;

*IDE_SECTOR_READ
$00AC (00AC)
Low-level sector read
&nbsp;
&nbsp;
&nbsp;
&nbsp;

*IDE_SECTOR_WRITE
$00AF (00AF)
Low-level sector write
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_PARTITON_READ
$00C4 (00C4)
Read a partition entry
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_PARTITION_OPEN
$00CD (00CD)
Open a partition
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_PARTITION_CLOSE
$00D0 (00D0)
Close a partition
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_PARTITIONS
$01A5 (01A5)
Get number of open partitions
&nbsp;
&nbsp;
&nbsp;
&nbsp;

Unimplemented Calls

DOS_OPEN_DRIVE
$014B (014B)
Open a drive as a single file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DOS_MAP_B
$0154 (0154)
Map B: onto unit 0 or 1
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_INTERFACE
$0157 (0157)
Is the floppy disk driver interface present?
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_INIT
$015A (015A)
Initialise disk driver
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_SETUP
$015D (015D)
Specify drive parameters
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_SET_RETRY
$0160 (0160)
Set try/retry count
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_READ_SECTOR
$0163 (0163)
Read a sector
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_WRITE_SECTOR
$0166 (0166)
Write a sector
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_CHECK_SECTOR
$0169 (0169)
Check a sector
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_FORMAT
$016C (016C)
Format a track
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_READ_ID
$016F (016F)
Read a sector identifier
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_TEST_UNSUITABLE
$0172 (0172)
Test media suitability
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_LOGIN
$0175 (0175)
Log in disk, initialise XDPB
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_SEL_FORMAT
$0178 (0178)
Pre-initialise XDPB for DD FORMAT
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_ASK_1
$017B (017B)
Is unit 1 &amp; external drive &amp; present?
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_DRIVE_STATUS
$017E (017E)
Fetch drive status
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_EQUIPMENT
$0181 (0181)
What type of drive?
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_ENCODE
$0184 (0184)
Set intercept routine for copy protection
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_L_SEEK
$018D (018D)
uPD765A seek driver
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_L_READ
$0190 (0190)
uPD765A read driver
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_L_WRITE
$0193 (0193)
uPD765A write driver
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_L_ON_MOTOR
$0196 (0196)
Motor on, wait for motor-on time
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_L_T_OFF_MOTOR
$0199 (0199)
Start the motor-off ticker
&nbsp;
&nbsp;
&nbsp;
&nbsp;

DD_L_OFF_MOTOR
$019C (019C)
Turn the motor off
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_FORMAT
$00B2 (00B2)
Format a partition
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_PARTITION_NEW
$00B8 (00B8)
Create partition
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_PARTITION_INIT
$00BB (00BB)
Initialise partition
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_PARTITION_ERASE
$00BE (00BE)
Delete a partition
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_PARTITION_RENAME
$00C1 (00C1)
Rename a partition
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_PARTITION_WRITE
$00C7 (00C7)
Write a partition entry
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_PARTITION_WINFO
$00CA (00CA)
Write type-specific partition information
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_PARTITION_GETINFO
$00D3 (00D3)
Get byte from type-specific partition information
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_PARTITION_SETINFO
$00D6 (00D6)
Set byte in type-specific partition information
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_DOS_UNPERMANENT
$00FA (00FA)
Remove permanent drive mapping
&nbsp;
&nbsp;
&nbsp;
&nbsp;

IDE_IDENTIFY
$01A2 (01A2)
Return IDE drive identity information
&nbsp;
&nbsp;
&nbsp;
&nbsp;

@node NODE196


@{h2}+3DOS compatible error codes

Recoverable disk errors

0
rc_ready
Drive not ready
&nbsp;
&nbsp;
&nbsp;
&nbsp;

1
rc_wp
Disk is write protected
&nbsp;
&nbsp;
&nbsp;
&nbsp;

2
rc_seek
Seek fail
&nbsp;
&nbsp;
&nbsp;
&nbsp;

3
rc_crc
CRC data error
&nbsp;
&nbsp;
&nbsp;
&nbsp;

4
rc_nodata
No data
&nbsp;
&nbsp;
&nbsp;
&nbsp;

5
rc_mark
Missing address mark
&nbsp;
&nbsp;
&nbsp;
&nbsp;

6
rc_unrecog
Unrecognised disk format
&nbsp;
&nbsp;
&nbsp;
&nbsp;

7
rc_unknown
Unknown disk error
&nbsp;
&nbsp;
&nbsp;
&nbsp;

8
rc_diskchg
Disk changed whilst +3DOS was using it
&nbsp;
&nbsp;
&nbsp;
&nbsp;

9
rc_unsuit
Unsuitable media for drive
&nbsp;
&nbsp;
&nbsp;
&nbsp;

Non-recoverable errors

20
rc_badname
Bad filename
&nbsp;
&nbsp;
&nbsp;
&nbsp;

21
rc_badparam
Bad parameter
&nbsp;
&nbsp;
&nbsp;
&nbsp;

22
rc_nodrive
Drive not found
&nbsp;
&nbsp;
&nbsp;
&nbsp;

23
rc_nofile
File not found
&nbsp;
&nbsp;
&nbsp;
&nbsp;

24
rc_exists
File already exists
&nbsp;
&nbsp;
&nbsp;
&nbsp;

25
rc_eof
End of file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

26
rc_diskfull
Disk full
&nbsp;
&nbsp;
&nbsp;
&nbsp;

27
rc_dirfull
Directory full
&nbsp;
&nbsp;
&nbsp;
&nbsp;

28
rc_ro
Read-only file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

29
rc_number
File number not open (or open with wrong access)
&nbsp;
&nbsp;
&nbsp;
&nbsp;

30
rc_denied
Access denied
&nbsp;
&nbsp;
&nbsp;
&nbsp;

31
rc_norename
Cannot rename between drives
&nbsp;
&nbsp;
&nbsp;
&nbsp;

32
rc_extent
Extent missing
&nbsp;
&nbsp;
&nbsp;
&nbsp;

33
rc_uncached
Uncached
&nbsp;
&nbsp;
&nbsp;
&nbsp;

34
rc_toobig
File too big
&nbsp;
&nbsp;
&nbsp;
&nbsp;

35
rc_notboot
Disk not bootable
&nbsp;
&nbsp;
&nbsp;
&nbsp;

36
rc_inuse
Drive in use
&nbsp;
&nbsp;
&nbsp;
&nbsp;

56
rc_invpartition
Invalid partition
&nbsp;
&nbsp;
&nbsp;
&nbsp;

57
rc_partexist
Partition already exists
&nbsp;
&nbsp;
&nbsp;
&nbsp;

58
rc_notimp
Not implemented
&nbsp;
&nbsp;
&nbsp;
&nbsp;

59
rc_partopen
Partition open
&nbsp;
&nbsp;
&nbsp;
&nbsp;

60
rc_nohandle
Out of handles
&nbsp;
&nbsp;
&nbsp;
&nbsp;

61
rc_notswap
Not a swap partition
&nbsp;
&nbsp;
&nbsp;
&nbsp;

62
rc_mapped
Drive already mapped
&nbsp;
&nbsp;
&nbsp;
&nbsp;

63
rc_noxdpb
No XDPB
&nbsp;
&nbsp;
&nbsp;
&nbsp;

64
rc_noswap
No suitable swap partition
&nbsp;
&nbsp;
&nbsp;
&nbsp;

65
rc_invdevice
Invalid device
&nbsp;
&nbsp;
&nbsp;
&nbsp;

67
rc_cmdphase
Command phase error
&nbsp;
&nbsp;
&nbsp;
&nbsp;

68
rc_dataphase
Data phase error
&nbsp;
&nbsp;
&nbsp;
&nbsp;

69
rc_notdir
Not a directory
&nbsp;
&nbsp;
&nbsp;
&nbsp;

74
rc_fragmented
File is fragmented, use .DEFRAG
&nbsp;
&nbsp;
&nbsp;
&nbsp;

@node NODE197


@{h2}esxDOS Compatible Calls

Low-level calls

disk_filemap
$85 (85)
obtain file allocation map
&nbsp;
&nbsp;
&nbsp;
&nbsp;

disk_strmstart
$86 (86)
start streaming operation
&nbsp;
&nbsp;
&nbsp;
&nbsp;

disk_strmend
$87 (87)
end streaming operation
&nbsp;
&nbsp;
&nbsp;
&nbsp;

Miscellaneous calls

m_dosversion
$88 (88)
get NextZXOS version/mode information
&nbsp;
&nbsp;
&nbsp;
&nbsp;

m_getsetdrv
$89 (89)
get/set default drive
&nbsp;
&nbsp;
&nbsp;
&nbsp;

m_tapein
$8B (8B)
tape redirection control (input)
&nbsp;
&nbsp;
&nbsp;
&nbsp;

m_tapeout
$8C (8C)
tape redirection control (output)
&nbsp;
&nbsp;
&nbsp;
&nbsp;

m_gethandle
$8D (8D)
get handle for current dot command
&nbsp;
&nbsp;
&nbsp;
&nbsp;

m_getdate
$8E (8E)
get current date/time
&nbsp;
&nbsp;
&nbsp;
&nbsp;

m_execcmd
$8F (8F)
execute a dot command
&nbsp;
&nbsp;
&nbsp;
&nbsp;

m_setcaps
$91 (91)
set additional capabilities
&nbsp;
&nbsp;
&nbsp;
&nbsp;

m_drvapi
$92 (92)
access API for installable drivers
&nbsp;
&nbsp;
&nbsp;
&nbsp;

m_geterr
$93 (93)
get or generate error message
&nbsp;
&nbsp;
&nbsp;
&nbsp;

m_p3dos
$94 (94)
execute +3DOS/IDEDOS/NextZXOS call
&nbsp;
&nbsp;
&nbsp;
&nbsp;

m_errh
$95 (95)
register dot command error handler
&nbsp;
&nbsp;
&nbsp;
&nbsp;

File calls

f_open
$9A (9A)
open file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_close
$9B (9B)
close file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_sync
$9C (9C)
sync file changes to disk
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_read
$9D (9D)
read file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_write
$9E (9E)
write file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_seek
$9F (9F)
set file position
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_fgetpos
$A0 (A0)
get file position
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_fstat
$A1 (A1)
get open file information
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_ftruncate
$A2 (A2)
truncate/extend open file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_opendir
$A3 (A3)
open directory for reading
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_readdir
$A4 (A4)
read directory entry
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_telldir
$A5 (A5)
get directory position
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_seekdir
$A6 (A6)
set directory position
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_rewinddir
$A7 (A7)
rewind to start of directory
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_getcwd
$A8 (A8)
get current working directory
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_chdir
$A9 (A9)
change directory
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_mkdir
$AA (AA)
make directory
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_rmdir
$AB (AB)
remove directory
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_stat
$AC (AC)
get unopen file information
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_unlink
$AD (AD)
delete file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_truncate
$AE (AE)
truncate/extend unopen file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_chmod
$AF (AF)
change file attributes
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_rename
$B0 (B0)
rename/move file
&nbsp;
&nbsp;
&nbsp;
&nbsp;

f_getfree
$B1 (B1)
get free space
&nbsp;
&nbsp;
&nbsp;
&nbsp;

@node NODE198


@{h2}List of Figures

Pattern Example

All Rotate and Mirror Flags


------------------------------------------
@node NODE199


@{h2}List of Tables

Layer 1 Mode summary

Layer 1 Memory Map

ULA Colour

ULANext

Hi-Resolution Colours

Special Paging Modes

zxnDMA Registers

Vertical Line Counts and Dot Clock Combinations

Dot Clocks per Second

Maximum Horizontal COPPER Compare

Slack Dot Clocks After Maximum Compare

Horizontal Timing

Vertical Timing

Ideal Extended Resolutions for Both VGA and HDMI

Ideal Extended Resolution Display Parameters

Instruction Bit Definition

Register Bit Definitions

Control Mode Definitions

Summary of Video Modes

System Control Block

Program Return Codes

FCB Format

ZX Spectrum Ports

$00-$1F

$20-$3F

$40-$5F

$60-$7F

$80-$9F

$A0-$BF

$C0-$DF

$E0-$FF

$CB00-$CB1F

$CB20-$CB3F

$CB40-$CB5F

$CB60-$CB7F

$CB80-$CB9F

$CBA0-$CBBF

$CBC0-$CBDF

$CBE0-$CBFF

$DD00-$DD5F

$DD60-$CB8F

$DD90-$DDFF

$ED00-$ED4F

$ED50-$ED8F

$ED90-$EDFF

$FD00-$FD5F

$FD60-$FD8F

$FD90-$FDFF

$DDCB00-$DDCBFF

$FDCB00-$FDCBFF

aci-adc

add

adi-ani

bit 0-bit 3

bit 4-bit 7

brlc-cnz

cp-dcr

dcx-im

in-inx

jc-jz

ld (bc),a-ld (iy+x),x

ld (xx),a-ld a,x

ld b,(hl)-ld c,x

ld d,(hl)-ld e,x

ld h,(hl)-ld ixl,x

ld iyh,a-ld sp,xx

lda-mirror

mov a,a-mov d,m

mov e,a-mov m,l

mul-otir

out-rc

res 0-res 3

res 4-res 7

ret-rp

rr-rz

sbb-scf

set 0-set 3

set 4-set 7

setae-stc

sub-xthl


------------------------------------------
@node NODE200


@{h2}Index

access drive
BDOS
auxiliary input
BDOS
auxiliary input status
BDOS
auxiliary output
BDOS
auxiliary output status
BDOS
AUXIN
Character I/O Functions
AUXIST
Character I/O Functions
AUXOST
Character I/O Functions
AUXOUT
Character I/O Functions
BOOT
System Initialization Functions
call resident system extension
BDOS
chain to program
BDOS
clip window
Programming Tilemap mode
| Global Control of Sprites
close file
BDOS
compute file size
BDOS
CONIN
Character I/O Functions
CONOST
Character I/O Functions
CONOUT
Character I/O Functions
console input
BDOS
console output
BDOS
CONST
Character I/O Functions
delete file
BDOS
DEVINI
System Initialization Functions
DEVTBL
System Initialization Functions
direct BIOS calls
BDOS
direct console I/O
BDOS
DOS_CATALOG
+3DOS compatible API
DOS_FREE_SPACE
+3DOS compatible API
DOS_GET_EOF
+3DOS compatible API
DOS_GET_POSITION
+3DOS compatible API
DOS_OPEN
+3DOS compatible API
DRVTBL
System Initialization Functions
FLUSH
Disk I/O Functions
flush buffers
BDOS
free blocks
BDOS
free drive
BDOS
get addr(alloc)
BDOS
get addr(DPB parms)
BDOS
get console mode
BDOS
get console status
BDOS
get date and time
BDOS
get disk free space
BDOS
get output delimiter
BDOS
get program return code
BDOS
get read-only vector
BDOS
get system control bock
BDOS
get user code
BDOS
HOME
Disk I/O Functions
IDE_BANK
+3DOS compatible API
IDE_BROWSER
+3DOS compatible API
IDE_CAPACITY
+3DOS compatible API
IDE_DOS_MAP
+3DOS compatible API
IDE_DOS_MAPPING
+3DOS compatible API
IDE_DOS_UNMAP
+3DOS compatible API
IDE_GET_LFN
+3DOS compatible API
IDE_PATH
+3DOS compatible API
IDE_SNAPLOAD
+3DOS compatible API
IDE_SWAP_EX
+3DOS compatible API
IDE_SWAP_OPEN
+3DOS compatible API
LIST
Character I/O Functions
list block
BDOS
list output
BDOS
LISTST
Character I/O Functions
load overlay
BDOS
lock record
BDOS
make file
BDOS
MOVE
Memory Select and Move
MULTIO
Disk I/O Functions
open file
BDOS
palette
Palette
| Sprite Palette
parse filename
BDOS
print block
BDOS
print string
BDOS
READ
Disk I/O Functions
read console buffer
BDOS
read file date stamps and password mode
BDOS
read random
BDOS
read sequential
BDOS
rename file
BDOS
reset disk system
BDOS
reset drive
BDOS
return current disk
BDOS
return directory label data
BDOS
return login vector
BDOS
return serial number
BDOS
return version number
BDOS
scroll offset
Programming Tilemap mode
search for first
BDOS
search for next
BDOS
SECTRN
Disk I/O Functions
SELDSK
Disk I/O Functions
select disk
BDOS
SELMEM
Memory Select and Move
set BDOS error mode
BDOS
set console mode
BDOS
set date and time
BDOS
set default password
BDOS
set directory label
BDOS
set dma address
BDOS
set file attributes
BDOS
set multi-sector count
BDOS
set output delimiter
BDOS
set program return code
BDOS
set random record
BDOS
set system control bock
BDOS
set user code
BDOS
SETBNK
Memory Select and Move
SETDMA
Disk I/O Functions
SETSEC
Disk I/O Functions
SETTRK
Disk I/O Functions
system reset
BDOS
test and write record
BDOS
TIME
Clock Support Function
transparency
Video Layering and Transparency
| Programming Tilemap mode
| Global Control of Sprites
truncate file
BDOS
unlock record
BDOS
WBOOT
System Initialization Functions
WRITE
Disk I/O Functions
write file XFCB
BDOS
write protect disk
BDOS
write random
BDOS
write random with zero fill
BDOS
write sequential
BDOS
XMOVE
Memory Select and Move


------------------------------------------
@node NODE201


@{h1}About this document ...

ZX Spectrum Next Programming Notes
This document was generated using the
LaTeX2HTML translator Version 2020.2 (Released July 1, 2020)

The command line arguments were: 
latex2html -images zxnext_notes.tex

The translation was initiated on 2020-12-04


------------------------------------------
@node NODE202


@{h1}About this document ...

ZX Spectrum Next Programming Notes
This document was generated using the
LaTeX2HTML translator Version 2019 (Released January 1, 2019)

The command line arguments were: 
latex2html zxnext_notes.tex

The translation was initiated on 2020-07-06


------------------------------------------
@node ZXNEXT_NOTES

ZX Spectrum Next Programming Notes


------------------------------------------
@{ "Contents" LINK NODE1 }

@{ "Introduction" LINK NODE2 }

@{ "Video" LINK NODE3 }

* @{ "General Features" LINK NODE4 }

** @{ "Video Layering and Transparency" LINK NODE5 }

** @{ "Palette" LINK NODE6 }

** @{ "Scrolling" LINK NODE8 }

** @{ "Clipping" LINK NODE9 }

* @{ "Layer 1" LINK NODE10 }

** @{ "Colour Attributes" LINK NODE11 }

** @{ "Layer 1 Scrolling" LINK NODE21 }

** @{ "Layer 1 Clipping" LINK NODE22 }

** @{ "ZX Spectrum Mode" LINK NODE23 }

** @{ "Alternate Page Mode" LINK NODE24 }

** @{ "Timex Hi-Colour Mode" LINK NODE25 }

** @{ "Timex Hi-Resolution Mode" LINK NODE26 }

** @{ "Lo-Resolution Mode" LINK NODE27 }

* @{ "Layer 2" LINK NODE28 }

** @{ "Configuration" LINK NODE29 }

** @{ "Scrolling" LINK NODE34 }

** @{ "Clipping" LINK NODE35 }

* @{ "Layer 3 (Tilemap) Mode" LINK NODE36 }

** @{ "General Description" LINK NODE37 }

** @{ "Data Structures" LINK NODE38 }

** @{ "Memory Organization &amp; Display Layer" LINK NODE41 }

** @{ "Combining ULA &amp; Tilemap" LINK NODE42 }

** @{ "Programming Tilemap mode" LINK NODE43 }

* @{ "Sprites" LINK NODE46 }

** @{ "Sprite Patterns" LINK NODE47 }

** @{ "Sprite Palette" LINK NODE51 }

** @{ "Sprite Attributes" LINK NODE52 }

** @{ "Relative Sprites" LINK NODE53 }

** @{ "Programming Sprites" LINK NODE54 }

** @{ "Global Control of Sprites" LINK NODE55 }

@{ "Audio" LINK NODE56 }

* @{ "ZX Spectrum 1-bit" LINK NODE57 }

* @{ "Sampled 8-bit" LINK NODE58 }

* @{ "Turbosound" LINK NODE59 }

** @{ "Pi Audio" LINK NODE60 }

@{ "Memory" LINK NODE61 }

* @{ "Memory Management" LINK NODE62 }

** @{ "Default Layout" LINK NODE63 }

** @{ "RAM" LINK NODE64 }

** @{ "ROM" LINK NODE70 }

* @{ "Interactions between paging methods" LINK NODE76 }

* @{ "Memory Map" LINK NODE77 }

** @{ "Global Memory Map" LINK NODE78 }

** @{ "Z80 Visible Memory Map" LINK NODE79 }

@{ "zxnDMA" LINK NODE80 }

* @{ "Overview" LINK NODE81 }

* @{ "Accessing the zxnDMA" LINK NODE82 }

* @{ "Description" LINK NODE83 }

* @{ "Modes of Operation" LINK NODE84 }

* @{ "Programming the zxnDMA" LINK NODE85 }

* @{ "zxnDMA Registers" LINK NODE86 }

* @{ "Programming examples" LINK NODE96 }

@{ "Copper and Display Timing" LINK NODE97 }

* @{ "Timing" LINK NODE100 }

* @{ "Instructions" LINK NODE108 }

* @{ "Control" LINK NODE113 }

* @{ "Configuration" LINK NODE118 }

@{ "Interrupts" LINK NODE123 }

* @{ "Interrupt Types" LINK NODE124 }

* @{ "Interrupt Modes" LINK NODE128 }

* @{ "Z80 CTC" LINK NODE132 }

@{ "Serial Communication" LINK NODE134 }

@{ "Raspberry Pi0 Acceleration" LINK NODE135 }

@{ "System Software" LINK NODE136 }

* @{ "CP/M" LINK NODE137 }

** @{ "Utilities" LINK NODE138 }

** @{ "BDOS" LINK NODE139 }

** @{ "BIOS" LINK NODE140 }

*** @{ "System Initialization Functions" LINK NODE141 }

*** @{ "Character I/O Functions" LINK NODE142 }

*** @{ "Disk I/O Functions" LINK NODE143 }

** @{ "Memory Select and Move Functions" LINK NODE144 }

*** @{ "Clock Support Function" LINK NODE145 }

* @{ "NextZXOS" LINK NODE146 }

* @{ "NextZXOS" LINK NODE147 }

** @{ "+3DOS compatible API" LINK NODE148 }

** @{ "esxDOS compatible API" LINK NODE149 }

** @{ "Next Extensions" LINK NODE150 }

** @{ "esxDOS compatible API" LINK NODE151 }

@{ "Ports" LINK NODE152 }

* @{ "8-bit" LINK NODE153 }

* @{ "16-bit" LINK NODE154 }

@{ "Registers" LINK NODE155 }

* @{ "ZX Spectrum Next Registers" LINK NODE156 }

* @{ "AY-3-8912" LINK NODE157 }

* @{ "zxDMA" LINK NODE158 }

@{ "Extended Opcodes to Mnemonics" LINK NODE159 }

* @{ "Single Byte Opcodes" LINK NODE160 }

* @{ "$CBxx Bit Operations" LINK NODE161 }

* @{ "$DDxx IX" LINK NODE162 }

* @{ "$EDxx Block/Port" LINK NODE163 }

* @{ "$FDxx IY" LINK NODE164 }

* @{ "$DDCBxx IX Bit Operations" LINK NODE165 }

* @{ "$FDCBxx IY Bit Operations" LINK NODE166 }

@{ "Mnemonics to Extended Opcodes" LINK NODE167 }

@{ "File Formats" LINK NODE168 }

* @{ "BAS" LINK NODE169 }

* @{ "BMP" LINK NODE170 }

* @{ "DSK" LINK NODE171 }

* @{ "NDR" LINK NODE172 }

* @{ "NEX" LINK NODE173 }

* @{ "O" LINK NODE174 }

* @{ "P3D" LINK NODE175 }

* @{ "PT3" LINK NODE176 }

* @{ "P" LINK NODE177 }

* @{ "SCR" LINK NODE178 }

* @{ "SHC" LINK NODE179 }

* @{ "SHR" LINK NODE180 }

* @{ "SL2" LINK NODE181 }

* @{ "SLR" LINK NODE182 }

* @{ "SNA" LINK NODE183 }

* @{ "SNX" LINK NODE184 }

* @{ "SPR" LINK NODE185 }

* @{ "TAP" LINK NODE186 }

* @{ "TXT,DOC,ASM,INI,CFG,MD" LINK NODE187 }

* @{ "TZX" LINK NODE188 }

* @{ "Z3 to Z8" LINK NODE189 }

* @{ "Z80" LINK NODE190 }

@{ "Call Tables" LINK NODE191 }

* @{ "BDOS Call Table" LINK NODE192 }

* @{ "BIOS Call Table" LINK NODE193 }

* @{ "NextZXOS Calls" LINK NODE194 }

** @{ "+3DOS Compatible Calls" LINK NODE195 }

** @{ "+3DOS compatible error codes" LINK NODE196 }

** @{ "esxDOS Compatible Calls" LINK NODE197 }

@{ "List of Figures" LINK NODE198 }

@{ "List of Tables" LINK NODE199 }

@{ "Index" LINK NODE200 }

@{ "About this document ..." LINK NODE201 }


------------------------------------------
